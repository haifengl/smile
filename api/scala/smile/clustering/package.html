<!DOCTYPE html >
<html>
        <head>
          <title>clustering - Smile - Statistical Machine Intelligence and Learning Engine - smile.clustering</title>
          <meta name="description" content="clustering - Smile - Statistical Machine Intelligence and Learning Engine - smile.clustering" />
          <meta name="keywords" content="clustering Smile Statistical Machine Intelligence and Learning Engine smile.clustering" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'smile.clustering.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../../lib/package_big.png" />
        <p id="owner"><a href="../package.html" class="extype" name="smile">smile</a></p>
        <h1>clustering</h1><span class="permalink">
      <a href="../../index.html#smile.clustering.package" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">clustering</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Clustering analysis. Clustering is the assignment of a set of observations
into subsets (called clusters) so that observations in the same cluster are
similar in some sense. Clustering is a method of unsupervised learning,
and a common technique for statistical data analysis used in many fields.</p><p>Hierarchical algorithms find successive clusters using previously
established clusters. These algorithms usually are either agglomerative
(&quot;bottom-up&quot;) or divisive (&quot;top-down&quot;). Agglomerative algorithms begin
with each element as a separate cluster and merge them into successively
larger clusters. Divisive algorithms begin with the whole set and proceed
to divide it into successively smaller clusters.</p><p>Partitional algorithms typically determine all clusters at once, but can
also be used as divisive algorithms in the hierarchical clustering.
Many partitional clustering algorithms require the specification of
the number of clusters to produce in the input data set, prior to
execution of the algorithm. Barring knowledge of the proper value
beforehand, the appropriate value must be determined, a problem on
its own for which a number of techniques have been developed.</p><p>Density-based clustering algorithms are devised to discover
arbitrary-shaped clusters. In this approach, a cluster is regarded as
a region in which the density of data objects exceeds a threshold.</p><p>Subspace clustering methods look for clusters that can only be seen in
a particular projection (subspace, manifold) of the data. These methods
thus can ignore irrelevant attributes. The general problem is also known
as Correlation clustering while the special case of axis-parallel subspaces
is also known as two-way clustering, co-clustering or biclustering in
bioinformatics: in these methods not only the objects are clustered but
also the features of the objects, i.e., if the data is represented in
a data matrix, the rows and columns are clustered simultaneously. They
usually do not however work with arbitrary feature combinations as in general
subspace methods.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="smile.clustering"><span>clustering</span></li><li class="in" name="smile.clustering.Operators"><span>Operators</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="smile.clustering.Operators" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="OperatorsextendsAnyRef"></a>
      <a id="Operators:Operators"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Operators.html"><span class="name">Operators</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@OperatorsextendsAnyRef" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">High level cluster analysis operators.</p>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="smile.clustering.Operators#birch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="birch(data:Array[Array[Double]],k:Int,minPts:Int,branch:Int,radius:Double):smile.clustering.BIRCH"></a>
      <a id="birch(Array[Array[Double]],Int,Int,Int,Double):BIRCH"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">birch</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="branch">branch: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.BIRCH">BIRCH</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@birch(data:Array[Array[Double]],k:Int,minPts:Int,branch:Int,radius:Double):smile.clustering.BIRCH" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Balanced Iterative Reducing and Clustering using Hierarchies.</p><div class="fullcomment"><div class="comment cmt"><p>Balanced Iterative Reducing and Clustering using Hierarchies. BIRCH performs
hierarchical clustering over particularly large datasets. An advantage of
BIRCH is its ability to incrementally and dynamically cluster incoming,
multi-dimensional metric data points in an attempt to produce the high
quality clustering for a given set of resources (memory and time constraints).</p><p>BIRCH has several advantages. For example, each clustering decision is made
without scanning all data points and currently existing clusters. It
exploits the observation that data space is not usually uniformly occupied
and not every data point is equally important. It makes full use of
available memory to derive the finest possible sub-clusters while minimizing
I/O costs. It is also an incremental method that does not require the whole
data set in advance.</p><p>This implementation produces a clustering in three steps. First step
builds a CF (clustering feature) tree by a single scan of database.
The second step clusters the leaves of CF tree by hierarchical clustering.
Then the user can use the learned model to cluster input data in the final
step. In total, we scan the database twice.</p><h6>References:</h6><ul><li>Tian Zhang, Raghu Ramakrishnan, and Miron Livny. BIRCH: An Efficient Data Clustering Method for Very Large Databases. SIGMOD, 1996.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>a CF leaf will be treated as outlier if the number of its
              points is less than minPts.</p></dd><dt class="param">branch</dt><dd class="cmt"><p>the branching factor. Maximum number of children nodes.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the maximum radius of a sub-cluster.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#clarans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clarans(data:Array[Array[Double]],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[Array[Double]]"></a>
      <a id="clarans(Array[Array[Double]],Int,Int,Int):CLARANS[Array[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clarans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxNeighbor">maxNeighbor: <span class="extype" name="scala.Int">Int</span></span>, <span name="numLocal">numLocal: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.CLARANS">CLARANS</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@clarans(data:Array[Array[Double]],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[Array[Double]]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Clustering Large Applications based upon RANdomized Search.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering Large Applications based upon RANdomized Search. Euclidean distance is assumed.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxNeighbor</dt><dd class="cmt"><p>the maximum number of neighbors examined during a random search of local minima.</p></dd><dt class="param">numLocal</dt><dd class="cmt"><p>the number of local minima to search for.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#clarans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clarans[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[T]"></a>
      <a id="clarans[T&lt;:AnyRef](Array[T],Distance[T],Int,Int,Int):CLARANS[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clarans</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.clarans.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Distance">Distance</span>[<span class="extype" name="smile.clustering.Operators.clarans.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxNeighbor">maxNeighbor: <span class="extype" name="scala.Int">Int</span></span>, <span name="numLocal">numLocal: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.CLARANS">CLARANS</span>[<span class="extype" name="smile.clustering.Operators.clarans.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@clarans[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,maxNeighbor:Int,numLocal:Int):smile.clustering.CLARANS[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Clustering Large Applications based upon RANdomized Search.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering Large Applications based upon RANdomized Search. CLARANS is an
efficient medoid-based clustering algorithm. The k-medoids algorithm is an
adaptation of the k-means algorithm. Rather than calculate the mean of the
items in each cluster, a representative item, or medoid, is chosen for each
cluster at each iteration. In CLARANS, the process of finding k medoids from
n objects is viewed abstractly as searching through a certain graph. In the
graph, a node is represented by a set of k objects as selected medoids. Two
nodes are neighbors if their sets differ by only one object. In each iteration,
CLARANS considers a set of randomly chosen neighbor nodes as candidate
of new medoids. We will move to the neighbor node if the neighbor
is a better choice for medoids. Otherwise, a local optima is discovered. The
entire process is repeated multiple time to find better.</p><p>CLARANS has two parameters: the maximum number of neighbors examined
(maxNeighbor) and the number of local minima obtained (numLocal). The
higher the value of maxNeighbor, the closer is CLARANS to PAM, and the
longer is each search of a local minima. But the quality of such a local
minima is higher and fewer local minima needs to be obtained.</p><h6>References:</h6><ul><li>R. Ng and J. Han. CLARANS: A Method for Clustering Objects for Spatial Data Mining. IEEE TRANS. KNOWLEDGE AND DATA ENGINEERING, 2002.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance/dissimilarity measure.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxNeighbor</dt><dd class="cmt"><p>the maximum number of neighbors examined during a random search of local minima.</p></dd><dt class="param">numLocal</dt><dd class="cmt"><p>the number of local minima to search for.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dac" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dac(data:Array[Array[Double]],k:Int,alpha:Double):smile.clustering.DeterministicAnnealing"></a>
      <a id="dac(Array[Array[Double]],Int,Double):DeterministicAnnealing"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dac</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DeterministicAnnealing">DeterministicAnnealing</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@dac(data:Array[Array[Double]],k:Int,alpha:Double):smile.clustering.DeterministicAnnealing" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Deterministic annealing clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Deterministic annealing clustering. Deterministic annealing extends
soft-clustering to an annealing process.
For each temperature value, the algorithm iterates between the calculation
of all posteriori probabilities and the update of the centroids vectors,
until convergence is reached. The annealing starts with a high temperature.
Here, all centroids vectors converge to the center of the pattern
distribution (independent of their initial positions). Below a critical
temperature the vectors start to split. Further decreasing the temperature
leads to more splittings until all centroids vectors are separate. The
annealing can therefore avoid (if it is sufficiently slow) the convergence
to local minima.</p><h6>References:</h6><ul><li>Kenneth Rose. Deterministic Annealing for Clustering, Compression, Classification, Regression, and Speech Recognition.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the maximum number of clusters.</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>the temperature T is decreasing as T = T * alpha. alpha has
             to be in (0, 1).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dbscan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbscan(data:Array[Array[Double]],minPts:Int,radius:Double):smile.clustering.DBScan[Array[Double]]"></a>
      <a id="dbscan(Array[Array[Double]],Int,Double):DBScan[Array[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbscan</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DBScan">DBScan</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@dbscan(data:Array[Array[Double]],minPts:Int,radius:Double):smile.clustering.DBScan[Array[Double]]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Density-Based Spatial Clustering of Applications with Noise.</p><div class="fullcomment"><div class="comment cmt"><p>Density-Based Spatial Clustering of Applications with Noise.
DBScan finds a number of clusters starting from the estimated density
distribution of corresponding nodes.
If the data dimensionality is less than 10, KD-Tree is used for
neighbor search, otherwise Cover Tree is employed.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>the minimum number of neighbors for a core data point.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dbscan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbscan[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],minPts:Int,radius:Double):smile.clustering.DBScan[T]"></a>
      <a id="dbscan[T&lt;:AnyRef](Array[T],Metric[T],Int,Double):DBScan[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbscan</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DBScan">DBScan</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@dbscan[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],minPts:Int,radius:Double):smile.clustering.DBScan[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Density-Based Spatial Clustering of Applications with Noise.</p><div class="fullcomment"><div class="comment cmt"><p>Density-Based Spatial Clustering of Applications with Noise.
DBScan finds a number of clusters starting from the estimated density
distribution of corresponding nodes.
Cover Tree is used for nearest neighbor search.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance metric.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>the minimum number of neighbors for a core data point.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#dbscan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbscan[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],minPts:Int,radius:Double):smile.clustering.DBScan[T]"></a>
      <a id="dbscan[T&lt;:AnyRef](Array[T],RNNSearch[T,T],Int,Double):DBScan[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbscan</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="nns">nns: <span class="extype" name="smile.neighbor.RNNSearch">RNNSearch</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>, <span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DBScan">DBScan</span>[<span class="extype" name="smile.clustering.Operators.dbscan.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@dbscan[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],minPts:Int,radius:Double):smile.clustering.DBScan[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Density-Based Spatial Clustering of Applications with Noise.</p><div class="fullcomment"><div class="comment cmt"><p>Density-Based Spatial Clustering of Applications with Noise.
DBScan finds a number of clusters starting from the estimated density
distribution of corresponding nodes.</p><p>DBScan requires two parameters: radius (i.e. neighborhood radius) and the
number of minimum points required to form a cluster (minPts). It starts
with an arbitrary starting point that has not been visited. This point's
neighborhood is retrieved, and if it contains sufficient number of points,
a cluster is started. Otherwise, the point is labeled as noise. Note that
this point might later be found in a sufficiently sized radius-environment
of a different point and hence be made part of a cluster.</p><p>If a point is found to be part of a cluster, its neighborhood is also
part of that cluster. Hence, all points that are found within the
neighborhood are added, as is their own neighborhood. This process
continues until the cluster is completely found. Then, a new unvisited point
is retrieved and processed, leading to the discovery of a further cluster
of noise.</p><p>DBScan visits each point of the database, possibly multiple times (e.g.,
as candidates to different clusters). For practical considerations, however,
the time complexity is mostly governed by the number of nearest neighbor
queries. DBScan executes exactly one such query for each point, and if
an indexing structure is used that executes such a neighborhood query
in O(log n), an overall runtime complexity of O(n log n) is obtained.</p><p>DBScan has many advantages such as</p><ul><li>DBScan does not need to know the number of clusters in the data
   a priori, as opposed to k-means.</li><li>DBScan can find arbitrarily shaped clusters. It can even find clusters
   completely surrounded by (but not connected to) a different cluster.
   Due to the MinPts parameter, the so-called single-link effect
   (different clusters being connected by a thin line of points) is reduced.</li><li>DBScan has a notion of noise.</li><li>DBScan requires just two parameters and is mostly insensitive to the
   ordering of the points in the database. (Only points sitting on the
   edge of two different clusters might swap cluster membership if the
   ordering of the points is changed, and the cluster assignment is unique
   only up to isomorphism.)</li></ul><p>On the other hand, DBScan has the disadvantages of</p><ul><li>In high dimensional space, the data are sparse everywhere
   because of the curse of dimensionality. Therefore, DBScan doesn't
   work well on high-dimensional data in general.</li><li>DBScan does not respond well to data sets with varying densities.</li></ul><h6>References:</h6><ul><li>Martin Ester, Hans-Peter Kriegel, Jorg Sander, Xiaowei Xu (1996-). A density-based algorithm for discovering clusters in large spatial databases with noise&quot;. KDD, 1996.</li><li>Jorg Sander, Martin Ester, Hans-Peter  Kriegel, Xiaowei Xu. (1998). Density-Based Clustering in Spatial Databases: The Algorithm GDBSCAN and Its Applications. 1998.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">nns</dt><dd class="cmt"><p>the data structure for neighborhood search.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>the minimum number of neighbors for a core data point.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#denclue" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="denclue(data:Array[Array[Double]],sigma:Double,m:Int):smile.clustering.DENCLUE"></a>
      <a id="denclue(Array[Array[Double]],Double,Int):DENCLUE"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">denclue</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="sigma">sigma: <span class="extype" name="scala.Double">Double</span></span>, <span name="m">m: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.DENCLUE">DENCLUE</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@denclue(data:Array[Array[Double]],sigma:Double,m:Int):smile.clustering.DENCLUE" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">DENsity CLUstering.</p><div class="fullcomment"><div class="comment cmt"><p>DENsity CLUstering. The DENCLUE algorithm employs a cluster model based on
kernel density estimation. A cluster is defined by a local maximum of the
estimated density function. Data points going to the same local maximum
are put into the same cluster.</p><p>Clearly, DENCLUE doesn't work on data with uniform distribution. In high
dimensional space, the data always look like uniformly distributed because
of the curse of dimensionality. Therefore, DENCLUDE doesn't work well on
high-dimensional data in general.</p><h6>References:</h6><ul><li>A. Hinneburg and D. A. Keim. A general approach to clustering in large databases with noise. Knowledge and Information Systems, 5(4):387-415, 2003.</li><li>Alexander Hinneburg and Hans-Henning Gabriel. DENCLUE 2.0: Fast Clustering based on Kernel Density Estimation. IDA, 2007.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">sigma</dt><dd class="cmt"><p>the smooth parameter in the Gaussian kernel. The user can
             choose sigma such that number of density attractors is constant for a
             long interval of sigma.</p></dd><dt class="param">m</dt><dd class="cmt"><p>the number of selected samples used in the iteration.
         This number should be much smaller than the number of data points
         to speed up the algorithm. It should also be large enough to capture
         the sufficient information of underlying distribution.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#gmeans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gmeans(data:Array[Array[Double]],k:Int):smile.clustering.GMeans"></a>
      <a id="gmeans(Array[Array[Double]],Int):GMeans"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gmeans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.GMeans">GMeans</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@gmeans(data:Array[Array[Double]],k:Int):smile.clustering.GMeans" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">G-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters by normality test.</p><div class="fullcomment"><div class="comment cmt"><p>G-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters by normality test.
The G-means algorithm is based on a statistical test for the hypothesis
that a subset of data follows a Gaussian distribution. G-means runs
k-means with increasing k in a hierarchical fashion until the test accepts
the hypothesis that the data assigned to each k-means center are Gaussian.</p><h6>References:</h6><ul><li>G. Hamerly and C. Elkan. Learning the k in k-means. NIPS, 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the maximum number of clusters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#hclust" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hclust(proximity:Array[Array[Double]],method:String):smile.clustering.HierarchicalClustering"></a>
      <a id="hclust(Array[Array[Double]],String):HierarchicalClustering"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hclust</span><span class="params">(<span name="proximity">proximity: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="method">method: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.HierarchicalClustering">HierarchicalClustering</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@hclust(proximity:Array[Array[Double]],method:String):smile.clustering.HierarchicalClustering" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Agglomerative Hierarchical Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Agglomerative Hierarchical Clustering. This method
seeks to build a hierarchy of clusters in a bottom up approach: each
observation starts in its own cluster, and pairs of clusters are merged as
one moves up the hierarchy. The results of hierarchical clustering are
usually presented in a dendrogram.</p><p>In general, the merges are determined in a greedy manner. In order to decide
which clusters should be combined, a measure of dissimilarity between sets
of observations is required. In most methods of hierarchical clustering,
this is achieved by use of an appropriate metric, and a linkage criteria
which specifies the dissimilarity of sets as a function of the pairwise
distances of observations in the sets.</p><p>Hierarchical clustering has the distinct advantage that any valid measure
of distance can be used. In fact, the observations themselves are not
required: all that is used is a matrix of distances.</p><h4> References </h4><ul><li>David Eppstein. Fast hierarchical clustering and other applications of dynamic closest pairs. SODA 1998.
</li></ul></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>The proximity matrix to store the distance measure of
                 dissimilarity. To save space, we only need the lower half of matrix.</p></dd><dt class="param">method</dt><dd class="cmt"><p>the agglomeration method to merge clusters. This should be one of
               &quot;single&quot;, &quot;complete&quot;, &quot;upgma&quot;, &quot;upgmc&quot;, &quot;wpgma&quot;, &quot;wpgmc&quot;, and &quot;ward&quot;.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#kmeans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="kmeans(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.KMeans"></a>
      <a id="kmeans(Array[Array[Double]],Int,Int,Int):KMeans"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">kmeans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>, <span name="runs">runs: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.KMeans">KMeans</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@kmeans(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.KMeans" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">K-Means clustering.</p><div class="fullcomment"><div class="comment cmt"><p>K-Means clustering. The algorithm partitions n observations into k clusters in which
each observation belongs to the cluster with the nearest mean.
Although finding an exact solution to the k-means problem for arbitrary
input is NP-hard, the standard approach to finding an approximate solution
(often called Lloyd's algorithm or the k-means algorithm) is used widely
and frequently finds reasonable solutions quickly.</p><p>However, the k-means algorithm has at least two major theoretic shortcomings:</p><ul><li>First, it has been shown that the worst case running time of the
algorithm is super-polynomial in the input size.</li><li>Second, the approximation found can be arbitrarily bad with respect
to the objective function compared to the optimal learn.</li></ul><p>In this implementation, we use k-means++ which addresses the second of these
obstacles by specifying a procedure to initialize the cluster centers before
proceeding with the standard k-means optimization iterations. With the
k-means++ initialization, the algorithm is guaranteed to find a solution
that is O(log k) competitive to the optimal k-means solution.</p><p>We also use k-d trees to speed up each k-means step as described in the filter
algorithm by Kanungo, et al.</p><p>K-means is a hard clustering method, i.e. each sample is assigned to
a specific cluster. In contrast, soft clustering, e.g. the
Expectation-Maximization algorithm for Gaussian mixtures, assign samples
to different clusters with different probabilities.</p><h6>References:</h6><ul><li>Tapas Kanungo, David M. Mount, Nathan S. Netanyahu, Christine D. Piatko, Ruth Silverman, and Angela Y. Wu. An Efficient k-Means Clustering Algorithm: Analysis and Implementation. IEEE TRANS. PAMI, 2002.</li><li>D. Arthur and S. Vassilvitskii. &quot;K-means++: the advantages of careful seeding&quot;. ACM-SIAM symposium on Discrete algorithms, 1027-1035, 2007.</li><li>Anna D. Peterson, Arka P. Ghosh and Ranjan Maitra. A systematic evaluation of different methods for initializing the K-means clustering algorithm. 2010.</li></ul><p>This method runs the algorithm for given times and return the best one with smallest distortion.</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations for each running.</p></dd><dt class="param">runs</dt><dd class="cmt"><p>the number of runs of K-Means algorithm.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],k:Int,radius:Double,y:Array[Int]):smile.clustering.MEC[T]"></a>
      <a id="mec[T&lt;:AnyRef](Array[T],RNNSearch[T,T],Int,Double,Array[Int]):MEC[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="nns">nns: <span class="extype" name="smile.neighbor.RNNSearch">RNNSearch</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>, <span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Int">Int</span>]</span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@mec[T&lt;:Object](data:Array[T],nns:smile.neighbor.RNNSearch[T,T],k:Int,radius:Double,y:Array[Int]):smile.clustering.MEC[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">nns</dt><dd class="cmt"><p>the data structure for neighborhood search.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec(data:Array[Array[Double]],k:Int,radius:Double):smile.clustering.MEC[Array[Double]]"></a>
      <a id="mec(Array[Array[Double]],Int,Double):MEC[Array[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@mec(data:Array[Array[Double]],k:Int,radius:Double):smile.clustering.MEC[Array[Double]]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering. Assume Euclidean distance.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],k:Int,radius:Double):smile.clustering.MEC[T]"></a>
      <a id="mec[T&lt;:AnyRef](Array[T],Metric[T],Int,Double):MEC[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Metric[T],k:Int,radius:Double):smile.clustering.MEC[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance measure for neighborhood search.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#mec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,radius:Double):smile.clustering.MEC[T]"></a>
      <a id="mec[T&lt;:AnyRef](Array[T],Distance[T],Int,Double):MEC[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mec</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Distance">Distance</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="radius">radius: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.MEC">MEC</span>[<span class="extype" name="smile.clustering.Operators.mec.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@mec[T&lt;:Object](data:Array[T],distance:smile.math.distance.Distance[T],k:Int,radius:Double):smile.clustering.MEC[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Nonparametric Minimum Conditional Entropy Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Nonparametric Minimum Conditional Entropy Clustering. This method performs
very well especially when the exact number of clusters is unknown.
The method can also correctly reveal the structure of data and effectively
identify outliers simultaneously.</p><p>The clustering criterion is based on the conditional entropy H(C | x), where
C is the cluster label and x is an observation. According to Fano's
inequality, we can estimate C with a low probability of error only if the
conditional entropy H(C | X) is small. MEC also generalizes the criterion
by replacing Shannon's entropy with Havrda-Charvat's structural
&alpha;-entropy. Interestingly, the minimum entropy criterion based
on structural &alpha;-entropy is equal to the probability error of the
nearest neighbor method when &alpha;= 2. To estimate p(C | x), MEC employs
Parzen density estimation, a nonparametric approach.</p><p>MEC is an iterative algorithm starting with an initial partition given by
any other clustering methods, e.g. k-means, CLARNAS, hierarchical clustering,
etc. Note that a random initialization is NOT appropriate.</p><h6>References:</h6><ul><li>Haifeng Li, Keshu Zhang, and Tao Jiang. Minimum Entropy Clustering and Applications to Gene Expression Analysis. CSB, 2004.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance measure for neighborhood search.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters. Note that this is just a hint. The final
         number of clusters may be less.</p></dd><dt class="param">radius</dt><dd class="cmt"><p>the neighborhood radius.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#neuralgas" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="neuralgas(data:Array[Array[Double]],k:Int,epsBest:Double,epsNeighbor:Double,maxEdgeAge:Int,lambda:Int,alpha:Double,beta:Double):smile.clustering.GrowingNeuralGas"></a>
      <a id="neuralgas(Array[Array[Double]],Int,Double,Double,Int,Int,Double,Double):GrowingNeuralGas"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">neuralgas</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="epsBest">epsBest: <span class="extype" name="scala.Double">Double</span></span>, <span name="epsNeighbor">epsNeighbor: <span class="extype" name="scala.Double">Double</span></span>, <span name="maxEdgeAge">maxEdgeAge: <span class="extype" name="scala.Int">Int</span></span>, <span name="lambda">lambda: <span class="extype" name="scala.Int">Int</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Double">Double</span></span>, <span name="beta">beta: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.GrowingNeuralGas">GrowingNeuralGas</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@neuralgas(data:Array[Array[Double]],k:Int,epsBest:Double,epsNeighbor:Double,maxEdgeAge:Int,lambda:Int,alpha:Double,beta:Double):smile.clustering.GrowingNeuralGas" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Growing Neural Gas.</p><div class="fullcomment"><div class="comment cmt"><p>Growing Neural Gas. As an extension of Neural Gas, Growing Neural Gas
can add and delete nodes during algorithm execution.  The growth mechanism
is based on growing cell structures and competitive Hebbian learning.</p><p>Compared to Neural Gas, GNG has the following distinctions:</p><ul><li>The system has the ability to add and delete nodes.</li><li>Local Error measurements are noted at each step helping it to locally
insert/delete nodes.</li><li>Edges are connected between nodes, so a sufficiently old edges is
deleted. Such edges are intended place holders for localized data distribution.</li><li>Such edges also help to locate distinct clusters (those clusters are
not connected by edges).</li></ul><h6>References:</h6><ul><li>B. Fritzke. A growing neural gas network learns topologies. NIPS, 1995.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">epsBest</dt><dd class="cmt"><p>the fraction to update nearest neuron.</p></dd><dt class="param">epsNeighbor</dt><dd class="cmt"><p>the fraction to update neighbors of nearest neuron.</p></dd><dt class="param">maxEdgeAge</dt><dd class="cmt"><p>the maximum age of edges.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>if the number of input signals so far is an integer multiple
              of lambda, insert a new neuron.</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>decrease error variables by multiplying them with alpha
             during inserting a new neuron.</p></dd><dt class="param">beta</dt><dd class="cmt"><p>decrease all error variables by multiply them with beta.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#neuralgas" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="neuralgas(data:Array[Array[Double]],k:Int,lambda_i:Double,lambda_f:Double,eps_i:Double,eps_f:Double,steps:Int):smile.clustering.NeuralGas"></a>
      <a id="neuralgas(Array[Array[Double]],Int,Double,Double,Double,Double,Int):NeuralGas"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">neuralgas</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="lambda_i">lambda_i: <span class="extype" name="scala.Double">Double</span></span>, <span name="lambda_f">lambda_f: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.01</span></span>, <span name="eps_i">eps_i: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.5</span></span>, <span name="eps_f">eps_f: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.005</span></span>, <span name="steps">steps: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">25</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.NeuralGas">NeuralGas</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@neuralgas(data:Array[Array[Double]],k:Int,lambda_i:Double,lambda_f:Double,eps_i:Double,eps_f:Double,steps:Int):smile.clustering.NeuralGas" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Neural Gas soft competitive learning algorithm.</p><div class="fullcomment"><div class="comment cmt"><p>Neural Gas soft competitive learning algorithm. The Neural Gas is inspired
by the Self-Organizing Map for finding optimal data representations based on
feature vectors. The algorithm was coined &quot;Neural Gas&quot; because of the
dynamics of the feature vectors during the adaptation process, which
distribute themselves like a gas within the data space. Although it is mainly
applied where data compression or vector quantization is an issue,
it is also used for cluster analysis as a robustly converging alternative to
the k-means clustering. A prominent extension is the Growing Neural Gas.</p><p>Compared to SOM, neural gas has no topology of a fixed dimensionality
(in fact, no topology at all). For each input signal during learning, the
neural gas algorithm sorts the neurons of the network according to the
distance of their reference vectors to the input signal. Based on this
&quot;rank order&quot;, neurons are adapted based on the adaptation strength that are
decreased according to a fixed schedule.</p><p>The adaptation step of the Neural Gas can be interpreted as gradient descent
on a cost function. By adapting not only the closest feature vector but all
of them with a step size decreasing with increasing distance order,
compared to k-means clustering, a much more robust convergence of the
algorithm can be achieved.</p><h6>References:</h6><ul><li>Thomas Martinetz and Klaus Schulten. A &quot;neural gas&quot; network learns topologies. Artificial Neural Networks, 397-402, 1991.</li><li>T. Martinetz, S. Berkovich, and K. Schulten. &quot;Neural-gas&quot; Network for Vector Quantization and its Application to Time-Series Prediction. IEEE Trans. on Neural Networks, 4(4):558-569, 1993.</li><li>T. Martinetz and K. Schulten. Topology representing networks. Neural Networks, 7(3):507-522, 1994.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of units in the neural gas.</p></dd><dt class="param">lambda_i</dt><dd class="cmt"><p>the initial value of lambda. lambda_i and lambda_f are
                used to set the soft learning radius/rate, i.e. determining the number
                of neural units significantly changing their synaptic weights with
                each adaptation step.</p></dd><dt class="param">lambda_f</dt><dd class="cmt"><p>The final value of lambda.</p></dd><dt class="param">eps_i</dt><dd class="cmt"><p>the initial value of epsilon. epsilon_i and epsilon_f
             are the initial and final learning rate respectively.</p></dd><dt class="param">eps_f</dt><dd class="cmt"><p>the final value of epsilon.</p></dd><dt class="param">steps</dt><dd class="cmt"><p>the number of iterations. Note that for one iteration, we
             mean that the learning process goes through the whole dataset.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#neuralmap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="neuralmap(data:Array[Array[Double]],k:Int,minPts:Int,r:Double,epsBest:Double,epsNeighbor:Double,L:Int,rp:Int):smile.clustering.NeuralMap"></a>
      <a id="neuralmap(Array[Array[Double]],Int,Int,Double,Double,Double,Int,Int):NeuralMap"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">neuralmap</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="minPts">minPts: <span class="extype" name="scala.Int">Int</span></span>, <span name="r">r: <span class="extype" name="scala.Double">Double</span></span>, <span name="epsBest">epsBest: <span class="extype" name="scala.Double">Double</span></span>, <span name="epsNeighbor">epsNeighbor: <span class="extype" name="scala.Double">Double</span></span>, <span name="L">L: <span class="extype" name="scala.Int">Int</span></span>, <span name="rp">rp: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.NeuralMap">NeuralMap</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@neuralmap(data:Array[Array[Double]],k:Int,minPts:Int,r:Double,epsBest:Double,epsNeighbor:Double,L:Int,rp:Int):smile.clustering.NeuralMap" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">NeuralMap is an efficient competitive learning algorithm inspired by growing
neural gas and BIRCH.</p><div class="fullcomment"><div class="comment cmt"><p>NeuralMap is an efficient competitive learning algorithm inspired by growing
neural gas and BIRCH. Like growing neural gas, NeuralMap has the ability to
add and delete neurons with competitive Hebbian learning. Edges exist between
neurons close to each other. The edges are intended place holders for
localized data distribution. The edges also help to locate distinct clusters
(those clusters are not connected by edges). NeuralMap employs Locality-Sensitive
Hashing to speedup the learning while BIRCH uses balanced CF trees.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">minPts</dt><dd class="cmt"><p>neurons will be removed if the number of its points is
              less than minPts.</p></dd><dt class="param">r</dt><dd class="cmt"><p>the distance radius to activate a neuron for a given signal.</p></dd><dt class="param">epsBest</dt><dd class="cmt"><p>the fraction to update activated neuron.</p></dd><dt class="param">epsNeighbor</dt><dd class="cmt"><p>the fraction to update neighbors of activated neuron.</p></dd><dt class="param">L</dt><dd class="cmt"><p>the number of hash tables.</p></dd><dt class="param">rp</dt><dd class="cmt"><p>the number of random projection hash functions.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#proximity" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="proximity(data:Array[Array[Double]]):Array[Array[Double]]"></a>
      <a id="proximity(Array[Array[Double]]):Array[Array[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">proximity</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@proximity(data:Array[Array[Double]]):Array[Array[Double]]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the proximity matrix of a dataset for Euclidean distance.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the proximity matrix of a dataset for Euclidean distance.
To save space, we only store the lower half of matrix.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt>returns</dt><dd class="cmt"><p>the lower half of proximity matrix.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#proximity" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="proximity[T](data:Array[T],dist:smile.math.distance.Distance[T]):Array[Array[Double]]"></a>
      <a id="proximity[T](Array[T],Distance[T]):Array[Array[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">proximity</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.clustering.Operators.proximity.T">T</span>]</span>, <span name="dist">dist: <span class="extype" name="smile.math.distance.Distance">Distance</span>[<span class="extype" name="smile.clustering.Operators.proximity.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@proximity[T](data:Array[T],dist:smile.math.distance.Distance[T]):Array[Array[Double]]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Returns the proximity matrix of a dataset for given distance function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the proximity matrix of a dataset for given distance function.
To save space, we only store the lower half of matrix.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">dist</dt><dd class="cmt"><p>the distance function.</p></dd><dt>returns</dt><dd class="cmt"><p>the lower half of proximity matrix.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#sib" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sib(data:smile.data.SparseDataset,k:Int,maxIter:Int,runs:Int):smile.clustering.SIB"></a>
      <a id="sib(SparseDataset,Int,Int,Int):SIB"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sib</span><span class="params">(<span name="data">data: <span class="extype" name="smile.data.SparseDataset">SparseDataset</span></span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span></span>, <span name="runs">runs: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SIB">SIB</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@sib(data:smile.data.SparseDataset,k:Int,maxIter:Int,runs:Int):smile.clustering.SIB" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The Sequential Information Bottleneck algorithm on sparse dataset.</p><div class="fullcomment"><div class="comment cmt"><p>The Sequential Information Bottleneck algorithm on sparse dataset.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations.</p></dd><dt class="param">runs</dt><dd class="cmt"><p>the number of runs of SIB algorithm.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#sib" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sib(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.SIB"></a>
      <a id="sib(Array[Array[Double]],Int,Int,Int):SIB"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sib</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>, <span name="runs">runs: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SIB">SIB</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@sib(data:Array[Array[Double]],k:Int,maxIter:Int,runs:Int):smile.clustering.SIB" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The Sequential Information Bottleneck algorithm.</p><div class="fullcomment"><div class="comment cmt"><p>The Sequential Information Bottleneck algorithm. SIB clusters co-occurrence
data such as text documents vs words. SIB is guaranteed to converge to a local
maximum of the information. Moreover, the time and space complexity are
significantly improved in contrast to the agglomerative IB algorithm.</p><p>In analogy to K-Means, SIB's update formulas are essentially same as the
EM algorithm for estimating finite Gaussian mixture model by replacing
regular Euclidean distance with Kullback-Leibler divergence, which is
clearly a better dissimilarity measure for co-occurrence data. However,
the common batch updating rule (assigning all instances to nearest centroids
and then updating centroids) of K-Means won't work in SIB, which has
to work in a sequential way (reassigning (if better) each instance then
immediately update related centroids). It might be because K-L divergence
is very sensitive and the centroids may be significantly changed in each
iteration in batch updating rule.</p><p>Note that this implementation has a little difference from the original
paper, in which a weighted Jensen-Shannon divergence is employed as a
criterion to assign a randomly-picked sample to a different cluster.
However, this doesn't work well in some cases as we experienced probably
because the weighted JS divergence gives too much weight to clusters which
is much larger than a single sample. In this implementation, we instead
use the regular/unweighted Jensen-Shannon divergence.</p><h6>References:</h6><ul><li>N. Tishby, F.C. Pereira, and W. Bialek. The information bottleneck method. 1999.</li><li>N. Slonim, N. Friedman, and N. Tishby. Unsupervised document classification using sequential information maximization. ACM SIGIR, 2002.</li><li>Jaakko Peltonen, Janne Sinkkonen, and Samuel Kaski. Sequential information bottleneck for finite data. ICML, 2004.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations.</p></dd><dt class="param">runs</dt><dd class="cmt"><p>the number of runs of SIB algorithm.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#som" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="som(data:Array[Array[Double]],k:Int,width:Int,height:Int):smile.clustering.SOM"></a>
      <a id="som(Array[Array[Double]],Int,Int,Int):SOM"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">som</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="width">width: <span class="extype" name="scala.Int">Int</span></span>, <span name="height">height: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SOM">SOM</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@som(data:Array[Array[Double]],k:Int,width:Int,height:Int):smile.clustering.SOM" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Self-Organizing Map.</p><div class="fullcomment"><div class="comment cmt"><p>Self-Organizing Map. An SOM is a unsupervised learning method to produce
a low-dimensional (typically two-dimensional) discretized representation
(called a map) of the input space of the training samples. The model was
first described as an artificial neural network by Teuvo Kohonen, and is
sometimes called a Kohonen map.</p><p>While it is typical to consider SOMs as related to feed-forward networks where
the nodes are visualized as being attached, this type of architecture is
fundamentally different in arrangement and motivation because SOMs use a
neighborhood function to preserve the topological properties of the input
space. This makes SOMs useful for visualizing low-dimensional views of
high-dimensional data, akin to multidimensional scaling.</p><p>SOMs belong to a large family of competitive learning process and vector
quantization. An SOM consists of components called nodes or neurons.
Associated with each node is a weight vector of the same dimension as
the input data vectors and a position in the map space. The usual arrangement
of nodes is a regular spacing in a hexagonal or rectangular grid. The
self-organizing map describes a mapping from a higher dimensional input
space to a lower dimensional map space. During the (iterative) learning,
the input vectors are compared to the weight vector of each neuron. Neurons
who most closely match the input are known as the best match unit (BMU) of
the system. The weight vector of the BMU and those of nearby neurons are
adjusted to be closer to the input vector by a certain step size.</p><p>There are two ways to interpret a SOM. Because in the training phase weights
of the whole neighborhood are moved in the same direction, similar items
tend to excite adjacent neurons. Therefore, SOM forms a semantic map where
similar samples are mapped close together and dissimilar apart.
The other way is to think of neuronal weights as pointers to the input space.
They form a discrete approximation of the distribution of training samples.
More neurons point to regions with high training sample concentration and
fewer where the samples are scarce.</p><p>SOM may be considered a nonlinear generalization of Principal components
analysis (PCA). It has been shown, using both artificial and real
geophysical data, that SOM has many advantages over the conventional feature
extraction methods such as Empirical Orthogonal Functions (EOF) or PCA.</p><p>It has been shown that while SOMs with a small number of nodes behave in a
way that is similar to K-means. However, larger SOMs rearrange data
in a way that is fundamentally topological in character and display properties
which are emergent. Therefore, large maps are preferable to smaller ones.
In maps consisting of thousands of nodes, it is possible to perform cluster
operations on the map itself.</p><p>A common way to display SOMs is the heat map of U-matrix. The U-matrix value
of a particular node is the minimum/maximum/average distance between the node
and its closest neighbors. In a rectangular grid for instance, we might
consider the closest 4 or 8 nodes.</p><h6>References:</h6><ul><li>Teuvo KohonenDan. Self-organizing maps. Springer, 3rd edition, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the dataset for clustering.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">width</dt><dd class="cmt"><p>the width of map.</p></dd><dt class="param">height</dt><dd class="cmt"><p>the height of map.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#specc" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="specc(data:Array[Array[Double]],k:Int,l:Int,sigma:Double):smile.clustering.SpectralClustering"></a>
      <a id="specc(Array[Array[Double]],Int,Int,Double):SpectralClustering"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">specc</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="l">l: <span class="extype" name="scala.Int">Int</span></span>, <span name="sigma">sigma: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SpectralClustering">SpectralClustering</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@specc(data:Array[Array[Double]],k:Int,l:Int,sigma:Double):smile.clustering.SpectralClustering" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Spectral clustering with Nystrom approximation.</p><div class="fullcomment"><div class="comment cmt"><p>Spectral clustering with Nystrom approximation.</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the dataset for clustering.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">l</dt><dd class="cmt"><p>the number of random samples for Nystrom approximation.</p></dd><dt class="param">sigma</dt><dd class="cmt"><p>the smooth/width parameter of Gaussian kernel, which
             is a somewhat sensitive parameter. To search for the best setting,
             one may pick the value that gives the tightest clusters (smallest
             distortion, see { @link #distortion()}) in feature space.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#specc" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="specc(data:Array[Array[Double]],k:Int,sigma:Double):smile.clustering.SpectralClustering"></a>
      <a id="specc(Array[Array[Double]],Int,Double):SpectralClustering"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">specc</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="sigma">sigma: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SpectralClustering">SpectralClustering</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@specc(data:Array[Array[Double]],k:Int,sigma:Double):smile.clustering.SpectralClustering" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Spectral clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Spectral clustering.</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the dataset for clustering.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd><dt class="param">sigma</dt><dd class="cmt"><p>the smooth/width parameter of Gaussian kernel, which
             is a somewhat sensitive parameter. To search for the best setting,
             one may pick the value that gives the tightest clusters (smallest
             distortion, see { @link #distortion()}) in feature space.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#specc" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="specc(W:Array[Array[Double]],k:Int):smile.clustering.SpectralClustering"></a>
      <a id="specc(Array[Array[Double]],Int):SpectralClustering"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">specc</span><span class="params">(<span name="W">W: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.SpectralClustering">SpectralClustering</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@specc(W:Array[Array[Double]],k:Int):smile.clustering.SpectralClustering" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Spectral Clustering.</p><div class="fullcomment"><div class="comment cmt"><p>Spectral Clustering. Given a set of data points, the similarity matrix may
be defined as a matrix S where S<sub>ij</sub> represents a measure of the
similarity between points. Spectral clustering techniques make use of the
spectrum of the similarity matrix of the data to perform dimensionality
reduction for clustering in fewer dimensions. Then the clustering will
be performed in the dimension-reduce space, in which clusters of non-convex
shape may become tight. There are some intriguing similarities between
spectral clustering methods and kernel PCA, which has been empirically
observed to perform clustering.</p><h6>References:</h6><ul><li>A.Y. Ng, M.I. Jordan, and Y. Weiss. On Spectral Clustering: Analysis and an algorithm. NIPS, 2001.</li><li>Marina Maila and Jianbo Shi. Learning segmentation by random walks. NIPS, 2000.</li><li>Deepak Verma and Marina Meila. A Comparison of Spectral Clustering Algorithms. 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">W</dt><dd class="cmt"><p>the adjacency matrix of graph.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the number of clusters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.clustering.Operators#xmeans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="xmeans(data:Array[Array[Double]],k:Int):smile.clustering.XMeans"></a>
      <a id="xmeans(Array[Array[Double]],Int):XMeans"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">xmeans</span><span class="params">(<span name="data">data: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="smile.clustering.XMeans">XMeans</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.clustering.package@xmeans(data:Array[Array[Double]],k:Int):smile.clustering.XMeans" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">X-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters based on BIC scores.</p><div class="fullcomment"><div class="comment cmt"><p>X-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters based on BIC scores.
Starting with only one cluster, the X-Means algorithm goes into action
after each run of K-Means, making local decisions about which subset of the
current centroids should split themselves in order to better fit the data.
The splitting decision is done by computing the Bayesian Information
Criterion (BIC).</p><h6>References:</h6><ul><li>Dan Pelleg and Andrew Moore. X-means: Extending K-means with Efficient Estimation of the Number of Clusters. ICML, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the maximum number of clusters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="smile.clustering.Operators">
              <h3>Inherited from <a href="Operators.html" class="extype" name="smile.clustering.Operators">Operators</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
