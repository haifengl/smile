<!DOCTYPE html >
<html>
        <head>
          <title>mds - Smile - Statistical Machine Intelligence and Learning Engine - smile.mds</title>
          <meta name="description" content="mds - Smile - Statistical Machine Intelligence and Learning Engine - smile.mds" />
          <meta name="keywords" content="mds Smile Statistical Machine Intelligence and Learning Engine smile.mds" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'smile.mds.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../../lib/package_big.png" />
        <p id="owner"><a href="../package.html" class="extype" name="smile">smile</a></p>
        <h1>mds</h1><span class="permalink">
      <a href="../../index.html#smile.mds.package" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">mds</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Multidimensional scaling. MDS is a set of related statistical techniques
often used in information visualization for exploring similarities or
dissimilarities in data. An MDS algorithm starts with a matrix of item-item
similarities, then assigns a location to each item in N-dimensional space.
For sufficiently small N, the resulting locations may be displayed in a
graph or 3D visualization.</p><p>The major types of MDS algorithms include:</p><p><b>Classical multidimensional scaling</b>
takes an input matrix giving dissimilarities between pairs of items and
outputs a coordinate matrix whose configuration minimizes a loss function
called strain.</p><p><b>Metric multidimensional scaling</b> is
a superset of classical MDS that generalizes the optimization procedure
to a variety of loss functions and input matrices of known distances with
weights and so on. A useful loss function in this context is called stress
which is often minimized using a procedure called stress majorization.</p><p><b>Non-metric multidimensional scaling</b> finds both a non-parametric
monotonic relationship between the dissimilarities in the item-item matrix
and the Euclidean distances between items, and the location of each item in
the low-dimensional space. The relationship is typically found using isotonic
regression.</p><p><b>Generalized multidimensional scaling</b> is
an extension of metric multidimensional scaling, in which the target
space is an arbitrary smooth non-Euclidean space. In case when the
dissimilarities are distances on a surface and the target space is another
surface, GMDS allows finding the minimum-distortion embedding of one surface
into another.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="Operators.html" class="extype" name="smile.mds.Operators">Operators</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="smile.mds"><span>mds</span></li><li class="in" name="smile.mds.Operators"><span>Operators</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="smile.mds.Operators" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="OperatorsextendsAnyRef"></a>
      <a id="Operators:Operators"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Operators.html"><span class="name">Operators</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.mds.package@OperatorsextendsAnyRef" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">High level multi-dimensional scaling operators.</p>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="smile.mds.Operators#isomds" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isomds(proximity:Array[Array[Double]],k:Int,tol:Double,maxIter:Int):smile.mds.IsotonicMDS"></a>
      <a id="isomds(Array[Array[Double]],Int,Double,Int):IsotonicMDS"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isomds</span><span class="params">(<span name="proximity">proximity: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="tol">tol: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.0001</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">200</span></span>)</span><span class="result">: <span class="extype" name="smile.mds.IsotonicMDS">IsotonicMDS</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.mds.package@isomds(proximity:Array[Array[Double]],k:Int,tol:Double,maxIter:Int):smile.mds.IsotonicMDS" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Kruskal's nonmetric MDS.</p><div class="fullcomment"><div class="comment cmt"><p>Kruskal's nonmetric MDS. In non-metric MDS, only the rank order of entries
in the proximity matrix (not the actual dissimilarities) is assumed to
contain the significant information. Hence, the distances of the final
configuration should as far as possible be in the same rank order as the
original data. Note that a perfect ordinal re-scaling of the data into
distances is usually not possible. The relationship is typically found
using isotonic regression.
</p></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>the nonnegative proximity matrix of dissimilarities. The
                 diagonal should be zero and all other elements should be positive and symmetric.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the dimension of the projection.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>tolerance for stopping iterations.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>maximum number of iterations.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.mds.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.mds.Operators#mds" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mds(proximity:Array[Array[Double]],k:Int,add:Boolean):smile.mds.MDS"></a>
      <a id="mds(Array[Array[Double]],Int,Boolean):MDS"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mds</span><span class="params">(<span name="proximity">proximity: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="add">add: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="smile.mds.MDS">MDS</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.mds.package@mds(proximity:Array[Array[Double]],k:Int,add:Boolean):smile.mds.MDS" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Classical multidimensional scaling, also known as principal coordinates
analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Classical multidimensional scaling, also known as principal coordinates
analysis. Given a matrix of dissimilarities (e.g. pairwise distances), MDS
finds a set of points in low dimensional space that well-approximates the
dissimilarities in A. We are not restricted to using a Euclidean
distance metric. However, when Euclidean distances are used MDS is
equivalent to PCA.
</p></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>the nonnegative proximity matrix of dissimilarities. The
                 diagonal should be zero and all other elements should be positive and
                 symmetric. For pairwise distances matrix, it should be just the plain
                 distance, not squared.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the dimension of the projection.</p></dd><dt class="param">add</dt><dd class="cmt"><p>true to estimate an appropriate constant to be added
           to all the dissimilarities, apart from the self-dissimilarities, that
           makes the learning matrix positive semi-definite. The other formulation of
           the additive constant problem is as follows. If the proximity is
           measured in an interval scale, where there is no natural origin, then there
           is not a sympathy of the dissimilarities to the distances in the Euclidean
           space used to represent the objects. In this case, we can estimate a constant c
           such that proximity + c may be taken as ratio data, and also possibly
           to minimize the dimensionality of the Euclidean space required for
           representing the objects.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.mds.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.mds.Operators#sammon" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sammon(proximity:Array[Array[Double]],k:Int,lambda:Double,tol:Double,maxIter:Int):smile.mds.SammonMapping"></a>
      <a id="sammon(Array[Array[Double]],Int,Double,Double,Int):SammonMapping"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sammon</span><span class="params">(<span name="proximity">proximity: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="k">k: <span class="extype" name="scala.Int">Int</span></span>, <span name="lambda">lambda: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.2</span></span>, <span name="tol">tol: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.0001</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">100</span></span>)</span><span class="result">: <span class="extype" name="smile.mds.SammonMapping">SammonMapping</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.mds.package@sammon(proximity:Array[Array[Double]],k:Int,lambda:Double,tol:Double,maxIter:Int):smile.mds.SammonMapping" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The Sammon's mapping is an iterative technique for making interpoint
distances in the low-dimensional projection as close as possible to the
interpoint distances in the high-dimensional object.</p><div class="fullcomment"><div class="comment cmt"><p>The Sammon's mapping is an iterative technique for making interpoint
distances in the low-dimensional projection as close as possible to the
interpoint distances in the high-dimensional object. Two points close
together in the high-dimensional space should appear close together in the
projection, while two points far apart in the high dimensional space should
appear far apart in the projection. The Sammon's mapping is a special case of
metric least-square multidimensional scaling.</p><p>Ideally when we project from a high dimensional space to a low dimensional
space the image would be geometrically congruent to the original figure.
This is called an isometric projection. Unfortunately it is rarely possible
to isometrically project objects down into lower dimensional spaces. Instead of
trying to achieve equality between corresponding inter-point distances we
can minimize the difference between corresponding inter-point distances.
This is one goal of the Sammon's mapping algorithm. A second goal of the Sammon's
mapping algorithm is to preserve the topology as best as possible by giving
greater emphasize to smaller interpoint distances. The Sammon's mapping
algorithm has the advantage that whenever it is possible to isometrically
project an object into a lower dimensional space it will be isometrically
projected into the lower dimensional space. But whenever an object cannot
be projected down isometrically the Sammon's mapping projects it down to reduce
the distortion in interpoint distances and to limit the change in the
topology of the object.</p><p>The projection cannot be solved in a closed form and may be found by an
iterative algorithm such as gradient descent suggested by Sammon. Kohonen
also provides a heuristic that is simple and works reasonably well.
</p></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>the nonnegative proximity matrix of dissimilarities. The
                 diagonal should be zero and all other elements should be positive and symmetric.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the dimension of the projection.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>initial value of the step size constant in diagonal Newton method.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>tolerance for stopping iterations.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>maximum number of iterations.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.mds.Operators">Operators</a></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="smile.mds.Operators">
              <h3>Inherited from <a href="Operators.html" class="extype" name="smile.mds.Operators">Operators</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
