<!DOCTYPE html >
<html>
        <head>
          <title>regression - Smile - Statistical Machine Intelligence and Learning Engine - smile.regression</title>
          <meta name="description" content="regression - Smile - Statistical Machine Intelligence and Learning Engine - smile.regression" />
          <meta name="keywords" content="regression Smile Statistical Machine Intelligence and Learning Engine smile.regression" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'smile.regression.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../../lib/package_big.png" />
        <p id="owner"><a href="../package.html" class="extype" name="smile">smile</a></p>
        <h1>regression</h1><span class="permalink">
      <a href="../../index.html#smile.regression.package" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">regression</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Regression analysis. Regression analysis includes any
techniques for modeling and analyzing several variables, when the focus
is on the relationship between a dependent variable and one or more
independent variables. Most commonly, regression analysis estimates the
conditional expectation of the dependent variable given the independent
variables. Therefore, the estimation target is a function of the independent
variables called the regression function. Regression analysis is widely
used for prediction and forecasting.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By Inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="smile.regression"><span>regression</span></li><li class="in" name="smile.regression.Operators"><span>Operators</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show All</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="smile.regression.Operators" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="OperatorsextendsAnyRef"></a>
      <a id="Operators:Operators"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Operators.html"><span class="name">Operators</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@OperatorsextendsAnyRef" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">High level regression operators.</p>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="smile.regression.Operators#cart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cart(x:Array[Array[Double]],y:Array[Double],maxNodes:Int,attributes:Array[smile.data.Attribute]):smile.regression.RegressionTree"></a>
      <a id="cart(Array[Array[Double]],Array[Double],Int,Array[Attribute]):RegressionTree"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cart</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="maxNodes">maxNodes: <span class="extype" name="scala.Int">Int</span></span>, <span name="attributes">attributes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.data.Attribute">Attribute</span>] = <span class="symbol">null</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.RegressionTree">RegressionTree</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@cart(x:Array[Array[Double]],y:Array[Double],maxNodes:Int,attributes:Array[smile.data.Attribute]):smile.regression.RegressionTree" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Regression tree.</p><div class="fullcomment"><div class="comment cmt"><p>Regression tree. A decision tree can be learned by
splitting the training set into subsets based on an attribute value
test. This process is repeated on each derived subset in a recursive
manner called recursive partitioning. The recursion is completed when
the subset at a node all has the same value of the target variable,
or when splitting no longer adds value to the predictions.</p><p>The algorithms that are used for constructing decision trees usually
work top-down by choosing a variable at each step that is the next best
variable to use in splitting the set of items. &quot;Best&quot; is defined by how
well the variable splits the set into homogeneous subsets that have
the same value of the target variable. Different algorithms use different
formulae for measuring &quot;best&quot;. Used by the CART algorithm, Gini impurity
is a measure of how often a randomly chosen element from the set would
be incorrectly labeled if it were randomly labeled according to the
distribution of labels in the subset. Gini impurity can be computed by
summing the probability of each item being chosen times the probability
of a mistake in categorizing that item. It reaches its minimum (zero) when
all cases in the node fall into a single target category. Information gain
is another popular measure, used by the ID3, C4.5 and C5.0 algorithms.
Information gain is based on the concept of entropy used in information
theory. For categorical variables with different number of levels, however,
information gain are biased in favor of those attributes with more levels.
Instead, one may employ the information gain ratio, which solves the drawback
of information gain.</p><p>Classification and Regression Tree techniques have a number of advantages
over many of those alternative techniques.</p><ul><li><b>Simple to understand and interpret:</b>
In most cases, the interpretation of results summarized in a tree is
very simple. This simplicity is useful not only for purposes of rapid
classification of new observations, but can also often yield a much simpler
&quot;model&quot; for explaining why observations are classified or predicted in a
particular manner.</li><li><b>Able to handle both numerical and categorical data:</b>
Other techniques are usually specialized in analyzing datasets that
have only one type of variable.</li><li><b>Nonparametric and nonlinear:</b>
The final results of using tree methods for classification or regression
can be summarized in a series of (usually few) logical if-then conditions
(tree nodes). Therefore, there is no implicit assumption that the underlying
relationships between the predictor variables and the dependent variable
are linear, follow some specific non-linear link function, or that they
are even monotonic in nature. Thus, tree methods are particularly well
suited for data mining tasks, where there is often little a priori
knowledge nor any coherent set of theories or predictions regarding which
variables are related and how. In those types of data analytics, tree
methods can often reveal simple relationships between just a few variables
that could have easily gone unnoticed using other analytic techniques.</li></ul><p>One major problem with classification and regression trees is their high
variance. Often a small change in the data can result in a very different
series of splits, making interpretation somewhat precarious. Besides,
decision-tree learners can create over-complex trees that cause over-fitting.
Mechanisms such as pruning are necessary to avoid this problem.
Another limitation of trees is the lack of smoothness of the prediction
surface.</p><p>Some techniques such as bagging, boosting, and random forest use more than
one decision tree for their analysis.
</p></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>the training instances.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response variable.</p></dd><dt class="param">maxNodes</dt><dd class="cmt"><p>the maximum number of leaf nodes in the tree.</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>the attribute properties.</p></dd><dt>returns</dt><dd class="cmt"><p>Regression tree model.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#gbm" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gbm(x:Array[Array[Double]],y:Array[Double],attributes:Array[smile.data.Attribute],loss:smile.regression.GradientTreeBoost.Loss,ntrees:Int,maxNodes:Int,shrinkage:Double,subsample:Double):smile.regression.GradientTreeBoost"></a>
      <a id="gbm(Array[Array[Double]],Array[Double],Array[Attribute],Loss,Int,Int,Double,Double):GradientTreeBoost"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gbm</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="attributes">attributes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.data.Attribute">Attribute</span>] = <span class="symbol">null</span></span>, <span name="loss">loss: <span class="extype" name="smile.regression.GradientTreeBoost.Loss">Loss</span> = <span class="defval" name="GradientTreeBoost.Loss.LeastAbsoluteDeviation">...</span></span>, <span name="ntrees">ntrees: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">500</span></span>, <span name="maxNodes">maxNodes: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">6</span></span>, <span name="shrinkage">shrinkage: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.05</span></span>, <span name="subsample">subsample: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.7</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.GradientTreeBoost">GradientTreeBoost</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@gbm(x:Array[Array[Double]],y:Array[Double],attributes:Array[smile.data.Attribute],loss:smile.regression.GradientTreeBoost.Loss,ntrees:Int,maxNodes:Int,shrinkage:Double,subsample:Double):smile.regression.GradientTreeBoost" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Gradient boosted regression trees.</p><div class="fullcomment"><div class="comment cmt"><p>Gradient boosted regression trees.</p><p>Generic gradient boosting at the t-th step would fit a regression tree to
pseudo-residuals. Let J be the number of its leaves. The tree partitions
the input space into J disjoint regions and predicts a constant value in
each region. The parameter J controls the maximum allowed
level of interaction between variables in the model. With J = 2 (decision
stumps), no interaction between variables is allowed. With J = 3 the model
may include effects of the interaction between up to two variables, and
so on. Hastie et al. comment that typically 4 &le; J &le; 8 work well
for boosting and results are fairly insensitive to the choice of in
this range, J = 2 is insufficient for many applications, and J &gt; 10 is
unlikely to be required.</p><p>Fitting the training set too closely can lead to degradation of the model's
generalization ability. Several so-called regularization techniques reduce
this over-fitting effect by constraining the fitting procedure.
One natural regularization parameter is the number of gradient boosting
iterations T (i.e. the number of trees in the model when the base learner
is a decision tree). Increasing T reduces the error on training set,
but setting it too high may lead to over-fitting. An optimal value of T
is often selected by monitoring prediction error on a separate validation
data set.</p><p>Another regularization approach is the shrinkage which times a parameter
&eta; (called the &quot;learning rate&quot;) to update term.
Empirically it has been found that using small learning rates (such as
&eta; &lt; 0.1) yields dramatic improvements in model's generalization ability
over gradient boosting without shrinking (&eta; = 1). However, it comes at
the price of increasing computational time both during training and
prediction: lower learning rate requires more iterations.</p><p>Soon after the introduction of gradient boosting Friedman proposed a
minor modification to the algorithm, motivated by Breiman's bagging method.
Specifically, he proposed that at each iteration of the algorithm, a base
learner should be fit on a subsample of the training set drawn at random
without replacement. Friedman observed a substantial improvement in
gradient boosting's accuracy with this modification.</p><p>Subsample size is some constant fraction f of the size of the training set.
When f = 1, the algorithm is deterministic and identical to the one
described above. Smaller values of f introduce randomness into the
algorithm and help prevent over-fitting, acting as a kind of regularization.
The algorithm also becomes faster, because regression trees have to be fit
to smaller datasets at each iteration. Typically, f is set to 0.5, meaning
that one half of the training set is used to build each base learner.</p><p>Also, like in bagging, sub-sampling allows one to define an out-of-bag
estimate of the prediction performance improvement by evaluating predictions
on those observations which were not used in the building of the next
base learner. Out-of-bag estimates help avoid the need for an independent
validation dataset, but often underestimate actual performance improvement
and the optimal number of iterations.</p><p>Gradient tree boosting implementations often also use regularization by
limiting the minimum number of observations in trees' terminal nodes.
It's used in the tree building process by ignoring any splits that lead
to nodes containing fewer than this number of training set instances.
Imposing this limit helps to reduce variance in predictions at leaves.</p><h6>References:</h6><ul><li>J. H. Friedman. Greedy Function Approximation: A Gradient Boosting Machine, 1999.</li><li>J. H. Friedman. Stochastic Gradient Boosting, 1999.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>the training instances.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response variable.</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>the attribute properties. If not provided, all attributes
                  are treated as numeric values.</p></dd><dt class="param">loss</dt><dd class="cmt"><p>loss function for regression. By default, least absolute
            deviation is employed for robust regression.</p></dd><dt class="param">ntrees</dt><dd class="cmt"><p>the number of iterations (trees).</p></dd><dt class="param">maxNodes</dt><dd class="cmt"><p>the number of leaves in each tree.</p></dd><dt class="param">shrinkage</dt><dd class="cmt"><p>the shrinkage parameter in (0, 1] controls the learning rate of procedure.</p></dd><dt class="param">subsample</dt><dd class="cmt"><p>the sampling fraction for stochastic tree boosting.</p></dd><dt>returns</dt><dd class="cmt"><p>Gradient boosted trees.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#gpr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gpr[T&lt;:AnyRef](x:Array[T],y:Array[Double],t:Array[T],kernel:smile.math.kernel.MercerKernel[T],lambda:Double,nystrom:Boolean):smile.regression.GaussianProcessRegression[T]"></a>
      <a id="gpr[T&lt;:AnyRef](Array[T],Array[Double],Array[T],MercerKernel[T],Double,Boolean):GaussianProcessRegression[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gpr</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="t">t: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>, <span name="kernel">kernel: <span class="extype" name="smile.math.kernel.MercerKernel">MercerKernel</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>, <span name="lambda">lambda: <span class="extype" name="scala.Double">Double</span></span>, <span name="nystrom">nystrom: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.GaussianProcessRegression">GaussianProcessRegression</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@gpr[T&lt;:AnyRef](x:Array[T],y:Array[Double],t:Array[T],kernel:smile.math.kernel.MercerKernel[T],lambda:Double,nystrom:Boolean):smile.regression.GaussianProcessRegression[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">This method fits an approximate Gaussian process model by the method
of subset of regressors.</p><div class="fullcomment"><div class="comment cmt"><p>This method fits an approximate Gaussian process model by the method
of subset of regressors.
</p></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>the training dataset.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response variable.</p></dd><dt class="param">t</dt><dd class="cmt"><p>the inducing input, which are pre-selected or inducing samples
         acting as active set of regressors. In simple case, these can be chosen
         randomly from the training set or as the centers of k-means clustering.</p></dd><dt class="param">kernel</dt><dd class="cmt"><p>the Mercer kernel.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>the shrinkage/regularization parameter.</p></dd><dt class="param">nystrom</dt><dd class="cmt"><p>set it true for Nystrom approximation of kernel matrix.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#gpr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gpr[T&lt;:AnyRef](x:Array[T],y:Array[Double],kernel:smile.math.kernel.MercerKernel[T],lambda:Double):smile.regression.GaussianProcessRegression[T]"></a>
      <a id="gpr[T&lt;:AnyRef](Array[T],Array[Double],MercerKernel[T],Double):GaussianProcessRegression[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gpr</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="kernel">kernel: <span class="extype" name="smile.math.kernel.MercerKernel">MercerKernel</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>, <span name="lambda">lambda: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.GaussianProcessRegression">GaussianProcessRegression</span>[<span class="extype" name="smile.regression.Operators.gpr.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@gpr[T&lt;:AnyRef](x:Array[T],y:Array[Double],kernel:smile.math.kernel.MercerKernel[T],lambda:Double):smile.regression.GaussianProcessRegression[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Gaussian Process for Regression.</p><div class="fullcomment"><div class="comment cmt"><p>Gaussian Process for Regression. A Gaussian process is a stochastic process
whose realizations consist of random values associated with every point in
a range of times (or of space) such that each such random variable has
a normal distribution. Moreover, every finite collection of those random
variables has a multivariate normal distribution.</p><p>A Gaussian process can be used as a prior probability distribution over
functions in Bayesian inference. Given any set of N points in the desired
domain of your functions, take a multivariate Gaussian whose covariance
matrix parameter is the Gram matrix of N points with some desired kernel,
and sample from that Gaussian. Inference of continuous values with a
Gaussian process prior is known as Gaussian process regression.</p><p>The fitting is performed in the reproducing kernel Hilbert space with
the &quot;kernel trick&quot;. The loss function is squared-error. This also arises
as the kriging estimate of a Gaussian random field in spatial statistics.</p><p>A significant problem with Gaussian process prediction is that it typically
scales as O(n<sup>3</sup>). For large problems (e.g. n &gt; 10,000) both
storing the Gram matrix and solving the associated linear systems are
prohibitive on modern workstations. An extensive range of proposals have
been suggested to deal with this problem. A popular approach is the
reduced-rank Approximations of the Gram Matrix, known as Nystrom approximation.
Greedy approximation is another popular approach that uses an active set of
training points of size m selected from the training set of size n &gt; m.
We assume that it is impossible to search for the optimal subset of size m
due to combinatorics. The points in the active set could be selected
randomly, but in general we might expect better performance if the points
are selected greedily w.r.t. some criterion. Recently, researchers had
proposed relaxing the constraint that the inducing variables must be a
subset of training/test cases, turning the discrete selection problem
into one of continuous optimization.</p><p>This method fits a regular Gaussian process model.</p><h6>References:</h6><ul><li>Carl Edward Rasmussen and Chris Williams. Gaussian Processes for Machine Learning, 2006.</li><li>Joaquin Quinonero-candela,  Carl Edward Ramussen,  Christopher K. I. Williams. Approximation Methods for Gaussian Process Regression. 2007.</li><li>T. Poggio and F. Girosi. Networks for approximation and learning. Proc. IEEE 78(9):1484-1487, 1990.</li><li>Kai Zhang and James T. Kwok. Clustered Nystrom Method for Large Scale Manifold Learning and Dimension Reduction. IEEE Transactions on Neural Networks, 2010.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>the training dataset.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response variable.</p></dd><dt class="param">kernel</dt><dd class="cmt"><p>the Mercer kernel.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>the shrinkage/regularization parameter.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#lasso" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lasso(x:Array[Array[Double]],y:Array[Double],lambda:Double,tol:Double,maxIter:Int):smile.regression.LASSO"></a>
      <a id="lasso(Array[Array[Double]],Array[Double],Double,Double,Int):LASSO"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lasso</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="lambda">lambda: <span class="extype" name="scala.Double">Double</span></span>, <span name="tol">tol: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">1E-3</span></span>, <span name="maxIter">maxIter: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">5000</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.LASSO">LASSO</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@lasso(x:Array[Array[Double]],y:Array[Double],lambda:Double,tol:Double,maxIter:Int):smile.regression.LASSO" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Least absolute shrinkage and selection operator.</p><div class="fullcomment"><div class="comment cmt"><p>Least absolute shrinkage and selection operator.
The Lasso is a shrinkage and selection method for linear regression.
It minimizes the usual sum of squared errors, with a bound on the sum
of the absolute values of the coefficients (i.e. L<sub>1</sub>-regularized).
It has connections to soft-thresholding of wavelet coefficients, forward
stage-wise regression, and boosting methods.</p><p>The Lasso typically yields a sparse solution, of which the parameter
vector &beta; has relatively few nonzero coefficients. In contrast, the
solution of L<sub>2</sub>-regularized least squares (i.e. ridge regression)
typically has all coefficients nonzero. Because it effectively
reduces the number of variables, the Lasso is useful in some contexts.</p><p>For over-determined systems (more instances than variables, commonly in
machine learning), we normalize variables with mean 0 and standard deviation
1. For under-determined systems (less instances than variables, e.g.
compressed sensing), we assume white noise (i.e. no intercept in the linear
model) and do not perform normalization. Note that the solution
is not unique in this case.</p><p>There is no analytic formula or expression for the optimal solution to the
L<sub>1</sub>-regularized least squares problems. Therefore, its solution
must be computed numerically. The objective function in the
L<sub>1</sub>-regularized least squares is convex but not differentiable,
so solving it is more of a computational challenge than solving the
L<sub>2</sub>-regularized least squares. The Lasso may be solved using
quadratic programming or more general convex optimization methods, as well
as by specific algorithms such as the least angle regression algorithm.</p><h6>References:</h6><ul><li>R. Tibshirani. Regression shrinkage and selection via the lasso. J. Royal. Statist. Soc B., 58(1):267-288, 1996.</li><li>B. Efron, I. Johnstone, T. Hastie, and R. Tibshirani. Least angle regression. Annals of Statistics, 2003</li><li>Seung-Jean Kim, K. Koh, M. Lustig, Stephen Boyd, and Dimitry Gorinevsky. An Interior-Point Method for Large-Scale L1-Regularized Least Squares. IEEE JOURNAL OF SELECTED TOPICS IN SIGNAL PROCESSING, VOL. 1, NO. 4, 2007.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>a matrix containing the explanatory variables.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response values.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>the shrinkage/regularization parameter.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>the tolerance for stopping iterations (relative target duality gap).</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#nrbfnet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nrbfnet[T&lt;:AnyRef,RBF&lt;:smile.math.rbf.RadialBasisFunction](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:Array[RBF],centers:Array[T]):smile.regression.RBFNetwork[T]"></a>
      <a id="nrbfnet[T&lt;:AnyRef,RBF&lt;:RadialBasisFunction](Array[T],Array[Double],Metric[T],Array[RBF],Array[T]):RBFNetwork[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nrbfnet</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>, <span name="RBF">RBF &lt;: <span class="extype" name="smile.math.rbf.RadialBasisFunction">RadialBasisFunction</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>, <span name="rbf">rbf: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.RBF">RBF</span>]</span>, <span name="centers">centers: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="smile.regression.RBFNetwork">RBFNetwork</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@nrbfnet[T&lt;:AnyRef,RBF&lt;:smile.math.rbf.RadialBasisFunction](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:Array[RBF],centers:Array[T]):smile.regression.RBFNetwork[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalized radial basis function networks.</p><div class="fullcomment"><div class="comment cmt"><p>Normalized radial basis function networks.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#nrbfnet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nrbfnet[T&lt;:AnyRef](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:smile.math.rbf.RadialBasisFunction,centers:Array[T]):smile.regression.RBFNetwork[T]"></a>
      <a id="nrbfnet[T&lt;:AnyRef](Array[T],Array[Double],Metric[T],RadialBasisFunction,Array[T]):RBFNetwork[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nrbfnet</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>, <span name="rbf">rbf: <span class="extype" name="smile.math.rbf.RadialBasisFunction">RadialBasisFunction</span></span>, <span name="centers">centers: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="smile.regression.RBFNetwork">RBFNetwork</span>[<span class="extype" name="smile.regression.Operators.nrbfnet.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@nrbfnet[T&lt;:AnyRef](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:smile.math.rbf.RadialBasisFunction,centers:Array[T]):smile.regression.RBFNetwork[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalized radial basis function networks.</p><div class="fullcomment"><div class="comment cmt"><p>Normalized radial basis function networks.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#ols" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ols(x:Array[Array[Double]],y:Array[Double],method:String):smile.regression.OLS"></a>
      <a id="ols(Array[Array[Double]],Array[Double],String):OLS"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ols</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="method">method: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;qr&quot;</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.OLS">OLS</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@ols(x:Array[Array[Double]],y:Array[Double],method:String):smile.regression.OLS" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Ordinary least squares.</p><div class="fullcomment"><div class="comment cmt"><p>Ordinary least squares. In linear regression,
the model specification is that the dependent variable is a linear
combination of the parameters (but need not be linear in the independent
variables). The residual is the difference between the value of the
dependent variable predicted by the model, and the true value of the
dependent variable. Ordinary least squares obtains parameter estimates
that minimize the sum of squared residuals, SSE (also denoted RSS).</p><p>The OLS estimator is consistent when the independent variables are
exogenous and there is no multicollinearity, and optimal in the class
of linear unbiased estimators when the errors are homoscedastic and
serially uncorrelated. Under these conditions, the method of OLS provides
minimum-variance mean-unbiased estimation when the errors have finite
variances.</p><p>There are several different frameworks in which the linear regression
model can be cast in order to make the OLS technique applicable. Each
of these settings produces the same formulas and same results, the only
difference is the interpretation and the assumptions which have to be
imposed in order for the method to give meaningful results. The choice
of the applicable framework depends mostly on the nature of data at hand,
and on the inference task which has to be performed.</p><p>Least squares corresponds to the maximum likelihood criterion if the
experimental errors have a normal distribution and can also be derived
as a method of moments estimator.</p><p>Once a regression model has been constructed, it may be important to
confirm the goodness of fit of the model and the statistical significance
of the estimated parameters. Commonly used checks of goodness of fit
include the R-squared, analysis of the pattern of residuals and hypothesis
testing. Statistical significance can be checked by an F-test of the overall
fit, followed by t-tests of individual parameters.</p><p>Interpretations of these diagnostic tests rest heavily on the model
assumptions. Although examination of the residuals can be used to
invalidate a model, the results of a t-test or F-test are sometimes more
difficult to interpret if the model's assumptions are violated.
For example, if the error term does not have a normal distribution,
in small samples the estimated parameters will not follow normal
distributions and complicate inference. With relatively large samples,
however, a central limit theorem can be invoked such that hypothesis
testing may proceed using asymptotic approximations.
</p></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>a matrix containing the explanatory variables.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response values.</p></dd><dt class="param">method</dt><dd class="cmt"><p>qr or svd.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#randomForest" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="randomForest(x:Array[Array[Double]],y:Array[Double],attributes:Array[smile.data.Attribute],ntrees:Int,maxNodes:Int,nodeSize:Int,mtry:Int,subsample:Double):smile.regression.RandomForest"></a>
      <a id="randomForest(Array[Array[Double]],Array[Double],Array[Attribute],Int,Int,Int,Int,Double):RandomForest"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">randomForest</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="attributes">attributes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.data.Attribute">Attribute</span>] = <span class="symbol">null</span></span>, <span name="ntrees">ntrees: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">500</span></span>, <span name="maxNodes">maxNodes: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>, <span name="nodeSize">nodeSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">5</span></span>, <span name="mtry">mtry: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>, <span name="subsample">subsample: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">1.0</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.RandomForest">RandomForest</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@randomForest(x:Array[Array[Double]],y:Array[Double],attributes:Array[smile.data.Attribute],ntrees:Int,maxNodes:Int,nodeSize:Int,mtry:Int,subsample:Double):smile.regression.RandomForest" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Random forest for regression.</p><div class="fullcomment"><div class="comment cmt"><p>Random forest for regression. Random forest is an ensemble classifier
that consists of many decision trees and outputs the majority vote of
individual trees. The method combines bagging idea and the random
selection of features.</p><p>Each tree is constructed using the following algorithm:</p><ol class="lowerRoman"><li>If the number of cases in the training set is N, randomly sample N cases
with replacement from the original data. This sample will
be the training set for growing the tree.</li><li>If there are M input variables, a number m &lt;&lt; M is specified such
that at each node, m variables are selected at random out of the M and
the best split on these m is used to split the node. The value of m is
held constant during the forest growing.</li><li>Each tree is grown to the largest extent possible. There is no pruning.</li></ol><p>The advantages of random forest are:</p><ul><li>For many data sets, it produces a highly accurate classifier.</li><li>It runs efficiently on large data sets.</li><li>It can handle thousands of input variables without variable deletion.</li><li>It gives estimates of what variables are important in the classification.</li><li>It generates an internal unbiased estimate of the generalization error
as the forest building progresses.</li><li>It has an effective method for estimating missing data and maintains
accuracy when a large proportion of the data are missing.</li></ul><p>The disadvantages are</p><ul><li>Random forests are prone to over-fitting for some datasets. This is
even more pronounced on noisy data.</li><li>For data including categorical variables with different number of
levels, random forests are biased in favor of those attributes with more
levels. Therefore, the variable importance scores from random forest are
not reliable for this type of data.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>the training instances.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response variable.</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>the attribute properties. If not provided, all attributes
                  are treated as numeric values.</p></dd><dt class="param">ntrees</dt><dd class="cmt"><p>the number of trees.</p></dd><dt class="param">maxNodes</dt><dd class="cmt"><p>maximum number of leaf nodes.</p></dd><dt class="param">nodeSize</dt><dd class="cmt"><p>the number of instances in a node below which the tree will
         not split, setting nodeSize = 5 generally gives good results.</p></dd><dt class="param">mtry</dt><dd class="cmt"><p>the number of input variables to be used to determine the decision
            at a node of the tree. dim/3 seems to give generally good performance,
            where dim is the number of variables.</p></dd><dt class="param">subsample</dt><dd class="cmt"><p>the sampling rate for training tree. 1.0 means sampling with replacement. &lt; 1.0 means
                 sampling without replacement.</p></dd><dt>returns</dt><dd class="cmt"><p>Random forest regression model.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#rbfnet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rbfnet[T&lt;:AnyRef,RBF&lt;:smile.math.rbf.RadialBasisFunction](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:Array[RBF],centers:Array[T]):smile.regression.RBFNetwork[T]"></a>
      <a id="rbfnet[T&lt;:AnyRef,RBF&lt;:RadialBasisFunction](Array[T],Array[Double],Metric[T],Array[RBF],Array[T]):RBFNetwork[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rbfnet</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>, <span name="RBF">RBF &lt;: <span class="extype" name="smile.math.rbf.RadialBasisFunction">RadialBasisFunction</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>, <span name="rbf">rbf: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.rbfnet.RBF">RBF</span>]</span>, <span name="centers">centers: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="smile.regression.RBFNetwork">RBFNetwork</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@rbfnet[T&lt;:AnyRef,RBF&lt;:smile.math.rbf.RadialBasisFunction](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:Array[RBF],centers:Array[T]):smile.regression.RBFNetwork[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Radial basis function networks.</p><div class="fullcomment"><div class="comment cmt"><p>Radial basis function networks. A radial basis function network is an
artificial neural network that uses radial basis functions as activation
functions. It is a linear combination of radial basis functions. They are
used in function approximation, time series prediction, and control.</p><p>In its basic form, radial basis function network is in the form</p><p>y(x) = &Sigma; w<sub>i</sub> &phi;(||x-c<sub>i</sub>||)</p><p>where the approximating function y(x) is represented as a sum of N radial
basis functions &phi;, each associated with a different center c<sub>i</sub>,
and weighted by an appropriate coefficient w<sub>i</sub>. For distance,
one usually chooses Euclidean distance. The weights w<sub>i</sub> can
be estimated using the matrix methods of linear least squares, because
the approximating function is linear in the weights.</p><p>The centers c<sub>i</sub> can be randomly selected from training data,
or learned by some clustering method (e.g. k-means), or learned together
with weight parameters undergo a supervised learning processing
(e.g. error-correction learning).</p><p>The popular choices for &phi; comprise the Gaussian function and the so
called thin plate splines. The advantage of the thin plate splines is that
their conditioning is invariant under scalings. Gaussian, multi-quadric
and inverse multi-quadric are infinitely smooth and and involve a scale
or shape parameter, r<sub><small>0</small></sub> &gt; 0. Decreasing
r<sub><small>0</small></sub> tends to flatten the basis function. For a
given function, the quality of approximation may strongly depend on this
parameter. In particular, increasing r<sub><small>0</small></sub> has the
effect of better conditioning (the separation distance of the scaled points
increases).</p><p>A variant on RBF networks is normalized radial basis function (NRBF)
networks, in which we require the sum of the basis functions to be unity.
NRBF arises more naturally from a Bayesian statistical perspective. However,
there is no evidence that either the NRBF method is consistently superior
to the RBF method, or vice versa.</p><p>SVMs with Gaussian kernel have similar structure as RBF networks with
Gaussian radial basis functions. However, the SVM approach &quot;automatically&quot;
solves the network complexity problem since the size of the hidden layer
is obtained as the result of the QP procedure. Hidden neurons and
support vectors correspond to each other, so the center problems of
the RBF network is also solved, as the support vectors serve as the
basis function centers. It was reported that with similar number of support
vectors/centers, SVM shows better generalization performance than RBF
network when the training data size is relatively small. On the other hand,
RBF network gives better generalization performance than SVM on large
training data.</p><h6>References:</h6><ul><li>Simon Haykin. Neural Networks: A Comprehensive Foundation (2nd edition). 1999.</li><li>T. Poggio and F. Girosi. Networks for approximation and learning. Proc. IEEE 78(9):1484-1487, 1990.</li><li>Nabil Benoudjit and Michel Verleysen. On the kernel widths in radial-basis function networks. Neural Process, 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>training samples.</p></dd><dt class="param">y</dt><dd class="cmt"><p>response variable.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance metric functor.</p></dd><dt class="param">rbf</dt><dd class="cmt"><p>the radial basis functions at each center.</p></dd><dt class="param">centers</dt><dd class="cmt"><p>the centers of RBF functions.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#rbfnet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rbfnet[T&lt;:AnyRef](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:smile.math.rbf.RadialBasisFunction,centers:Array[T]):smile.regression.RBFNetwork[T]"></a>
      <a id="rbfnet[T&lt;:AnyRef](Array[T],Array[Double],Metric[T],RadialBasisFunction,Array[T]):RBFNetwork[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rbfnet</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="distance">distance: <span class="extype" name="smile.math.distance.Metric">Metric</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>, <span name="rbf">rbf: <span class="extype" name="smile.math.rbf.RadialBasisFunction">RadialBasisFunction</span></span>, <span name="centers">centers: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="smile.regression.RBFNetwork">RBFNetwork</span>[<span class="extype" name="smile.regression.Operators.rbfnet.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@rbfnet[T&lt;:AnyRef](x:Array[T],y:Array[Double],distance:smile.math.distance.Metric[T],rbf:smile.math.rbf.RadialBasisFunction,centers:Array[T]):smile.regression.RBFNetwork[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Radial basis function networks.</p><div class="fullcomment"><div class="comment cmt"><p>Radial basis function networks. A radial basis function network is an
artificial neural network that uses radial basis functions as activation
functions. It is a linear combination of radial basis functions. They are
used in function approximation, time series prediction, and control.</p><p>In its basic form, radial basis function network is in the form</p><p>y(x) = &Sigma; w<sub>i</sub> &phi;(||x-c<sub>i</sub>||)</p><p>where the approximating function y(x) is represented as a sum of N radial
basis functions &phi;, each associated with a different center c<sub>i</sub>,
and weighted by an appropriate coefficient w<sub>i</sub>. For distance,
one usually chooses Euclidean distance. The weights w<sub>i</sub> can
be estimated using the matrix methods of linear least squares, because
the approximating function is linear in the weights.</p><p>The centers c<sub>i</sub> can be randomly selected from training data,
or learned by some clustering method (e.g. k-means), or learned together
with weight parameters undergo a supervised learning processing
(e.g. error-correction learning).</p><p>The popular choices for &phi; comprise the Gaussian function and the so
called thin plate splines. The advantage of the thin plate splines is that
their conditioning is invariant under scalings. Gaussian, multi-quadric
and inverse multi-quadric are infinitely smooth and and involve a scale
or shape parameter, r<sub><small>0</small></sub> &gt; 0. Decreasing
r<sub><small>0</small></sub> tends to flatten the basis function. For a
given function, the quality of approximation may strongly depend on this
parameter. In particular, increasing r<sub><small>0</small></sub> has the
effect of better conditioning (the separation distance of the scaled points
increases).</p><p>A variant on RBF networks is normalized radial basis function (NRBF)
networks, in which we require the sum of the basis functions to be unity.
NRBF arises more naturally from a Bayesian statistical perspective. However,
there is no evidence that either the NRBF method is consistently superior
to the RBF method, or vice versa.</p><p>SVMs with Gaussian kernel have similar structure as RBF networks with
Gaussian radial basis functions. However, the SVM approach &quot;automatically&quot;
solves the network complexity problem since the size of the hidden layer
is obtained as the result of the QP procedure. Hidden neurons and
support vectors correspond to each other, so the center problems of
the RBF network is also solved, as the support vectors serve as the
basis function centers. It was reported that with similar number of support
vectors/centers, SVM shows better generalization performance than RBF
network when the training data size is relatively small. On the other hand,
RBF network gives better generalization performance than SVM on large
training data.</p><h6>References:</h6><ul><li>Simon Haykin. Neural Networks: A Comprehensive Foundation (2nd edition). 1999.</li><li>T. Poggio and F. Girosi. Networks for approximation and learning. Proc. IEEE 78(9):1484-1487, 1990.</li><li>Nabil Benoudjit and Michel Verleysen. On the kernel widths in radial-basis function networks. Neural Process, 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>training samples.</p></dd><dt class="param">y</dt><dd class="cmt"><p>response variable.</p></dd><dt class="param">distance</dt><dd class="cmt"><p>the distance metric functor.</p></dd><dt class="param">rbf</dt><dd class="cmt"><p>the radial basis function.</p></dd><dt class="param">centers</dt><dd class="cmt"><p>the centers of RBF functions.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#ridge" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ridge(x:Array[Array[Double]],y:Array[Double],lambda:Double):smile.regression.RidgeRegression"></a>
      <a id="ridge(Array[Array[Double]],Array[Double],Double):RidgeRegression"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ridge</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="lambda">lambda: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.RidgeRegression">RidgeRegression</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@ridge(x:Array[Array[Double]],y:Array[Double],lambda:Double):smile.regression.RidgeRegression" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Ridge Regression.</p><div class="fullcomment"><div class="comment cmt"><p>Ridge Regression. When the predictor variables are highly correlated amongst
themselves, the coefficients of the resulting least squares fit may be very
imprecise. By allowing a small amount of bias in the estimates, more
reasonable coefficients may often be obtained. Ridge regression is one
method to address these issues. Often, small amounts of bias lead to
dramatic reductions in the variance of the estimated model coefficients.
Ridge regression is such a technique which shrinks the regression
coefficients by imposing a penalty on their size. Ridge regression was
originally developed to overcome the singularity of the X'X matrix.
This matrix is perturbed so as to make its determinant appreciably
different from 0.</p><p>Ridge regression is a kind of Tikhonov regularization, which is the most
commonly used method of regularization of ill-posed problems. Another
interpretation of ridge regression is available through Bayesian estimation.
In this setting the belief that weight should be small is coded into a prior
distribution.
</p></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>a matrix containing the explanatory variables.</p></dd><dt class="param">y</dt><dd class="cmt"><p>the response values.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>the shrinkage/regularization parameter.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li><li name="smile.regression.Operators#svr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="svr[T&lt;:AnyRef](x:Array[T],y:Array[Double],kernel:smile.math.kernel.MercerKernel[T],eps:Double,C:Double,weight:Array[Double],tol:Double):smile.regression.SVR[T]"></a>
      <a id="svr[T&lt;:AnyRef](Array[T],Array[Double],MercerKernel[T],Double,Double,Array[Double],Double):SVR[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">svr</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.AnyRef">AnyRef</span></span>]</span><span class="params">(<span name="x">x: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="smile.regression.Operators.svr.T">T</span>]</span>, <span name="y">y: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>, <span name="kernel">kernel: <span class="extype" name="smile.math.kernel.MercerKernel">MercerKernel</span>[<span class="extype" name="smile.regression.Operators.svr.T">T</span>]</span>, <span name="eps">eps: <span class="extype" name="scala.Double">Double</span></span>, <span name="C">C: <span class="extype" name="scala.Double">Double</span></span>, <span name="weight">weight: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>] = <span class="symbol">null</span></span>, <span name="tol">tol: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">1E-3</span></span>)</span><span class="result">: <span class="extype" name="smile.regression.SVR">SVR</span>[<span class="extype" name="smile.regression.Operators.svr.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#smile.regression.package@svr[T&lt;:AnyRef](x:Array[T],y:Array[Double],kernel:smile.math.kernel.MercerKernel[T],eps:Double,C:Double,weight:Array[Double],tol:Double):smile.regression.SVR[T]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Support vector regression.</p><div class="fullcomment"><div class="comment cmt"><p>Support vector regression. Like SVM for classification, the model produced
by SVR depends only on a subset of the training data, because the cost
function ignores any training data close to the model prediction (within
a threshold).
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the data type</p></dd><dt class="param">x</dt><dd class="cmt"><p>training data.</p></dd><dt class="param">y</dt><dd class="cmt"><p>response variable.</p></dd><dt class="param">kernel</dt><dd class="cmt"><p>the kernel function.</p></dd><dt class="param">eps</dt><dd class="cmt"><p>the loss function error threshold.</p></dd><dt class="param">C</dt><dd class="cmt"><p>the soft margin penalty parameter.</p></dd><dt class="param">weight</dt><dd class="cmt"><p>positive instance weight. The soft margin penalty
              parameter for instance i will be weight[i] * C.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>the tolerance of convergence test.</p></dd><dt>returns</dt><dd class="cmt"><p>SVR model.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="smile.regression.Operators">
              <h3>Inherited from <a href="Operators.html" class="extype" name="smile.regression.Operators">Operators</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
