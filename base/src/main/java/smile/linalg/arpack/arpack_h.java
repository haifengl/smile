// Generated by jextract

package smile.linalg.arpack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class arpack_h {

    arpack_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("arpack"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int INTERFACE64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define INTERFACE64 0
     * }
     */
    public static int INTERFACE64() {
        return INTERFACE64;
    }

    private static class cnaupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("cnaupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cnaupd_c$descriptor() {
        return cnaupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static MethodHandle cnaupd_c$handle() {
        return cnaupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static MemorySegment cnaupd_c$address() {
        return cnaupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static void cnaupd_c(MemorySegment ido, MemorySegment bmat, int n, MemorySegment which, int nev, float tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment rwork, MemorySegment info) {
        var mh$ = cnaupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cnaupd_c", ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
            }
            mh$.invokeExact(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cneupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("cneupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cneupd_c(int rvec, const char *howmny, const int *select, _Complex float *d, _Complex float *z, int ldz, _Complex float sigma, _Complex float *workev, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cneupd_c$descriptor() {
        return cneupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cneupd_c(int rvec, const char *howmny, const int *select, _Complex float *d, _Complex float *z, int ldz, _Complex float sigma, _Complex float *workev, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static MethodHandle cneupd_c$handle() {
        return cneupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cneupd_c(int rvec, const char *howmny, const int *select, _Complex float *d, _Complex float *z, int ldz, _Complex float sigma, _Complex float *workev, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static MemorySegment cneupd_c$address() {
        return cneupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cneupd_c(int rvec, const char *howmny, const int *select, _Complex float *d, _Complex float *z, int ldz, _Complex float sigma, _Complex float *workev, const char *bmat, int n, const char *which, int nev, float tol, _Complex float *resid, int ncv, _Complex float *v, int ldv, int *iparam, int *ipntr, _Complex float *workd, _Complex float *workl, int lworkl, float *rwork, int *info)
     * }
     */
    public static void cneupd_c(int rvec, MemorySegment howmny, MemorySegment select, MemorySegment d, MemorySegment z, int ldz, float sigma, MemorySegment workev, MemorySegment bmat, int n, MemorySegment which, int nev, float tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment rwork, MemorySegment info) {
        var mh$ = cneupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cneupd_c", rvec, howmny, select, d, z, ldz, sigma, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
            }
            mh$.invokeExact(rvec, howmny, select, d, z, ldz, sigma, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dnaupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("dnaupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor dnaupd_c$descriptor() {
        return dnaupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle dnaupd_c$handle() {
        return dnaupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment dnaupd_c$address() {
        return dnaupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dnaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static void dnaupd_c(MemorySegment ido, MemorySegment bmat, int n, MemorySegment which, int nev, double tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = dnaupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dnaupd_c", ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dneupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("dneupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dneupd_c(int rvec, const char *howmny, const int *select, double *dr, double *di, double *z, int ldz, double sigmar, double sigmai, double *workev, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor dneupd_c$descriptor() {
        return dneupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dneupd_c(int rvec, const char *howmny, const int *select, double *dr, double *di, double *z, int ldz, double sigmar, double sigmai, double *workev, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle dneupd_c$handle() {
        return dneupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dneupd_c(int rvec, const char *howmny, const int *select, double *dr, double *di, double *z, int ldz, double sigmar, double sigmai, double *workev, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment dneupd_c$address() {
        return dneupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dneupd_c(int rvec, const char *howmny, const int *select, double *dr, double *di, double *z, int ldz, double sigmar, double sigmai, double *workev, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static void dneupd_c(int rvec, MemorySegment howmny, MemorySegment select, MemorySegment dr, MemorySegment di, MemorySegment z, int ldz, double sigmar, double sigmai, MemorySegment workev, MemorySegment bmat, int n, MemorySegment which, int nev, double tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = dneupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dneupd_c", rvec, howmny, select, dr, di, z, ldz, sigmar, sigmai, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(rvec, howmny, select, dr, di, z, ldz, sigmar, sigmai, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsaupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("dsaupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor dsaupd_c$descriptor() {
        return dsaupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle dsaupd_c$handle() {
        return dsaupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment dsaupd_c$address() {
        return dsaupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static void dsaupd_c(MemorySegment ido, MemorySegment bmat, int n, MemorySegment which, int nev, double tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = dsaupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsaupd_c", ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dseupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("dseupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dseupd_c(int rvec, const char *howmny, const int *select, double *d, double *z, int ldz, double sigma, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor dseupd_c$descriptor() {
        return dseupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dseupd_c(int rvec, const char *howmny, const int *select, double *d, double *z, int ldz, double sigma, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle dseupd_c$handle() {
        return dseupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dseupd_c(int rvec, const char *howmny, const int *select, double *d, double *z, int ldz, double sigma, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment dseupd_c$address() {
        return dseupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dseupd_c(int rvec, const char *howmny, const int *select, double *d, double *z, int ldz, double sigma, const char *bmat, int n, const char *which, int nev, double tol, double *resid, int ncv, double *v, int ldv, int *iparam, int *ipntr, double *workd, double *workl, int lworkl, int *info)
     * }
     */
    public static void dseupd_c(int rvec, MemorySegment howmny, MemorySegment select, MemorySegment d, MemorySegment z, int ldz, double sigma, MemorySegment bmat, int n, MemorySegment which, int nev, double tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = dseupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dseupd_c", rvec, howmny, select, d, z, ldz, sigma, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(rvec, howmny, select, d, z, ldz, sigma, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class snaupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("snaupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void snaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor snaupd_c$descriptor() {
        return snaupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void snaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle snaupd_c$handle() {
        return snaupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void snaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment snaupd_c$address() {
        return snaupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void snaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static void snaupd_c(MemorySegment ido, MemorySegment bmat, int n, MemorySegment which, int nev, float tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = snaupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("snaupd_c", ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sneupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("sneupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sneupd_c(int rvec, const char *howmny, const int *select, float *dr, float *di, float *z, int ldz, float sigmar, float sigmai, float *workev, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor sneupd_c$descriptor() {
        return sneupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sneupd_c(int rvec, const char *howmny, const int *select, float *dr, float *di, float *z, int ldz, float sigmar, float sigmai, float *workev, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle sneupd_c$handle() {
        return sneupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sneupd_c(int rvec, const char *howmny, const int *select, float *dr, float *di, float *z, int ldz, float sigmar, float sigmai, float *workev, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment sneupd_c$address() {
        return sneupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sneupd_c(int rvec, const char *howmny, const int *select, float *dr, float *di, float *z, int ldz, float sigmar, float sigmai, float *workev, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static void sneupd_c(int rvec, MemorySegment howmny, MemorySegment select, MemorySegment dr, MemorySegment di, MemorySegment z, int ldz, float sigmar, float sigmai, MemorySegment workev, MemorySegment bmat, int n, MemorySegment which, int nev, float tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = sneupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sneupd_c", rvec, howmny, select, dr, di, z, ldz, sigmar, sigmai, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(rvec, howmny, select, dr, di, z, ldz, sigmar, sigmai, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssaupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("ssaupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor ssaupd_c$descriptor() {
        return ssaupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle ssaupd_c$handle() {
        return ssaupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment ssaupd_c$address() {
        return ssaupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static void ssaupd_c(MemorySegment ido, MemorySegment bmat, int n, MemorySegment which, int nev, float tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = ssaupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssaupd_c", ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sseupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_FLOAT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("sseupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sseupd_c(int rvec, const char *howmny, const int *select, float *d, float *z, int ldz, float sigma, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static FunctionDescriptor sseupd_c$descriptor() {
        return sseupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sseupd_c(int rvec, const char *howmny, const int *select, float *d, float *z, int ldz, float sigma, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MethodHandle sseupd_c$handle() {
        return sseupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sseupd_c(int rvec, const char *howmny, const int *select, float *d, float *z, int ldz, float sigma, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static MemorySegment sseupd_c$address() {
        return sseupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sseupd_c(int rvec, const char *howmny, const int *select, float *d, float *z, int ldz, float sigma, const char *bmat, int n, const char *which, int nev, float tol, float *resid, int ncv, float *v, int ldv, int *iparam, int *ipntr, float *workd, float *workl, int lworkl, int *info)
     * }
     */
    public static void sseupd_c(int rvec, MemorySegment howmny, MemorySegment select, MemorySegment d, MemorySegment z, int ldz, float sigma, MemorySegment bmat, int n, MemorySegment which, int nev, float tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment info) {
        var mh$ = sseupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sseupd_c", rvec, howmny, select, d, z, ldz, sigma, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
            }
            mh$.invokeExact(rvec, howmny, select, d, z, ldz, sigma, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class znaupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("znaupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void znaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor znaupd_c$descriptor() {
        return znaupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void znaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static MethodHandle znaupd_c$handle() {
        return znaupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void znaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static MemorySegment znaupd_c$address() {
        return znaupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void znaupd_c(int *ido, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static void znaupd_c(MemorySegment ido, MemorySegment bmat, int n, MemorySegment which, int nev, double tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment rwork, MemorySegment info) {
        var mh$ = znaupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("znaupd_c", ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
            }
            mh$.invokeExact(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zneupd_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_DOUBLE,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER,
            arpack_h.C_INT,
            arpack_h.C_POINTER,
            arpack_h.C_POINTER
        );

        public static final MemorySegment ADDR = arpack_h.findOrThrow("zneupd_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zneupd_c(int rvec, const char *howmny, const int *select, _Complex double *d, _Complex double *z, int ldz, _Complex double sigma, _Complex double *workev, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zneupd_c$descriptor() {
        return zneupd_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zneupd_c(int rvec, const char *howmny, const int *select, _Complex double *d, _Complex double *z, int ldz, _Complex double sigma, _Complex double *workev, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static MethodHandle zneupd_c$handle() {
        return zneupd_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zneupd_c(int rvec, const char *howmny, const int *select, _Complex double *d, _Complex double *z, int ldz, _Complex double sigma, _Complex double *workev, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static MemorySegment zneupd_c$address() {
        return zneupd_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zneupd_c(int rvec, const char *howmny, const int *select, _Complex double *d, _Complex double *z, int ldz, _Complex double sigma, _Complex double *workev, const char *bmat, int n, const char *which, int nev, double tol, _Complex double *resid, int ncv, _Complex double *v, int ldv, int *iparam, int *ipntr, _Complex double *workd, _Complex double *workl, int lworkl, double *rwork, int *info)
     * }
     */
    public static void zneupd_c(int rvec, MemorySegment howmny, MemorySegment select, MemorySegment d, MemorySegment z, int ldz, double sigma, MemorySegment workev, MemorySegment bmat, int n, MemorySegment which, int nev, double tol, MemorySegment resid, int ncv, MemorySegment v, int ldv, MemorySegment iparam, MemorySegment ipntr, MemorySegment workd, MemorySegment workl, int lworkl, MemorySegment rwork, MemorySegment info) {
        var mh$ = zneupd_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zneupd_c", rvec, howmny, select, d, z, ldz, sigma, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
            }
            mh$.invokeExact(rvec, howmny, select, d, z, ldz, sigma, workev, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

