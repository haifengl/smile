// Generated by jextract

package smile.linalg.blas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_h {

    cblas_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final String OS = System.getProperty("os.name", "linux").toLowerCase().split(" ")[0];
    static final String LIBRARY_NAME = System.getProperty("smile.lib.blas", switch (OS) {
        case "mac" -> "blas"; // macOS's builtin Accelerate framework
        case "windows" -> "libopenblas"; // ARPACK depends on this name
        default -> "openblas"; // OpenBLAS
    });
    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName(LIBRARY_NAME), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int OPENBLAS_OS_LINUX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_OS_LINUX 1
     * }
     */
    public static int OPENBLAS_OS_LINUX() {
        return OPENBLAS_OS_LINUX;
    }
    private static final int OPENBLAS_ARCH_X86_64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_ARCH_X86_64 1
     * }
     */
    public static int OPENBLAS_ARCH_X86_64() {
        return OPENBLAS_ARCH_X86_64;
    }
    private static final int OPENBLAS_C_GCC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_C_GCC 1
     * }
     */
    public static int OPENBLAS_C_GCC() {
        return OPENBLAS_C_GCC;
    }
    private static final int OPENBLAS___64BIT__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS___64BIT__ 1
     * }
     */
    public static int OPENBLAS___64BIT__() {
        return OPENBLAS___64BIT__;
    }
    private static final int OPENBLAS_HAVE_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_HAVE_C11 1
     * }
     */
    public static int OPENBLAS_HAVE_C11() {
        return OPENBLAS_HAVE_C11;
    }
    private static final int OPENBLAS_NEEDBUNDERSCORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_NEEDBUNDERSCORE 1
     * }
     */
    public static int OPENBLAS_NEEDBUNDERSCORE() {
        return OPENBLAS_NEEDBUNDERSCORE;
    }
    private static final int OPENBLAS_L1_DATA_SIZE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L1_DATA_SIZE 32768
     * }
     */
    public static int OPENBLAS_L1_DATA_SIZE() {
        return OPENBLAS_L1_DATA_SIZE;
    }
    private static final int OPENBLAS_L1_DATA_LINESIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L1_DATA_LINESIZE 128
     * }
     */
    public static int OPENBLAS_L1_DATA_LINESIZE() {
        return OPENBLAS_L1_DATA_LINESIZE;
    }
    private static final int OPENBLAS_L2_SIZE = (int)512488L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_SIZE 512488
     * }
     */
    public static int OPENBLAS_L2_SIZE() {
        return OPENBLAS_L2_SIZE;
    }
    private static final int OPENBLAS_L2_LINESIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_LINESIZE 128
     * }
     */
    public static int OPENBLAS_L2_LINESIZE() {
        return OPENBLAS_L2_LINESIZE;
    }
    private static final int OPENBLAS_DTB_DEFAULT_ENTRIES = (int)128L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DTB_DEFAULT_ENTRIES 128
     * }
     */
    public static int OPENBLAS_DTB_DEFAULT_ENTRIES() {
        return OPENBLAS_DTB_DEFAULT_ENTRIES;
    }
    private static final int OPENBLAS_DTB_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DTB_SIZE 4096
     * }
     */
    public static int OPENBLAS_DTB_SIZE() {
        return OPENBLAS_DTB_SIZE;
    }
    private static final int OPENBLAS_L2_ASSOCIATIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_L2_ASSOCIATIVE 8
     * }
     */
    public static int OPENBLAS_L2_ASSOCIATIVE() {
        return OPENBLAS_L2_ASSOCIATIVE;
    }
    private static final int OPENBLAS_SLOCAL_BUFFER_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_SLOCAL_BUFFER_SIZE 4096
     * }
     */
    public static int OPENBLAS_SLOCAL_BUFFER_SIZE() {
        return OPENBLAS_SLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_DLOCAL_BUFFER_SIZE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_DLOCAL_BUFFER_SIZE 4096
     * }
     */
    public static int OPENBLAS_DLOCAL_BUFFER_SIZE() {
        return OPENBLAS_DLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_CLOCAL_BUFFER_SIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_CLOCAL_BUFFER_SIZE 8192
     * }
     */
    public static int OPENBLAS_CLOCAL_BUFFER_SIZE() {
        return OPENBLAS_CLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_ZLOCAL_BUFFER_SIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_ZLOCAL_BUFFER_SIZE 8192
     * }
     */
    public static int OPENBLAS_ZLOCAL_BUFFER_SIZE() {
        return OPENBLAS_ZLOCAL_BUFFER_SIZE;
    }
    private static final int OPENBLAS_GEMM_MULTITHREAD_THRESHOLD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_GEMM_MULTITHREAD_THRESHOLD 4
     * }
     */
    public static int OPENBLAS_GEMM_MULTITHREAD_THRESHOLD() {
        return OPENBLAS_GEMM_MULTITHREAD_THRESHOLD;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _COMPLEX_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _COMPLEX_H 1
     * }
     */
    public static int _COMPLEX_H() {
        return _COMPLEX_H;
    }
    private static final int _SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SCHED_H 1
     * }
     */
    public static int _SCHED_H() {
        return _SCHED_H;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SCHED_H 1
     * }
     */
    public static int _BITS_SCHED_H() {
        return _BITS_SCHED_H;
    }
    private static final int SCHED_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 0
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 1
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int _BITS_TYPES_STRUCT_SCHED_PARAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_STRUCT_SCHED_PARAM 1
     * }
     */
    public static int _BITS_TYPES_STRUCT_SCHED_PARAM() {
        return _BITS_TYPES_STRUCT_SCHED_PARAM;
    }
    private static final int _BITS_CPU_SET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_CPU_SET_H 1
     * }
     */
    public static int _BITS_CPU_SET_H() {
        return _BITS_CPU_SET_H;
    }
    private static final int __CPU_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __CPU_SETSIZE 1024
     * }
     */
    public static int __CPU_SETSIZE() {
        return __CPU_SETSIZE;
    }
    private static final int OPENBLAS_SEQUENTIAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_SEQUENTIAL 0
     * }
     */
    public static int OPENBLAS_SEQUENTIAL() {
        return OPENBLAS_SEQUENTIAL;
    }
    private static final int OPENBLAS_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_THREAD 1
     * }
     */
    public static int OPENBLAS_THREAD() {
        return OPENBLAS_THREAD;
    }
    private static final int OPENBLAS_OPENMP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_OPENMP 2
     * }
     */
    public static int OPENBLAS_OPENMP() {
        return OPENBLAS_OPENMP;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long BLASLONG
     * }
     */
    public static final OfLong BLASLONG = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long BLASULONG
     * }
     */
    public static final OfLong BLASULONG = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = smile.linalg.blas.cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = cblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = cblas_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = cblas_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint16_t bfloat16
     * }
     */
    public static final OfShort bfloat16 = cblas_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int blasint
     * }
     */
    public static final OfInt blasint = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = cblas_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = cblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = cblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = cblas_h.C_POINTER;
        public static final MemorySegment SEGMENT = cblas_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER,
                cblas_h.C_LONG,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_INT,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                cblas_h.C_INT,
                cblas_h.C_POINTER,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = cblas_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = cblas_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = cblas_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_LONG,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacos$descriptor() {
        return cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MethodHandle cacos$handle() {
        return cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MemorySegment cacos$address() {
        return cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static double cacos(double __z) {
        var mh$ = cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacos$descriptor() {
        return __cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MethodHandle __cacos$handle() {
        return __cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MemorySegment __cacos$address() {
        return __cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static double __cacos(double __z) {
        var mh$ = __cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casin$descriptor() {
        return casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MethodHandle casin$handle() {
        return casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MemorySegment casin$address() {
        return casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static double casin(double __z) {
        var mh$ = casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casin$descriptor() {
        return __casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MethodHandle __casin$handle() {
        return __casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MemorySegment __casin$address() {
        return __casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static double __casin(double __z) {
        var mh$ = __casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catan$descriptor() {
        return catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MethodHandle catan$handle() {
        return catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MemorySegment catan$address() {
        return catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static double catan(double __z) {
        var mh$ = catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catan$descriptor() {
        return __catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MethodHandle __catan$handle() {
        return __catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MemorySegment __catan$address() {
        return __catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static double __catan(double __z) {
        var mh$ = __catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccos$descriptor() {
        return ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MethodHandle ccos$handle() {
        return ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MemorySegment ccos$address() {
        return ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static double ccos(double __z) {
        var mh$ = ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccos$descriptor() {
        return __ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MethodHandle __ccos$handle() {
        return __ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MemorySegment __ccos$address() {
        return __ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static double __ccos(double __z) {
        var mh$ = __ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csin$descriptor() {
        return csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MethodHandle csin$handle() {
        return csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MemorySegment csin$address() {
        return csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static double csin(double __z) {
        var mh$ = csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csin$descriptor() {
        return __csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MethodHandle __csin$handle() {
        return __csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MemorySegment __csin$address() {
        return __csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static double __csin(double __z) {
        var mh$ = __csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctan$descriptor() {
        return ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MethodHandle ctan$handle() {
        return ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MemorySegment ctan$address() {
        return ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static double ctan(double __z) {
        var mh$ = ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctan$descriptor() {
        return __ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MethodHandle __ctan$handle() {
        return __ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MemorySegment __ctan$address() {
        return __ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static double __ctan(double __z) {
        var mh$ = __ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacosh$descriptor() {
        return cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle cacosh$handle() {
        return cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment cacosh$address() {
        return cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static double cacosh(double __z) {
        var mh$ = cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacosh$descriptor() {
        return __cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle __cacosh$handle() {
        return __cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment __cacosh$address() {
        return __cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static double __cacosh(double __z) {
        var mh$ = __cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casinh$descriptor() {
        return casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MethodHandle casinh$handle() {
        return casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MemorySegment casinh$address() {
        return casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static double casinh(double __z) {
        var mh$ = casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casinh$descriptor() {
        return __casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MethodHandle __casinh$handle() {
        return __casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MemorySegment __casinh$address() {
        return __casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static double __casinh(double __z) {
        var mh$ = __casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catanh$descriptor() {
        return catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MethodHandle catanh$handle() {
        return catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MemorySegment catanh$address() {
        return catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static double catanh(double __z) {
        var mh$ = catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catanh$descriptor() {
        return __catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MethodHandle __catanh$handle() {
        return __catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MemorySegment __catanh$address() {
        return __catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static double __catanh(double __z) {
        var mh$ = __catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccosh$descriptor() {
        return ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle ccosh$handle() {
        return ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment ccosh$address() {
        return ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static double ccosh(double __z) {
        var mh$ = ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccosh$descriptor() {
        return __ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle __ccosh$handle() {
        return __ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment __ccosh$address() {
        return __ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static double __ccosh(double __z) {
        var mh$ = __ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csinh$descriptor() {
        return csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MethodHandle csinh$handle() {
        return csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MemorySegment csinh$address() {
        return csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static double csinh(double __z) {
        var mh$ = csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csinh$descriptor() {
        return __csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MethodHandle __csinh$handle() {
        return __csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MemorySegment __csinh$address() {
        return __csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static double __csinh(double __z) {
        var mh$ = __csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctanh$descriptor() {
        return ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle ctanh$handle() {
        return ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment ctanh$address() {
        return ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static double ctanh(double __z) {
        var mh$ = ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctanh$descriptor() {
        return __ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle __ctanh$handle() {
        return __ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment __ctanh$address() {
        return __ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static double __ctanh(double __z) {
        var mh$ = __ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cexp$descriptor() {
        return cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MethodHandle cexp$handle() {
        return cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MemorySegment cexp$address() {
        return cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static double cexp(double __z) {
        var mh$ = cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cexp$descriptor() {
        return __cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MethodHandle __cexp$handle() {
        return __cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MemorySegment __cexp$address() {
        return __cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static double __cexp(double __z) {
        var mh$ = __cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor clog$descriptor() {
        return clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MethodHandle clog$handle() {
        return clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MemorySegment clog$address() {
        return clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static double clog(double __z) {
        var mh$ = clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __clog$descriptor() {
        return __clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MethodHandle __clog$handle() {
        return __clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MemorySegment __clog$address() {
        return __clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static double __clog(double __z) {
        var mh$ = __clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor cpow$descriptor() {
        return cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle cpow$handle() {
        return cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment cpow$address() {
        return cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double cpow(double __x, double __y) {
        var mh$ = cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor __cpow$descriptor() {
        return __cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle __cpow$handle() {
        return __cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment __cpow$address() {
        return __cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double __cpow(double __x, double __y) {
        var mh$ = __cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csqrt$descriptor() {
        return csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle csqrt$handle() {
        return csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment csqrt$address() {
        return csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static double csqrt(double __z) {
        var mh$ = csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csqrt$descriptor() {
        return __csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle __csqrt$handle() {
        return __csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment __csqrt$address() {
        return __csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static double __csqrt(double __z) {
        var mh$ = __csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cabs$descriptor() {
        return cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MethodHandle cabs$handle() {
        return cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MemorySegment cabs$address() {
        return cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static double cabs(double __z) {
        var mh$ = cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cabs$descriptor() {
        return __cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MethodHandle __cabs$handle() {
        return __cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MemorySegment __cabs$address() {
        return __cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static double __cabs(double __z) {
        var mh$ = __cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor carg$descriptor() {
        return carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MethodHandle carg$handle() {
        return carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MemorySegment carg$address() {
        return carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static double carg(double __z) {
        var mh$ = carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __carg$descriptor() {
        return __carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MethodHandle __carg$handle() {
        return __carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MemorySegment __carg$address() {
        return __carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static double __carg(double __z) {
        var mh$ = __carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor conj$descriptor() {
        return conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MethodHandle conj$handle() {
        return conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MemorySegment conj$address() {
        return conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static double conj(double __z) {
        var mh$ = conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __conj$descriptor() {
        return __conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MethodHandle __conj$handle() {
        return __conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MemorySegment __conj$address() {
        return __conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static double __conj(double __z) {
        var mh$ = __conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cproj$descriptor() {
        return cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MethodHandle cproj$handle() {
        return cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MemorySegment cproj$address() {
        return cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static double cproj(double __z) {
        var mh$ = cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cproj$descriptor() {
        return __cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MethodHandle __cproj$handle() {
        return __cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MemorySegment __cproj$address() {
        return __cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static double __cproj(double __z) {
        var mh$ = __cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cimag$descriptor() {
        return cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MethodHandle cimag$handle() {
        return cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MemorySegment cimag$address() {
        return cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static double cimag(double __z) {
        var mh$ = cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cimag$descriptor() {
        return __cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MethodHandle __cimag$handle() {
        return __cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MemorySegment __cimag$address() {
        return __cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static double __cimag(double __z) {
        var mh$ = __cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor creal$descriptor() {
        return creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MethodHandle creal$handle() {
        return creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MemorySegment creal$address() {
        return creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static double creal(double __z) {
        var mh$ = creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __creal$descriptor() {
        return __creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MethodHandle __creal$handle() {
        return __creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MemorySegment __creal$address() {
        return __creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static double __creal(double __z) {
        var mh$ = __creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacosf$descriptor() {
        return cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle cacosf$handle() {
        return cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment cacosf$address() {
        return cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static float cacosf(float __z) {
        var mh$ = cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacosf$descriptor() {
        return __cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacosf$handle() {
        return __cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacosf$address() {
        return __cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static float __cacosf(float __z) {
        var mh$ = __cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinf$descriptor() {
        return casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MethodHandle casinf$handle() {
        return casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MemorySegment casinf$address() {
        return casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static float casinf(float __z) {
        var mh$ = casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinf$descriptor() {
        return __casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinf$handle() {
        return __casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinf$address() {
        return __casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static float __casinf(float __z) {
        var mh$ = __casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanf$descriptor() {
        return catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MethodHandle catanf$handle() {
        return catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MemorySegment catanf$address() {
        return catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static float catanf(float __z) {
        var mh$ = catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanf$descriptor() {
        return __catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanf$handle() {
        return __catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanf$address() {
        return __catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static float __catanf(float __z) {
        var mh$ = __catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccosf$descriptor() {
        return ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle ccosf$handle() {
        return ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment ccosf$address() {
        return ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static float ccosf(float __z) {
        var mh$ = ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccosf$descriptor() {
        return __ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccosf$handle() {
        return __ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccosf$address() {
        return __ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static float __ccosf(float __z) {
        var mh$ = __ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinf$descriptor() {
        return csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MethodHandle csinf$handle() {
        return csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MemorySegment csinf$address() {
        return csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static float csinf(float __z) {
        var mh$ = csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinf$descriptor() {
        return __csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinf$handle() {
        return __csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinf$address() {
        return __csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static float __csinf(float __z) {
        var mh$ = __csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanf$descriptor() {
        return ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanf$handle() {
        return ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanf$address() {
        return ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static float ctanf(float __z) {
        var mh$ = ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanf$descriptor() {
        return __ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanf$handle() {
        return __ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanf$address() {
        return __ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static float __ctanf(float __z) {
        var mh$ = __ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacoshf$descriptor() {
        return cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle cacoshf$handle() {
        return cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment cacoshf$address() {
        return cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static float cacoshf(float __z) {
        var mh$ = cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacoshf$descriptor() {
        return __cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacoshf$handle() {
        return __cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacoshf$address() {
        return __cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static float __cacoshf(float __z) {
        var mh$ = __cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinhf$descriptor() {
        return casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle casinhf$handle() {
        return casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment casinhf$address() {
        return casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static float casinhf(float __z) {
        var mh$ = casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinhf$descriptor() {
        return __casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinhf$handle() {
        return __casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinhf$address() {
        return __casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static float __casinhf(float __z) {
        var mh$ = __casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanhf$descriptor() {
        return catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle catanhf$handle() {
        return catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment catanhf$address() {
        return catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static float catanhf(float __z) {
        var mh$ = catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanhf$descriptor() {
        return __catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanhf$handle() {
        return __catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanhf$address() {
        return __catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static float __catanhf(float __z) {
        var mh$ = __catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccoshf$descriptor() {
        return ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle ccoshf$handle() {
        return ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment ccoshf$address() {
        return ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static float ccoshf(float __z) {
        var mh$ = ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccoshf$descriptor() {
        return __ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccoshf$handle() {
        return __ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccoshf$address() {
        return __ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static float __ccoshf(float __z) {
        var mh$ = __ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinhf$descriptor() {
        return csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle csinhf$handle() {
        return csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment csinhf$address() {
        return csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static float csinhf(float __z) {
        var mh$ = csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinhf$descriptor() {
        return __csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinhf$handle() {
        return __csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinhf$address() {
        return __csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static float __csinhf(float __z) {
        var mh$ = __csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanhf$descriptor() {
        return ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanhf$handle() {
        return ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanhf$address() {
        return ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static float ctanhf(float __z) {
        var mh$ = ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanhf$descriptor() {
        return __ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanhf$handle() {
        return __ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanhf$address() {
        return __ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static float __ctanhf(float __z) {
        var mh$ = __ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cexpf$descriptor() {
        return cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle cexpf$handle() {
        return cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment cexpf$address() {
        return cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static float cexpf(float __z) {
        var mh$ = cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cexpf$descriptor() {
        return __cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle __cexpf$handle() {
        return __cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment __cexpf$address() {
        return __cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static float __cexpf(float __z) {
        var mh$ = __cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor clogf$descriptor() {
        return clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MethodHandle clogf$handle() {
        return clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MemorySegment clogf$address() {
        return clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static float clogf(float __z) {
        var mh$ = clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __clogf$descriptor() {
        return __clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MethodHandle __clogf$handle() {
        return __clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MemorySegment __clogf$address() {
        return __clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static float __clogf(float __z) {
        var mh$ = __clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor cpowf$descriptor() {
        return cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle cpowf$handle() {
        return cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment cpowf$address() {
        return cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float cpowf(float __x, float __y) {
        var mh$ = cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor __cpowf$descriptor() {
        return __cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle __cpowf$handle() {
        return __cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment __cpowf$address() {
        return __cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float __cpowf(float __x, float __y) {
        var mh$ = __cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csqrtf$descriptor() {
        return csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle csqrtf$handle() {
        return csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment csqrtf$address() {
        return csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static float csqrtf(float __z) {
        var mh$ = csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csqrtf$descriptor() {
        return __csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle __csqrtf$handle() {
        return __csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment __csqrtf$address() {
        return __csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static float __csqrtf(float __z) {
        var mh$ = __csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cabsf$descriptor() {
        return cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle cabsf$handle() {
        return cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment cabsf$address() {
        return cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static float cabsf(float __z) {
        var mh$ = cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cabsf$descriptor() {
        return __cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle __cabsf$handle() {
        return __cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment __cabsf$address() {
        return __cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static float __cabsf(float __z) {
        var mh$ = __cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cargf$descriptor() {
        return cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MethodHandle cargf$handle() {
        return cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MemorySegment cargf$address() {
        return cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static float cargf(float __z) {
        var mh$ = cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cargf$descriptor() {
        return __cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MethodHandle __cargf$handle() {
        return __cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MemorySegment __cargf$address() {
        return __cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static float __cargf(float __z) {
        var mh$ = __cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor conjf$descriptor() {
        return conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MethodHandle conjf$handle() {
        return conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MemorySegment conjf$address() {
        return conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static float conjf(float __z) {
        var mh$ = conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __conjf$descriptor() {
        return __conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MethodHandle __conjf$handle() {
        return __conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MemorySegment __conjf$address() {
        return __conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static float __conjf(float __z) {
        var mh$ = __conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cprojf$descriptor() {
        return cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle cprojf$handle() {
        return cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment cprojf$address() {
        return cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static float cprojf(float __z) {
        var mh$ = cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cprojf$descriptor() {
        return __cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle __cprojf$handle() {
        return __cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment __cprojf$address() {
        return __cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static float __cprojf(float __z) {
        var mh$ = __cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cimagf$descriptor() {
        return cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle cimagf$handle() {
        return cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment cimagf$address() {
        return cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static float cimagf(float __z) {
        var mh$ = cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cimagf$descriptor() {
        return __cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle __cimagf$handle() {
        return __cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment __cimagf$address() {
        return __cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static float __cimagf(float __z) {
        var mh$ = __cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor crealf$descriptor() {
        return crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MethodHandle crealf$handle() {
        return crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MemorySegment crealf$address() {
        return crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static float crealf(float __z) {
        var mh$ = crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __crealf$descriptor() {
        return __crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MethodHandle __crealf$handle() {
        return __crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MemorySegment __crealf$address() {
        return __crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static float __crealf(float __z) {
        var mh$ = __crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = cblas_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = cblas_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = cblas_h.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER,
            cblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_set_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_set_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static FunctionDescriptor openblas_set_num_threads$descriptor() {
        return openblas_set_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static MethodHandle openblas_set_num_threads$handle() {
        return openblas_set_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static MemorySegment openblas_set_num_threads$address() {
        return openblas_set_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void openblas_set_num_threads(int num_threads)
     * }
     */
    public static void openblas_set_num_threads(int num_threads) {
        var mh$ = openblas_set_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_set_num_threads", num_threads);
            }
            mh$.invokeExact(num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class goto_set_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("goto_set_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static FunctionDescriptor goto_set_num_threads$descriptor() {
        return goto_set_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static MethodHandle goto_set_num_threads$handle() {
        return goto_set_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static MemorySegment goto_set_num_threads$address() {
        return goto_set_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void goto_set_num_threads(int num_threads)
     * }
     */
    public static void goto_set_num_threads(int num_threads) {
        var mh$ = goto_set_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("goto_set_num_threads", num_threads);
            }
            mh$.invokeExact(num_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_num_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_get_num_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static FunctionDescriptor openblas_get_num_threads$descriptor() {
        return openblas_get_num_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static MethodHandle openblas_get_num_threads$handle() {
        return openblas_get_num_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static MemorySegment openblas_get_num_threads$address() {
        return openblas_get_num_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_num_threads()
     * }
     */
    public static int openblas_get_num_threads() {
        var mh$ = openblas_get_num_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_num_threads");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_num_procs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_get_num_procs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static FunctionDescriptor openblas_get_num_procs$descriptor() {
        return openblas_get_num_procs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static MethodHandle openblas_get_num_procs$handle() {
        return openblas_get_num_procs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static MemorySegment openblas_get_num_procs$address() {
        return openblas_get_num_procs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_num_procs()
     * }
     */
    public static int openblas_get_num_procs() {
        var mh$ = openblas_get_num_procs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_num_procs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_get_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static FunctionDescriptor openblas_get_config$descriptor() {
        return openblas_get_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MethodHandle openblas_get_config$handle() {
        return openblas_get_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MemorySegment openblas_get_config$address() {
        return openblas_get_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *openblas_get_config()
     * }
     */
    public static MemorySegment openblas_get_config() {
        var mh$ = openblas_get_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_config");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_corename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_POINTER    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_get_corename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static FunctionDescriptor openblas_get_corename$descriptor() {
        return openblas_get_corename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MethodHandle openblas_get_corename$handle() {
        return openblas_get_corename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MemorySegment openblas_get_corename$address() {
        return openblas_get_corename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *openblas_get_corename()
     * }
     */
    public static MemorySegment openblas_get_corename() {
        var mh$ = openblas_get_corename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_corename");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_setaffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_LONG,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_setaffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static FunctionDescriptor openblas_setaffinity$descriptor() {
        return openblas_setaffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static MethodHandle openblas_setaffinity$handle() {
        return openblas_setaffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static MemorySegment openblas_setaffinity$address() {
        return openblas_setaffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t *cpu_set)
     * }
     */
    public static int openblas_setaffinity(int thread_idx, long cpusetsize, MemorySegment cpu_set) {
        var mh$ = openblas_setaffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_setaffinity", thread_idx, cpusetsize, cpu_set);
            }
            return (int)mh$.invokeExact(thread_idx, cpusetsize, cpu_set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class openblas_get_parallel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("openblas_get_parallel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static FunctionDescriptor openblas_get_parallel$descriptor() {
        return openblas_get_parallel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static MethodHandle openblas_get_parallel$handle() {
        return openblas_get_parallel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static MemorySegment openblas_get_parallel$address() {
        return openblas_get_parallel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openblas_get_parallel()
     * }
     */
    public static int openblas_get_parallel() {
        var mh$ = openblas_get_parallel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openblas_get_parallel");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int CblasRowMajor = (int)101L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasRowMajor = 101
     * }
     */
    public static int CblasRowMajor() {
        return CblasRowMajor;
    }
    private static final int CblasColMajor = (int)102L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_ORDER.CblasColMajor = 102
     * }
     */
    public static int CblasColMajor() {
        return CblasColMajor;
    }
    private static final int CblasNoTrans = (int)111L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasNoTrans = 111
     * }
     */
    public static int CblasNoTrans() {
        return CblasNoTrans;
    }
    private static final int CblasTrans = (int)112L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasTrans = 112
     * }
     */
    public static int CblasTrans() {
        return CblasTrans;
    }
    private static final int CblasConjTrans = (int)113L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjTrans = 113
     * }
     */
    public static int CblasConjTrans() {
        return CblasConjTrans;
    }
    private static final int CblasConjNoTrans = (int)114L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_TRANSPOSE.CblasConjNoTrans = 114
     * }
     */
    public static int CblasConjNoTrans() {
        return CblasConjNoTrans;
    }
    private static final int CblasUpper = (int)121L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasUpper = 121
     * }
     */
    public static int CblasUpper() {
        return CblasUpper;
    }
    private static final int CblasLower = (int)122L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_UPLO.CblasLower = 122
     * }
     */
    public static int CblasLower() {
        return CblasLower;
    }
    private static final int CblasNonUnit = (int)131L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasNonUnit = 131
     * }
     */
    public static int CblasNonUnit() {
        return CblasNonUnit;
    }
    private static final int CblasUnit = (int)132L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_DIAG.CblasUnit = 132
     * }
     */
    public static int CblasUnit() {
        return CblasUnit;
    }
    private static final int CblasLeft = (int)141L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasLeft = 141
     * }
     */
    public static int CblasLeft() {
        return CblasLeft;
    }
    private static final int CblasRight = (int)142L;
    /**
     * {@snippet lang=c :
     * enum CBLAS_SIDE.CblasRight = 142
     * }
     */
    public static int CblasRight() {
        return CblasRight;
    }

    private static class cblas_sdsdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sdsdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sdsdot$descriptor() {
        return cblas_sdsdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sdsdot$handle() {
        return cblas_sdsdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sdsdot$address() {
        return cblas_sdsdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sdsdot(const blasint n, const float alpha, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static float cblas_sdsdot(int n, float alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sdsdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sdsdot", n, alpha, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dsdot$descriptor() {
        return cblas_dsdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dsdot$handle() {
        return cblas_dsdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dsdot$address() {
        return cblas_dsdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dsdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static double cblas_dsdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dsdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsdot", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sdot$descriptor() {
        return cblas_sdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sdot$handle() {
        return cblas_sdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sdot$address() {
        return cblas_sdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sdot(const blasint n, const float *x, const blasint incx, const float *y, const blasint incy)
     * }
     */
    public static float cblas_sdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sdot", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ddot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ddot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_ddot$descriptor() {
        return cblas_ddot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_ddot$handle() {
        return cblas_ddot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_ddot$address() {
        return cblas_ddot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_ddot(const blasint n, const double *x, const blasint incx, const double *y, const blasint incy)
     * }
     */
    public static double cblas_ddot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_ddot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ddot", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cdotu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cdotu$descriptor() {
        return cblas_cdotu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cdotu$handle() {
        return cblas_cdotu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cdotu$address() {
        return cblas_cdotu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static float cblas_cdotu(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cdotu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotu", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cdotc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cdotc$descriptor() {
        return cblas_cdotc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cdotc$handle() {
        return cblas_cdotc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cdotc$address() {
        return cblas_cdotc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_float cblas_cdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static float cblas_cdotc(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cdotc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotc", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zdotu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zdotu$descriptor() {
        return cblas_zdotu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zdotu$handle() {
        return cblas_zdotu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zdotu$address() {
        return cblas_zdotu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotu(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static double cblas_zdotu(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zdotu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotu", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zdotc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zdotc$descriptor() {
        return cblas_zdotc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zdotc$handle() {
        return cblas_zdotc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zdotc$address() {
        return cblas_zdotc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * openblas_complex_double cblas_zdotc(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy)
     * }
     */
    public static double cblas_zdotc(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zdotc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotc", n, x, incx, y, incy);
            }
            return (double)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotu_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cdotu_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_cdotu_sub$descriptor() {
        return cblas_cdotu_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_cdotu_sub$handle() {
        return cblas_cdotu_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_cdotu_sub$address() {
        return cblas_cdotu_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_cdotu_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_cdotu_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotu_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cdotc_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cdotc_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_cdotc_sub$descriptor() {
        return cblas_cdotc_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_cdotc_sub$handle() {
        return cblas_cdotc_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_cdotc_sub$address() {
        return cblas_cdotc_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_cdotc_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_cdotc_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cdotc_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotu_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zdotu_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_zdotu_sub$descriptor() {
        return cblas_zdotu_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_zdotu_sub$handle() {
        return cblas_zdotu_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_zdotu_sub$address() {
        return cblas_zdotu_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdotu_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_zdotu_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_zdotu_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotu_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdotc_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zdotc_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static FunctionDescriptor cblas_zdotc_sub$descriptor() {
        return cblas_zdotc_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MethodHandle cblas_zdotc_sub$handle() {
        return cblas_zdotc_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static MemorySegment cblas_zdotc_sub$address() {
        return cblas_zdotc_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdotc_sub(const blasint n, const void *x, const blasint incx, const void *y, const blasint incy, void *ret)
     * }
     */
    public static void cblas_zdotc_sub(int n, MemorySegment x, int incx, MemorySegment y, int incy, MemorySegment ret) {
        var mh$ = cblas_zdotc_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdotc_sub", n, x, incx, y, incy, ret);
            }
            mh$.invokeExact(n, x, incx, y, incy, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_sasum$descriptor() {
        return cblas_sasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_sasum$handle() {
        return cblas_sasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_sasum$address() {
        return cblas_sasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sasum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static float cblas_sasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_sasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sasum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dasum$descriptor() {
        return cblas_dasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dasum$handle() {
        return cblas_dasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dasum$address() {
        return cblas_dasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dasum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static double cblas_dasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dasum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_scasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_scasum$descriptor() {
        return cblas_scasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_scasum$handle() {
        return cblas_scasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_scasum$address() {
        return cblas_scasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static float cblas_scasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_scasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scasum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dzasum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dzasum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dzasum$descriptor() {
        return cblas_dzasum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dzasum$handle() {
        return cblas_dzasum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dzasum$address() {
        return cblas_dzasum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dzasum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static double cblas_dzasum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dzasum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dzasum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ssum$descriptor() {
        return cblas_ssum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ssum$handle() {
        return cblas_ssum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ssum$address() {
        return cblas_ssum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_ssum(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static float cblas_ssum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ssum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dsum$descriptor() {
        return cblas_dsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dsum$handle() {
        return cblas_dsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dsum$address() {
        return cblas_dsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dsum(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static double cblas_dsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_scsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_scsum$descriptor() {
        return cblas_scsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_scsum$handle() {
        return cblas_scsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_scsum$address() {
        return cblas_scsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static float cblas_scsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_scsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scsum", n, x, incx);
            }
            return (float)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dzsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dzsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_dzsum$descriptor() {
        return cblas_dzsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_dzsum$handle() {
        return cblas_dzsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_dzsum$address() {
        return cblas_dzsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dzsum(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static double cblas_dzsum(int n, MemorySegment x, int incx) {
        var mh$ = cblas_dzsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dzsum", n, x, incx);
            }
            return (double)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_snrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_snrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_snrm2$descriptor() {
        return cblas_snrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_snrm2$handle() {
        return cblas_snrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_snrm2$address() {
        return cblas_snrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_snrm2(const blasint N, const float *X, const blasint incX)
     * }
     */
    public static float cblas_snrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_snrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_snrm2", N, X, incX);
            }
            return (float)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dnrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dnrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dnrm2$descriptor() {
        return cblas_dnrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dnrm2$handle() {
        return cblas_dnrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dnrm2$address() {
        return cblas_dnrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dnrm2(const blasint N, const double *X, const blasint incX)
     * }
     */
    public static double cblas_dnrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_dnrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dnrm2", N, X, incX);
            }
            return (double)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scnrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_scnrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_scnrm2$descriptor() {
        return cblas_scnrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_scnrm2$handle() {
        return cblas_scnrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_scnrm2$address() {
        return cblas_scnrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_scnrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static float cblas_scnrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_scnrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scnrm2", N, X, incX);
            }
            return (float)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dznrm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_DOUBLE,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dznrm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dznrm2$descriptor() {
        return cblas_dznrm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dznrm2$handle() {
        return cblas_dznrm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dznrm2$address() {
        return cblas_dznrm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cblas_dznrm2(const blasint N, const void *X, const blasint incX)
     * }
     */
    public static double cblas_dznrm2(int N, MemorySegment X, int incX) {
        var mh$ = cblas_dznrm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dznrm2", N, X, incX);
            }
            return (double)mh$.invokeExact(N, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_isamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_isamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_isamax$descriptor() {
        return cblas_isamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_isamax$handle() {
        return cblas_isamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_isamax$address() {
        return cblas_isamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_isamax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_isamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_isamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_isamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_idamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idamax$descriptor() {
        return cblas_idamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idamax$handle() {
        return cblas_idamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idamax$address() {
        return cblas_idamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idamax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_icamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icamax$descriptor() {
        return cblas_icamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icamax$handle() {
        return cblas_icamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icamax$address() {
        return cblas_icamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izamax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_izamax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izamax$descriptor() {
        return cblas_izamax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izamax$handle() {
        return cblas_izamax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izamax$address() {
        return cblas_izamax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izamax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izamax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izamax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izamax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_isamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_isamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_isamin$descriptor() {
        return cblas_isamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_isamin$handle() {
        return cblas_isamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_isamin$address() {
        return cblas_isamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_isamin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_isamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_isamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_isamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_idamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idamin$descriptor() {
        return cblas_idamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idamin$handle() {
        return cblas_idamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idamin$address() {
        return cblas_idamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idamin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_icamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icamin$descriptor() {
        return cblas_icamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icamin$handle() {
        return cblas_icamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icamin$address() {
        return cblas_icamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izamin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_izamin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izamin$descriptor() {
        return cblas_izamin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izamin$handle() {
        return cblas_izamin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izamin$address() {
        return cblas_izamin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izamin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izamin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izamin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izamin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ismax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ismax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ismax$descriptor() {
        return cblas_ismax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ismax$handle() {
        return cblas_ismax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ismax$address() {
        return cblas_ismax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_ismax(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_ismax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ismax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ismax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_idmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idmax$descriptor() {
        return cblas_idmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idmax$handle() {
        return cblas_idmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idmax$address() {
        return cblas_idmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idmax(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_icmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icmax$descriptor() {
        return cblas_icmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icmax$handle() {
        return cblas_icmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icmax$address() {
        return cblas_icmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_izmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izmax$descriptor() {
        return cblas_izmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izmax$handle() {
        return cblas_izmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izmax$address() {
        return cblas_izmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izmax(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izmax(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izmax", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ismin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ismin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_ismin$descriptor() {
        return cblas_ismin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_ismin$handle() {
        return cblas_ismin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_ismin$address() {
        return cblas_ismin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_ismin(const blasint n, const float *x, const blasint incx)
     * }
     */
    public static long cblas_ismin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_ismin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ismin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_idmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_idmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_idmin$descriptor() {
        return cblas_idmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_idmin$handle() {
        return cblas_idmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_idmin$address() {
        return cblas_idmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_idmin(const blasint n, const double *x, const blasint incx)
     * }
     */
    public static long cblas_idmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_idmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_idmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_icmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_icmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_icmin$descriptor() {
        return cblas_icmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_icmin$handle() {
        return cblas_icmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_icmin$address() {
        return cblas_icmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_icmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_icmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_icmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_icmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_izmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_LONG,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_izmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static FunctionDescriptor cblas_izmin$descriptor() {
        return cblas_izmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MethodHandle cblas_izmin$handle() {
        return cblas_izmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static MemorySegment cblas_izmin$address() {
        return cblas_izmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t cblas_izmin(const blasint n, const void *x, const blasint incx)
     * }
     */
    public static long cblas_izmin(int n, MemorySegment x, int incx) {
        var mh$ = cblas_izmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_izmin", n, x, incx);
            }
            return (long)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_saxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_saxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_saxpy$descriptor() {
        return cblas_saxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_saxpy$handle() {
        return cblas_saxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_saxpy$address() {
        return cblas_saxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_saxpy(const blasint n, const float alpha, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_saxpy(int n, float alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_saxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_saxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_daxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_daxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_daxpy$descriptor() {
        return cblas_daxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_daxpy$handle() {
        return cblas_daxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_daxpy$address() {
        return cblas_daxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_daxpy(const blasint n, const double alpha, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_daxpy(int n, double alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_daxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_daxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_caxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_caxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_caxpy$descriptor() {
        return cblas_caxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_caxpy$handle() {
        return cblas_caxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_caxpy$address() {
        return cblas_caxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_caxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_caxpy(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_caxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_caxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zaxpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zaxpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zaxpy$descriptor() {
        return cblas_zaxpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zaxpy$handle() {
        return cblas_zaxpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zaxpy$address() {
        return cblas_zaxpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zaxpy(const blasint n, const void *alpha, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zaxpy(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zaxpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zaxpy", n, alpha, x, incx, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_scopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_scopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_scopy$descriptor() {
        return cblas_scopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_scopy$handle() {
        return cblas_scopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_scopy$address() {
        return cblas_scopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_scopy(const blasint n, const float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_scopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_scopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_scopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dcopy$descriptor() {
        return cblas_dcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dcopy$handle() {
        return cblas_dcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dcopy$address() {
        return cblas_dcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dcopy(const blasint n, const double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_dcopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dcopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ccopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ccopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_ccopy$descriptor() {
        return cblas_ccopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_ccopy$handle() {
        return cblas_ccopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_ccopy$address() {
        return cblas_ccopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ccopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_ccopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_ccopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ccopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zcopy$descriptor() {
        return cblas_zcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zcopy$handle() {
        return cblas_zcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zcopy$address() {
        return cblas_zcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zcopy(const blasint n, const void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zcopy(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zcopy", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sswap$descriptor() {
        return cblas_sswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sswap$handle() {
        return cblas_sswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sswap$address() {
        return cblas_sswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sswap(const blasint n, float *x, const blasint incx, float *y, const blasint incy)
     * }
     */
    public static void cblas_sswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dswap$descriptor() {
        return cblas_dswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dswap$handle() {
        return cblas_dswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dswap$address() {
        return cblas_dswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dswap(const blasint n, double *x, const blasint incx, double *y, const blasint incy)
     * }
     */
    public static void cblas_dswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_dswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cswap$descriptor() {
        return cblas_cswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cswap$handle() {
        return cblas_cswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cswap$address() {
        return cblas_cswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_cswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_cswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zswap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zswap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zswap$descriptor() {
        return cblas_zswap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zswap$handle() {
        return cblas_zswap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zswap$address() {
        return cblas_zswap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zswap(const blasint n, void *x, const blasint incx, void *y, const blasint incy)
     * }
     */
    public static void cblas_zswap(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_zswap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zswap", n, x, incx, y, incy);
            }
            mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_srot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static FunctionDescriptor cblas_srot$descriptor() {
        return cblas_srot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static MethodHandle cblas_srot$handle() {
        return cblas_srot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static MemorySegment cblas_srot$address() {
        return cblas_srot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srot(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float c, const float s)
     * }
     */
    public static void cblas_srot(int N, MemorySegment X, int incX, MemorySegment Y, int incY, float c, float s) {
        var mh$ = cblas_srot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srot", N, X, incX, Y, incY, c, s);
            }
            mh$.invokeExact(N, X, incX, Y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_drot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static FunctionDescriptor cblas_drot$descriptor() {
        return cblas_drot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static MethodHandle cblas_drot$handle() {
        return cblas_drot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static MemorySegment cblas_drot$address() {
        return cblas_drot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drot(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double c, const double s)
     * }
     */
    public static void cblas_drot(int N, MemorySegment X, int incX, MemorySegment Y, int incY, double c, double s) {
        var mh$ = cblas_drot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drot", N, X, incX, Y, incY, c, s);
            }
            mh$.invokeExact(N, X, incX, Y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csrot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_csrot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static FunctionDescriptor cblas_csrot$descriptor() {
        return cblas_csrot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static MethodHandle cblas_csrot$handle() {
        return cblas_csrot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static MemorySegment cblas_csrot$address() {
        return cblas_csrot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const float c, const float s)
     * }
     */
    public static void cblas_csrot(int n, MemorySegment x, int incx, MemorySegment y, int incY, float c, float s) {
        var mh$ = cblas_csrot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csrot", n, x, incx, y, incY, c, s);
            }
            mh$.invokeExact(n, x, incx, y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdrot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zdrot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static FunctionDescriptor cblas_zdrot$descriptor() {
        return cblas_zdrot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static MethodHandle cblas_zdrot$handle() {
        return cblas_zdrot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static MemorySegment cblas_zdrot$address() {
        return cblas_zdrot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdrot(const blasint n, const void *x, const blasint incx, void *y, const blasint incY, const double c, const double s)
     * }
     */
    public static void cblas_zdrot(int n, MemorySegment x, int incx, MemorySegment y, int incY, double c, double s) {
        var mh$ = cblas_zdrot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdrot", n, x, incx, y, incY, c, s);
            }
            mh$.invokeExact(n, x, incx, y, incY, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_srotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static FunctionDescriptor cblas_srotg$descriptor() {
        return cblas_srotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static MethodHandle cblas_srotg$handle() {
        return cblas_srotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static MemorySegment cblas_srotg$address() {
        return cblas_srotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotg(float *a, float *b, float *c, float *s)
     * }
     */
    public static void cblas_srotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_srotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_drotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static FunctionDescriptor cblas_drotg$descriptor() {
        return cblas_drotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static MethodHandle cblas_drotg$handle() {
        return cblas_drotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static MemorySegment cblas_drotg$address() {
        return cblas_drotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotg(double *a, double *b, double *c, double *s)
     * }
     */
    public static void cblas_drotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_drotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_crotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_crotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static FunctionDescriptor cblas_crotg$descriptor() {
        return cblas_crotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static MethodHandle cblas_crotg$handle() {
        return cblas_crotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static MemorySegment cblas_crotg$address() {
        return cblas_crotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_crotg(void *a, void *b, float *c, void *s)
     * }
     */
    public static void cblas_crotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_crotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_crotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zrotg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zrotg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static FunctionDescriptor cblas_zrotg$descriptor() {
        return cblas_zrotg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static MethodHandle cblas_zrotg$handle() {
        return cblas_zrotg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static MemorySegment cblas_zrotg$address() {
        return cblas_zrotg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zrotg(void *a, void *b, double *c, void *s)
     * }
     */
    public static void cblas_zrotg(MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment s) {
        var mh$ = cblas_zrotg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zrotg", a, b, c, s);
            }
            mh$.invokeExact(a, b, c, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_srotm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static FunctionDescriptor cblas_srotm$descriptor() {
        return cblas_srotm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static MethodHandle cblas_srotm$handle() {
        return cblas_srotm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static MemorySegment cblas_srotm$address() {
        return cblas_srotm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotm(const blasint N, float *X, const blasint incX, float *Y, const blasint incY, const float *P)
     * }
     */
    public static void cblas_srotm(int N, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment P) {
        var mh$ = cblas_srotm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotm", N, X, incX, Y, incY, P);
            }
            mh$.invokeExact(N, X, incX, Y, incY, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_drotm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static FunctionDescriptor cblas_drotm$descriptor() {
        return cblas_drotm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static MethodHandle cblas_drotm$handle() {
        return cblas_drotm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static MemorySegment cblas_drotm$address() {
        return cblas_drotm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotm(const blasint N, double *X, const blasint incX, double *Y, const blasint incY, const double *P)
     * }
     */
    public static void cblas_drotm(int N, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment P) {
        var mh$ = cblas_drotm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotm", N, X, incX, Y, incY, P);
            }
            mh$.invokeExact(N, X, incX, Y, incY, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_srotmg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_srotmg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static FunctionDescriptor cblas_srotmg$descriptor() {
        return cblas_srotmg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static MethodHandle cblas_srotmg$handle() {
        return cblas_srotmg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static MemorySegment cblas_srotmg$address() {
        return cblas_srotmg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P)
     * }
     */
    public static void cblas_srotmg(MemorySegment d1, MemorySegment d2, MemorySegment b1, float b2, MemorySegment P) {
        var mh$ = cblas_srotmg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_srotmg", d1, d2, b1, b2, P);
            }
            mh$.invokeExact(d1, d2, b1, b2, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_drotmg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_drotmg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static FunctionDescriptor cblas_drotmg$descriptor() {
        return cblas_drotmg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static MethodHandle cblas_drotmg$handle() {
        return cblas_drotmg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static MemorySegment cblas_drotmg$address() {
        return cblas_drotmg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P)
     * }
     */
    public static void cblas_drotmg(MemorySegment d1, MemorySegment d2, MemorySegment b1, double b2, MemorySegment P) {
        var mh$ = cblas_drotmg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_drotmg", d1, d2, b1, b2, P);
            }
            mh$.invokeExact(d1, d2, b1, b2, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_sscal$descriptor() {
        return cblas_sscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_sscal$handle() {
        return cblas_sscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_sscal$address() {
        return cblas_sscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sscal(const blasint N, const float alpha, float *X, const blasint incX)
     * }
     */
    public static void cblas_sscal(int N, float alpha, MemorySegment X, int incX) {
        var mh$ = cblas_sscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dscal$descriptor() {
        return cblas_dscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dscal$handle() {
        return cblas_dscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dscal$address() {
        return cblas_dscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dscal(const blasint N, const double alpha, double *X, const blasint incX)
     * }
     */
    public static void cblas_dscal(int N, double alpha, MemorySegment X, int incX) {
        var mh$ = cblas_dscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_cscal$descriptor() {
        return cblas_cscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_cscal$handle() {
        return cblas_cscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_cscal$address() {
        return cblas_cscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_cscal(int N, MemorySegment alpha, MemorySegment X, int incX) {
        var mh$ = cblas_cscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_zscal$descriptor() {
        return cblas_zscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_zscal$handle() {
        return cblas_zscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_zscal$address() {
        return cblas_zscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zscal(const blasint N, const void *alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_zscal(int N, MemorySegment alpha, MemorySegment X, int incX) {
        var mh$ = cblas_zscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_csscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_csscal$descriptor() {
        return cblas_csscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_csscal$handle() {
        return cblas_csscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_csscal$address() {
        return cblas_csscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csscal(const blasint N, const float alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_csscal(int N, float alpha, MemorySegment X, int incX) {
        var mh$ = cblas_csscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zdscal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zdscal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_zdscal$descriptor() {
        return cblas_zdscal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_zdscal$handle() {
        return cblas_zdscal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_zdscal$address() {
        return cblas_zdscal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zdscal(const blasint N, const double alpha, void *X, const blasint incX)
     * }
     */
    public static void cblas_zdscal(int N, double alpha, MemorySegment X, int incX) {
        var mh$ = cblas_zdscal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zdscal", N, alpha, X, incX);
            }
            mh$.invokeExact(N, alpha, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sgemv$descriptor() {
        return cblas_sgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sgemv$handle() {
        return cblas_sgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sgemv$address() {
        return cblas_sgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const float *a, const blasint lda, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_sgemv(int order, int trans, int m, int n, float alpha, MemorySegment a, int lda, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_sgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_dgemv$descriptor() {
        return cblas_dgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_dgemv$handle() {
        return cblas_dgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_dgemv$address() {
        return cblas_dgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const double alpha, const double *a, const blasint lda, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_dgemv(int order, int trans, int m, int n, double alpha, MemorySegment a, int lda, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_dgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_cgemv$descriptor() {
        return cblas_cgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_cgemv$handle() {
        return cblas_cgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_cgemv$address() {
        return cblas_cgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_cgemv(int order, int trans, int m, int n, MemorySegment alpha, MemorySegment a, int lda, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_cgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zgemv$descriptor() {
        return cblas_zgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zgemv$handle() {
        return cblas_zgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zgemv$address() {
        return cblas_zgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const void *alpha, const void *a, const blasint lda, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_zgemv(int order, int trans, int m, int n, MemorySegment alpha, MemorySegment a, int lda, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_zgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_sger$descriptor() {
        return cblas_sger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_sger$handle() {
        return cblas_sger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_sger$address() {
        return cblas_sger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static void cblas_sger(int order, int M, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_sger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sger", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dger$descriptor() {
        return cblas_dger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dger$handle() {
        return cblas_dger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dger$address() {
        return cblas_dger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dger(const enum CBLAS_ORDER order, const blasint M, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static void cblas_dger(int order, int M, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_dger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dger", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgeru {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgeru");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cgeru$descriptor() {
        return cblas_cgeru.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cgeru$handle() {
        return cblas_cgeru.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cgeru$address() {
        return cblas_cgeru.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cgeru(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cgeru.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgeru", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgerc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgerc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cgerc$descriptor() {
        return cblas_cgerc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cgerc$handle() {
        return cblas_cgerc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cgerc$address() {
        return cblas_cgerc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cgerc(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cgerc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgerc", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgeru {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgeru");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zgeru$descriptor() {
        return cblas_zgeru.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zgeru$handle() {
        return cblas_zgeru.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zgeru$address() {
        return cblas_zgeru.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgeru(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zgeru(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zgeru.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgeru", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgerc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgerc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zgerc$descriptor() {
        return cblas_zgerc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zgerc$handle() {
        return cblas_zgerc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zgerc$address() {
        return cblas_zgerc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgerc(const enum CBLAS_ORDER order, const blasint M, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zgerc(int order, int M, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zgerc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgerc", order, M, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, M, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_strsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_strsv$descriptor() {
        return cblas_strsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_strsv$handle() {
        return cblas_strsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_strsv$address() {
        return cblas_strsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_strsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_strsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtrsv$descriptor() {
        return cblas_dtrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtrsv$handle() {
        return cblas_dtrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtrsv$address() {
        return cblas_dtrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctrsv$descriptor() {
        return cblas_ctrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctrsv$handle() {
        return cblas_ctrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctrsv$address() {
        return cblas_ctrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztrsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztrsv$descriptor() {
        return cblas_ztrsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztrsv$handle() {
        return cblas_ztrsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztrsv$address() {
        return cblas_ztrsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztrsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztrsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrsv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_strmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_strmv$descriptor() {
        return cblas_strmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_strmv$handle() {
        return cblas_strmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_strmv$address() {
        return cblas_strmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_strmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_strmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtrmv$descriptor() {
        return cblas_dtrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtrmv$handle() {
        return cblas_dtrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtrmv$address() {
        return cblas_dtrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctrmv$descriptor() {
        return cblas_ctrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctrmv$handle() {
        return cblas_ctrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctrmv$address() {
        return cblas_ctrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztrmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztrmv$descriptor() {
        return cblas_ztrmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztrmv$handle() {
        return cblas_ztrmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztrmv$address() {
        return cblas_ztrmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztrmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztrmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrmv", order, Uplo, TransA, Diag, N, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_ssyr$descriptor() {
        return cblas_ssyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_ssyr$handle() {
        return cblas_ssyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_ssyr$address() {
        return cblas_ssyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *A, const blasint lda)
     * }
     */
    public static void cblas_ssyr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_ssyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dsyr$descriptor() {
        return cblas_dsyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dsyr$handle() {
        return cblas_dsyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dsyr$address() {
        return cblas_dsyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *A, const blasint lda)
     * }
     */
    public static void cblas_dsyr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_dsyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cher$descriptor() {
        return cblas_cher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cher$handle() {
        return cblas_cher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cher$address() {
        return cblas_cher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static void cblas_cher(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_cher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zher$descriptor() {
        return cblas_zher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zher$handle() {
        return cblas_zher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zher$address() {
        return cblas_zher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A, const blasint lda)
     * }
     */
    public static void cblas_zher(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A, int lda) {
        var mh$ = cblas_zher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher", order, Uplo, N, alpha, X, incX, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssyr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_ssyr2$descriptor() {
        return cblas_ssyr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_ssyr2$handle() {
        return cblas_ssyr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_ssyr2$address() {
        return cblas_ssyr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A, const blasint lda)
     * }
     */
    public static void cblas_ssyr2(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_ssyr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsyr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_dsyr2$descriptor() {
        return cblas_dsyr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_dsyr2$handle() {
        return cblas_dsyr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_dsyr2$address() {
        return cblas_dsyr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A, const blasint lda)
     * }
     */
    public static void cblas_dsyr2(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_dsyr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cher2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_cher2$descriptor() {
        return cblas_cher2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_cher2$handle() {
        return cblas_cher2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_cher2$address() {
        return cblas_cher2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_cher2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_cher2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zher2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static FunctionDescriptor cblas_zher2$descriptor() {
        return cblas_zher2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MethodHandle cblas_zher2$handle() {
        return cblas_zher2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static MemorySegment cblas_zher2$address() {
        return cblas_zher2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *A, const blasint lda)
     * }
     */
    public static void cblas_zher2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A, int lda) {
        var mh$ = cblas_zher2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher2", order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_sgbmv$descriptor() {
        return cblas_sgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_sgbmv$handle() {
        return cblas_sgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_sgbmv$address() {
        return cblas_sgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_sgbmv(int order, int TransA, int M, int N, int KL, int KU, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_sgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dgbmv$descriptor() {
        return cblas_dgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dgbmv$handle() {
        return cblas_dgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dgbmv$address() {
        return cblas_dgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dgbmv(int order, int TransA, int M, int N, int KL, int KU, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_cgbmv$descriptor() {
        return cblas_cgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_cgbmv$handle() {
        return cblas_cgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_cgbmv$address() {
        return cblas_cgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_cgbmv(int order, int TransA, int M, int N, int KL, int KU, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_cgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zgbmv$descriptor() {
        return cblas_zgbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zgbmv$handle() {
        return cblas_zgbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zgbmv$address() {
        return cblas_zgbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgbmv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA, const blasint M, const blasint N, const blasint KL, const blasint KU, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zgbmv(int order, int TransA, int M, int N, int KL, int KU, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zgbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgbmv", order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, TransA, M, N, KL, KU, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_ssbmv$descriptor() {
        return cblas_ssbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_ssbmv$handle() {
        return cblas_ssbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_ssbmv$address() {
        return cblas_ssbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_ssbmv(int order, int Uplo, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_ssbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dsbmv$descriptor() {
        return cblas_dsbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dsbmv$handle() {
        return cblas_dsbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dsbmv$address() {
        return cblas_dsbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dsbmv(int order, int Uplo, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dsbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_stbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stbmv$descriptor() {
        return cblas_stbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stbmv$handle() {
        return cblas_stbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stbmv$address() {
        return cblas_stbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_stbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_stbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtbmv$descriptor() {
        return cblas_dtbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtbmv$handle() {
        return cblas_dtbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtbmv$address() {
        return cblas_dtbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctbmv$descriptor() {
        return cblas_ctbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctbmv$handle() {
        return cblas_ctbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctbmv$address() {
        return cblas_ctbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztbmv$descriptor() {
        return cblas_ztbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztbmv$handle() {
        return cblas_ztbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztbmv$address() {
        return cblas_ztbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztbmv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztbmv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_stbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stbsv$descriptor() {
        return cblas_stbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stbsv$handle() {
        return cblas_stbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stbsv$address() {
        return cblas_stbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const float *A, const blasint lda, float *X, const blasint incX)
     * }
     */
    public static void cblas_stbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_stbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtbsv$descriptor() {
        return cblas_dtbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtbsv$handle() {
        return cblas_dtbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtbsv$address() {
        return cblas_dtbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const double *A, const blasint lda, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_dtbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctbsv$descriptor() {
        return cblas_ctbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctbsv$handle() {
        return cblas_ctbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctbsv$address() {
        return cblas_ctbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ctbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztbsv$descriptor() {
        return cblas_ztbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztbsv$handle() {
        return cblas_ztbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztbsv$address() {
        return cblas_ztbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const blasint K, const void *A, const blasint lda, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztbsv(int order, int Uplo, int TransA, int Diag, int N, int K, MemorySegment A, int lda, MemorySegment X, int incX) {
        var mh$ = cblas_ztbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztbsv", order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, K, A, lda, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_stpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stpmv$descriptor() {
        return cblas_stpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stpmv$handle() {
        return cblas_stpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stpmv$address() {
        return cblas_stpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static void cblas_stpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_stpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtpmv$descriptor() {
        return cblas_dtpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtpmv$handle() {
        return cblas_dtpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtpmv$address() {
        return cblas_dtpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_dtpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctpmv$descriptor() {
        return cblas_ctpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctpmv$handle() {
        return cblas_ctpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctpmv$address() {
        return cblas_ctpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ctpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztpmv$descriptor() {
        return cblas_ztpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztpmv$handle() {
        return cblas_ztpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztpmv$address() {
        return cblas_ztpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztpmv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ztpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztpmv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_stpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_stpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_stpsv$descriptor() {
        return cblas_stpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_stpsv$handle() {
        return cblas_stpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_stpsv$address() {
        return cblas_stpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const float *Ap, float *X, const blasint incX)
     * }
     */
    public static void cblas_stpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_stpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_stpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_dtpsv$descriptor() {
        return cblas_dtpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_dtpsv$handle() {
        return cblas_dtpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_dtpsv$address() {
        return cblas_dtpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const double *Ap, double *X, const blasint incX)
     * }
     */
    public static void cblas_dtpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_dtpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ctpsv$descriptor() {
        return cblas_ctpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ctpsv$handle() {
        return cblas_ctpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ctpsv$address() {
        return cblas_ctpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ctpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ctpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static FunctionDescriptor cblas_ztpsv$descriptor() {
        return cblas_ztpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MethodHandle cblas_ztpsv$handle() {
        return cblas_ztpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static MemorySegment cblas_ztpsv$address() {
        return cblas_ztpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint N, const void *Ap, void *X, const blasint incX)
     * }
     */
    public static void cblas_ztpsv(int order, int Uplo, int TransA, int Diag, int N, MemorySegment Ap, MemorySegment X, int incX) {
        var mh$ = cblas_ztpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztpsv", order, Uplo, TransA, Diag, N, Ap, X, incX);
            }
            mh$.invokeExact(order, Uplo, TransA, Diag, N, Ap, X, incX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssymv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssymv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_ssymv$descriptor() {
        return cblas_ssymv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_ssymv$handle() {
        return cblas_ssymv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_ssymv$address() {
        return cblas_ssymv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *A, const blasint lda, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_ssymv(int order, int Uplo, int N, float alpha, MemorySegment A, int lda, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_ssymv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssymv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsymv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsymv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dsymv$descriptor() {
        return cblas_dsymv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dsymv$handle() {
        return cblas_dsymv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dsymv$address() {
        return cblas_dsymv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *A, const blasint lda, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dsymv(int order, int Uplo, int N, double alpha, MemorySegment A, int lda, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dsymv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsymv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_chemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chemv$descriptor() {
        return cblas_chemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chemv$handle() {
        return cblas_chemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chemv$address() {
        return cblas_chemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chemv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chemv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zhemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhemv$descriptor() {
        return cblas_zhemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhemv$handle() {
        return cblas_zhemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhemv$address() {
        return cblas_zhemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhemv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhemv", order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sspmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_sspmv$descriptor() {
        return cblas_sspmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_sspmv$handle() {
        return cblas_sspmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_sspmv$address() {
        return cblas_sspmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *Ap, const float *X, const blasint incX, const float beta, float *Y, const blasint incY)
     * }
     */
    public static void cblas_sspmv(int order, int Uplo, int N, float alpha, MemorySegment Ap, MemorySegment X, int incX, float beta, MemorySegment Y, int incY) {
        var mh$ = cblas_sspmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dspmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_dspmv$descriptor() {
        return cblas_dspmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_dspmv$handle() {
        return cblas_dspmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_dspmv$address() {
        return cblas_dspmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *Ap, const double *X, const blasint incX, const double beta, double *Y, const blasint incY)
     * }
     */
    public static void cblas_dspmv(int order, int Uplo, int N, double alpha, MemorySegment Ap, MemorySegment X, int incX, double beta, MemorySegment Y, int incY) {
        var mh$ = cblas_dspmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sspr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static FunctionDescriptor cblas_sspr$descriptor() {
        return cblas_sspr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static MethodHandle cblas_sspr$handle() {
        return cblas_sspr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static MemorySegment cblas_sspr$address() {
        return cblas_sspr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, float *Ap)
     * }
     */
    public static void cblas_sspr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Ap) {
        var mh$ = cblas_sspr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspr", order, Uplo, N, alpha, X, incX, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dspr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static FunctionDescriptor cblas_dspr$descriptor() {
        return cblas_dspr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static MethodHandle cblas_dspr$handle() {
        return cblas_dspr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static MemorySegment cblas_dspr$address() {
        return cblas_dspr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, double *Ap)
     * }
     */
    public static void cblas_dspr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Ap) {
        var mh$ = cblas_dspr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspr", order, Uplo, N, alpha, X, incX, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_chpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static FunctionDescriptor cblas_chpr$descriptor() {
        return cblas_chpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MethodHandle cblas_chpr$handle() {
        return cblas_chpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MemorySegment cblas_chpr$address() {
        return cblas_chpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static void cblas_chpr(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment A) {
        var mh$ = cblas_chpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpr", order, Uplo, N, alpha, X, incX, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zhpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static FunctionDescriptor cblas_zhpr$descriptor() {
        return cblas_zhpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MethodHandle cblas_zhpr$handle() {
        return cblas_zhpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static MemorySegment cblas_zhpr$address() {
        return cblas_zhpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const void *X, const blasint incX, void *A)
     * }
     */
    public static void cblas_zhpr(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment A) {
        var mh$ = cblas_zhpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpr", order, Uplo, N, alpha, X, incX, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sspr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sspr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static FunctionDescriptor cblas_sspr2$descriptor() {
        return cblas_sspr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static MethodHandle cblas_sspr2$handle() {
        return cblas_sspr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static MemorySegment cblas_sspr2$address() {
        return cblas_sspr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const float alpha, const float *X, const blasint incX, const float *Y, const blasint incY, float *A)
     * }
     */
    public static void cblas_sspr2(int order, int Uplo, int N, float alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A) {
        var mh$ = cblas_sspr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sspr2", order, Uplo, N, alpha, X, incX, Y, incY, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dspr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dspr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static FunctionDescriptor cblas_dspr2$descriptor() {
        return cblas_dspr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static MethodHandle cblas_dspr2$handle() {
        return cblas_dspr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static MemorySegment cblas_dspr2$address() {
        return cblas_dspr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const double alpha, const double *X, const blasint incX, const double *Y, const blasint incY, double *A)
     * }
     */
    public static void cblas_dspr2(int order, int Uplo, int N, double alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment A) {
        var mh$ = cblas_dspr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dspr2", order, Uplo, N, alpha, X, incX, Y, incY, A);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_chpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static FunctionDescriptor cblas_chpr2$descriptor() {
        return cblas_chpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MethodHandle cblas_chpr2$handle() {
        return cblas_chpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MemorySegment cblas_chpr2$address() {
        return cblas_chpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static void cblas_chpr2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment Ap) {
        var mh$ = cblas_chpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpr2", order, Uplo, N, alpha, X, incX, Y, incY, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zhpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static FunctionDescriptor cblas_zhpr2$descriptor() {
        return cblas_zhpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MethodHandle cblas_zhpr2$handle() {
        return cblas_zhpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static MemorySegment cblas_zhpr2$address() {
        return cblas_zhpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *X, const blasint incX, const void *Y, const blasint incY, void *Ap)
     * }
     */
    public static void cblas_zhpr2(int order, int Uplo, int N, MemorySegment alpha, MemorySegment X, int incX, MemorySegment Y, int incY, MemorySegment Ap) {
        var mh$ = cblas_zhpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpr2", order, Uplo, N, alpha, X, incX, Y, incY, Ap);
            }
            mh$.invokeExact(order, Uplo, N, alpha, X, incX, Y, incY, Ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_chbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chbmv$descriptor() {
        return cblas_chbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chbmv$handle() {
        return cblas_chbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chbmv$address() {
        return cblas_chbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chbmv(int order, int Uplo, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhbmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zhbmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhbmv$descriptor() {
        return cblas_zhbmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhbmv$handle() {
        return cblas_zhbmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhbmv$address() {
        return cblas_zhbmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhbmv(int order, int Uplo, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhbmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhbmv", order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, K, alpha, A, lda, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_chpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_chpmv$descriptor() {
        return cblas_chpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_chpmv$handle() {
        return cblas_chpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_chpmv$address() {
        return cblas_chpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_chpmv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment Ap, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_chpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chpmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhpmv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zhpmv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static FunctionDescriptor cblas_zhpmv$descriptor() {
        return cblas_zhpmv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MethodHandle cblas_zhpmv$handle() {
        return cblas_zhpmv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static MemorySegment cblas_zhpmv$address() {
        return cblas_zhpmv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const blasint N, const void *alpha, const void *Ap, const void *X, const blasint incX, const void *beta, void *Y, const blasint incY)
     * }
     */
    public static void cblas_zhpmv(int order, int Uplo, int N, MemorySegment alpha, MemorySegment Ap, MemorySegment X, int incX, MemorySegment beta, MemorySegment Y, int incY) {
        var mh$ = cblas_zhpmv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhpmv", order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
            }
            mh$.invokeExact(order, Uplo, N, alpha, Ap, X, incX, beta, Y, incY);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_sgemm$descriptor() {
        return cblas_sgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_sgemm$handle() {
        return cblas_sgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_sgemm$address() {
        return cblas_sgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_sgemm(int Order, int TransA, int TransB, int M, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_sgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dgemm$descriptor() {
        return cblas_dgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dgemm$handle() {
        return cblas_dgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dgemm$address() {
        return cblas_dgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dgemm(int Order, int TransA, int TransB, int M, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cgemm$descriptor() {
        return cblas_cgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cgemm$handle() {
        return cblas_cgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cgemm$address() {
        return cblas_cgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cgemm(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgemm3m {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgemm3m");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cgemm3m$descriptor() {
        return cblas_cgemm3m.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cgemm3m$handle() {
        return cblas_cgemm3m.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cgemm3m$address() {
        return cblas_cgemm3m.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cgemm3m(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cgemm3m.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgemm3m", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zgemm$descriptor() {
        return cblas_zgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zgemm$handle() {
        return cblas_zgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zgemm$address() {
        return cblas_zgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zgemm(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgemm3m {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgemm3m");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zgemm3m$descriptor() {
        return cblas_zgemm3m.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zgemm3m$handle() {
        return cblas_zgemm3m.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zgemm3m$address() {
        return cblas_zgemm3m.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgemm3m(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zgemm3m(int Order, int TransA, int TransB, int M, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zgemm3m.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgemm3m", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssymm$descriptor() {
        return cblas_ssymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssymm$handle() {
        return cblas_ssymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssymm$address() {
        return cblas_ssymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssymm(int Order, int Side, int Uplo, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsymm$descriptor() {
        return cblas_dsymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsymm$handle() {
        return cblas_dsymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsymm$address() {
        return cblas_dsymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsymm(int Order, int Side, int Uplo, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_csymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csymm$descriptor() {
        return cblas_csymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csymm$handle() {
        return cblas_csymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csymm$address() {
        return cblas_csymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csymm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsymm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zsymm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsymm$descriptor() {
        return cblas_zsymm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsymm$handle() {
        return cblas_zsymm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsymm$address() {
        return cblas_zsymm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsymm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsymm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsymm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssyrk$descriptor() {
        return cblas_ssyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssyrk$handle() {
        return cblas_ssyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssyrk$address() {
        return cblas_ssyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssyrk(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsyrk$descriptor() {
        return cblas_dsyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsyrk$handle() {
        return cblas_dsyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsyrk$address() {
        return cblas_dsyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsyrk(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_csyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csyrk$descriptor() {
        return cblas_csyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csyrk$handle() {
        return cblas_csyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csyrk$address() {
        return cblas_csyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csyrk(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsyrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zsyrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsyrk$descriptor() {
        return cblas_zsyrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsyrk$handle() {
        return cblas_zsyrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsyrk$address() {
        return cblas_zsyrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsyrk(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsyrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsyrk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ssyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ssyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_ssyr2k$descriptor() {
        return cblas_ssyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_ssyr2k$handle() {
        return cblas_ssyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_ssyr2k$address() {
        return cblas_ssyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const float *A, const blasint lda, const float *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_ssyr2k(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_ssyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ssyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dsyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dsyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_dsyr2k$descriptor() {
        return cblas_dsyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_dsyr2k$handle() {
        return cblas_dsyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_dsyr2k$address() {
        return cblas_dsyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const double *A, const blasint lda, const double *B, const blasint ldb, const double beta, double *C, const blasint ldc)
     * }
     */
    public static void cblas_dsyr2k(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_dsyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dsyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_csyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_csyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_csyr2k$descriptor() {
        return cblas_csyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_csyr2k$handle() {
        return cblas_csyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_csyr2k$address() {
        return cblas_csyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_csyr2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_csyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_csyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zsyr2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zsyr2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zsyr2k$descriptor() {
        return cblas_zsyr2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zsyr2k$handle() {
        return cblas_zsyr2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zsyr2k$address() {
        return cblas_zsyr2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zsyr2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zsyr2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zsyr2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_strmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_strmm$descriptor() {
        return cblas_strmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_strmm$handle() {
        return cblas_strmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_strmm$address() {
        return cblas_strmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static void cblas_strmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_strmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_dtrmm$descriptor() {
        return cblas_dtrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_dtrmm$handle() {
        return cblas_dtrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_dtrmm$address() {
        return cblas_dtrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static void cblas_dtrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_dtrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ctrmm$descriptor() {
        return cblas_ctrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ctrmm$handle() {
        return cblas_ctrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ctrmm$address() {
        return cblas_ctrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ctrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ctrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrmm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztrmm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ztrmm$descriptor() {
        return cblas_ztrmm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ztrmm$handle() {
        return cblas_ztrmm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ztrmm$address() {
        return cblas_ztrmm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ztrmm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ztrmm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrmm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_strsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_strsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_strsm$descriptor() {
        return cblas_strsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_strsm$handle() {
        return cblas_strsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_strsm$address() {
        return cblas_strsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const float alpha, const float *A, const blasint lda, float *B, const blasint ldb)
     * }
     */
    public static void cblas_strsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_strsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_strsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dtrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dtrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_dtrsm$descriptor() {
        return cblas_dtrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_dtrsm$handle() {
        return cblas_dtrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_dtrsm$address() {
        return cblas_dtrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const double alpha, const double *A, const blasint lda, double *B, const blasint ldb)
     * }
     */
    public static void cblas_dtrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, double alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_dtrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dtrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ctrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ctrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ctrsm$descriptor() {
        return cblas_ctrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ctrsm$handle() {
        return cblas_ctrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ctrsm$address() {
        return cblas_ctrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ctrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ctrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ctrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_ztrsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_ztrsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static FunctionDescriptor cblas_ztrsm$descriptor() {
        return cblas_ztrsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MethodHandle cblas_ztrsm$handle() {
        return cblas_ztrsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static MemorySegment cblas_ztrsm$address() {
        return cblas_ztrsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, void *B, const blasint ldb)
     * }
     */
    public static void cblas_ztrsm(int Order, int Side, int Uplo, int TransA, int Diag, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb) {
        var mh$ = cblas_ztrsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_ztrsm", Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
            }
            mh$.invokeExact(Order, Side, Uplo, TransA, Diag, M, N, alpha, A, lda, B, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_chemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_chemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_chemm$descriptor() {
        return cblas_chemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_chemm$handle() {
        return cblas_chemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_chemm$address() {
        return cblas_chemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_chemm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_chemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_chemm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zhemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zhemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zhemm$descriptor() {
        return cblas_zhemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zhemm$handle() {
        return cblas_zhemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zhemm$address() {
        return cblas_zhemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side, const enum CBLAS_UPLO Uplo, const blasint M, const blasint N, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const void *beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zhemm(int Order, int Side, int Uplo, int M, int N, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, MemorySegment beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zhemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zhemm", Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Side, Uplo, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cherk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cherk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cherk$descriptor() {
        return cblas_cherk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cherk$handle() {
        return cblas_cherk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cherk$address() {
        return cblas_cherk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const float alpha, const void *A, const blasint lda, const float beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cherk(int Order, int Uplo, int Trans, int N, int K, float alpha, MemorySegment A, int lda, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cherk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cherk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zherk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zherk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zherk$descriptor() {
        return cblas_zherk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zherk$handle() {
        return cblas_zherk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zherk$address() {
        return cblas_zherk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const double alpha, const void *A, const blasint lda, const double beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zherk(int Order, int Uplo, int Trans, int N, int K, double alpha, MemorySegment A, int lda, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zherk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zherk", Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cher2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cher2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_cher2k$descriptor() {
        return cblas_cher2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_cher2k$handle() {
        return cblas_cher2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_cher2k$address() {
        return cblas_cher2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const float beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_cher2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_cher2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cher2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zher2k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zher2k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_zher2k$descriptor() {
        return cblas_zher2k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_zher2k$handle() {
        return cblas_zher2k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_zher2k$address() {
        return cblas_zher2k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE Trans, const blasint N, const blasint K, const void *alpha, const void *A, const blasint lda, const void *B, const blasint ldb, const double beta, void *C, const blasint ldc)
     * }
     */
    public static void cblas_zher2k(int Order, int Uplo, int Trans, int N, int K, MemorySegment alpha, MemorySegment A, int lda, MemorySegment B, int ldb, double beta, MemorySegment C, int ldc) {
        var mh$ = cblas_zher2k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zher2k", Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, Uplo, Trans, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void cblas_xerbla(blasint p, char *rout, char *form, ...)
     * }
     */
    public static class cblas_xerbla {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                cblas_h.C_INT,
                cblas_h.C_POINTER,
                cblas_h.C_POINTER
            );
        private static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_xerbla");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private cblas_xerbla(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void cblas_xerbla(blasint p, char *rout, char *form, ...)
         * }
         */
        public static cblas_xerbla makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            Linker.Option critical$ = Linker.Option.critical(true);
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$, critical$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new cblas_xerbla(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(int p, MemorySegment rout, MemorySegment form, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("cblas_xerbla", p, rout, form, x3);
                }
                 spreader.invokeExact(p, rout, form, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class cblas_saxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_saxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_saxpby$descriptor() {
        return cblas_saxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_saxpby$handle() {
        return cblas_saxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_saxpby$address() {
        return cblas_saxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_saxpby(const blasint n, const float alpha, const float *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_saxpby(int n, float alpha, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_saxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_saxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_daxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_daxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_daxpby$descriptor() {
        return cblas_daxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_daxpby$handle() {
        return cblas_daxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_daxpby$address() {
        return cblas_daxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_daxpby(const blasint n, const double alpha, const double *x, const blasint incx, const double beta, double *y, const blasint incy)
     * }
     */
    public static void cblas_daxpby(int n, double alpha, MemorySegment x, int incx, double beta, MemorySegment y, int incy) {
        var mh$ = cblas_daxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_daxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_caxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_caxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_caxpby$descriptor() {
        return cblas_caxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_caxpby$handle() {
        return cblas_caxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_caxpby$address() {
        return cblas_caxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_caxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_caxpby(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_caxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_caxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zaxpby {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zaxpby");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_zaxpby$descriptor() {
        return cblas_zaxpby.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_zaxpby$handle() {
        return cblas_zaxpby.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_zaxpby$address() {
        return cblas_zaxpby.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zaxpby(const blasint n, const void *alpha, const void *x, const blasint incx, const void *beta, void *y, const blasint incy)
     * }
     */
    public static void cblas_zaxpby(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment beta, MemorySegment y, int incy) {
        var mh$ = cblas_zaxpby.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zaxpby", n, alpha, x, incx, beta, y, incy);
            }
            mh$.invokeExact(n, alpha, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_somatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_somatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_somatcopy$descriptor() {
        return cblas_somatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_somatcopy$handle() {
        return cblas_somatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_somatcopy$address() {
        return cblas_somatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_somatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static void cblas_somatcopy(int CORDER, int CTRANS, int crows, int ccols, float calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_somatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_somatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_domatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_domatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_domatcopy$descriptor() {
        return cblas_domatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_domatcopy$handle() {
        return cblas_domatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_domatcopy$address() {
        return cblas_domatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_domatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static void cblas_domatcopy(int CORDER, int CTRANS, int crows, int ccols, double calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_domatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_domatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_comatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_comatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_comatcopy$descriptor() {
        return cblas_comatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_comatcopy$handle() {
        return cblas_comatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_comatcopy$address() {
        return cblas_comatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_comatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, const float *a, const blasint clda, float *b, const blasint cldb)
     * }
     */
    public static void cblas_comatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_comatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_comatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zomatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zomatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_zomatcopy$descriptor() {
        return cblas_zomatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_zomatcopy$handle() {
        return cblas_zomatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_zomatcopy$address() {
        return cblas_zomatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zomatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, const double *a, const blasint clda, double *b, const blasint cldb)
     * }
     */
    public static void cblas_zomatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment b, int cldb) {
        var mh$ = cblas_zomatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zomatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, b, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_simatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_simatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_simatcopy$descriptor() {
        return cblas_simatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_simatcopy$handle() {
        return cblas_simatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_simatcopy$address() {
        return cblas_simatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_simatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_simatcopy(int CORDER, int CTRANS, int crows, int ccols, float calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_simatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_simatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_dimatcopy$descriptor() {
        return cblas_dimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_dimatcopy$handle() {
        return cblas_dimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_dimatcopy$address() {
        return cblas_dimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_dimatcopy(int CORDER, int CTRANS, int crows, int ccols, double calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_dimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_cimatcopy$descriptor() {
        return cblas_cimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_cimatcopy$handle() {
        return cblas_cimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_cimatcopy$address() {
        return cblas_cimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_cimatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_cimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zimatcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zimatcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static FunctionDescriptor cblas_zimatcopy$descriptor() {
        return cblas_zimatcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MethodHandle cblas_zimatcopy$handle() {
        return cblas_zimatcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static MemorySegment cblas_zimatcopy$address() {
        return cblas_zimatcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zimatcopy(const enum CBLAS_ORDER CORDER, const enum CBLAS_TRANSPOSE CTRANS, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const blasint cldb)
     * }
     */
    public static void cblas_zimatcopy(int CORDER, int CTRANS, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, int cldb) {
        var mh$ = cblas_zimatcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zimatcopy", CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
            }
            mh$.invokeExact(CORDER, CTRANS, crows, ccols, calpha, a, clda, cldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_sgeadd$descriptor() {
        return cblas_sgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_sgeadd$handle() {
        return cblas_sgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_sgeadd$address() {
        return cblas_sgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float calpha, float *a, const blasint clda, const float cbeta, float *c, const blasint cldc)
     * }
     */
    public static void cblas_sgeadd(int CORDER, int crows, int ccols, float calpha, MemorySegment a, int clda, float cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_sgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_DOUBLE,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_dgeadd$descriptor() {
        return cblas_dgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_dgeadd$handle() {
        return cblas_dgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_dgeadd$address() {
        return cblas_dgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double calpha, double *a, const blasint clda, const double cbeta, double *c, const blasint cldc)
     * }
     */
    public static void cblas_dgeadd(int CORDER, int crows, int ccols, double calpha, MemorySegment a, int clda, double cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_dgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_cgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_cgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_cgeadd$descriptor() {
        return cblas_cgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_cgeadd$handle() {
        return cblas_cgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_cgeadd$address() {
        return cblas_cgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_cgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const float *calpha, float *a, const blasint clda, const float *cbeta, float *c, const blasint cldc)
     * }
     */
    public static void cblas_cgeadd(int CORDER, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_cgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_cgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_zgeadd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_zgeadd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static FunctionDescriptor cblas_zgeadd$descriptor() {
        return cblas_zgeadd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static MethodHandle cblas_zgeadd$handle() {
        return cblas_zgeadd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static MemorySegment cblas_zgeadd$address() {
        return cblas_zgeadd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_zgeadd(const enum CBLAS_ORDER CORDER, const blasint crows, const blasint ccols, const double *calpha, double *a, const blasint clda, const double *cbeta, double *c, const blasint cldc)
     * }
     */
    public static void cblas_zgeadd(int CORDER, int crows, int ccols, MemorySegment calpha, MemorySegment a, int clda, MemorySegment cbeta, MemorySegment c, int cldc) {
        var mh$ = cblas_zgeadd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_zgeadd", CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
            }
            mh$.invokeExact(CORDER, crows, ccols, calpha, a, clda, cbeta, c, cldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbstobf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sbstobf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbstobf16$descriptor() {
        return cblas_sbstobf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbstobf16$handle() {
        return cblas_sbstobf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbstobf16$address() {
        return cblas_sbstobf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbstobf16(const blasint n, const float *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static void cblas_sbstobf16(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbstobf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbstobf16", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbdtobf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sbdtobf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbdtobf16$descriptor() {
        return cblas_sbdtobf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbdtobf16$handle() {
        return cblas_sbdtobf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbdtobf16$address() {
        return cblas_sbdtobf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbdtobf16(const blasint n, const double *in, const blasint incin, bfloat16 *out, const blasint incout)
     * }
     */
    public static void cblas_sbdtobf16(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbdtobf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbdtobf16", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbf16tos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sbf16tos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_sbf16tos$descriptor() {
        return cblas_sbf16tos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_sbf16tos$handle() {
        return cblas_sbf16tos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_sbf16tos$address() {
        return cblas_sbf16tos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbf16tos(const blasint n, const bfloat16 *in, const blasint incin, float *out, const blasint incout)
     * }
     */
    public static void cblas_sbf16tos(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_sbf16tos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbf16tos", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_dbf16tod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_dbf16tod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static FunctionDescriptor cblas_dbf16tod$descriptor() {
        return cblas_dbf16tod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static MethodHandle cblas_dbf16tod$handle() {
        return cblas_dbf16tod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static MemorySegment cblas_dbf16tod$address() {
        return cblas_dbf16tod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_dbf16tod(const blasint n, const bfloat16 *in, const blasint incin, double *out, const blasint incout)
     * }
     */
    public static void cblas_dbf16tod(int n, MemorySegment in, int incin, MemorySegment out, int incout) {
        var mh$ = cblas_dbf16tod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_dbf16tod", n, in, incin, out, incout);
            }
            mh$.invokeExact(n, in, incin, out, incout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbdot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_h.C_FLOAT,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sbdot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sbdot$descriptor() {
        return cblas_sbdot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sbdot$handle() {
        return cblas_sbdot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sbdot$address() {
        return cblas_sbdot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cblas_sbdot(const blasint n, const bfloat16 *x, const blasint incx, const bfloat16 *y, const blasint incy)
     * }
     */
    public static float cblas_sbdot(int n, MemorySegment x, int incx, MemorySegment y, int incy) {
        var mh$ = cblas_sbdot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbdot", n, x, incx, y, incy);
            }
            return (float)mh$.invokeExact(n, x, incx, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbgemv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sbgemv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static FunctionDescriptor cblas_sbgemv$descriptor() {
        return cblas_sbgemv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MethodHandle cblas_sbgemv$handle() {
        return cblas_sbgemv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static MemorySegment cblas_sbgemv$address() {
        return cblas_sbgemv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbgemv(const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE trans, const blasint m, const blasint n, const float alpha, const bfloat16 *a, const blasint lda, const bfloat16 *x, const blasint incx, const float beta, float *y, const blasint incy)
     * }
     */
    public static void cblas_sbgemv(int order, int trans, int m, int n, float alpha, MemorySegment a, int lda, MemorySegment x, int incx, float beta, MemorySegment y, int incy) {
        var mh$ = cblas_sbgemv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbgemv", order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
            }
            mh$.invokeExact(order, trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cblas_sbgemm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_POINTER,
            cblas_h.C_INT,
            cblas_h.C_FLOAT,
            cblas_h.C_POINTER,
            cblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_h.findOrThrow("cblas_sbgemm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static FunctionDescriptor cblas_sbgemm$descriptor() {
        return cblas_sbgemm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MethodHandle cblas_sbgemm$handle() {
        return cblas_sbgemm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static MemorySegment cblas_sbgemm$address() {
        return cblas_sbgemm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cblas_sbgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB, const blasint M, const blasint N, const blasint K, const float alpha, const bfloat16 *A, const blasint lda, const bfloat16 *B, const blasint ldb, const float beta, float *C, const blasint ldc)
     * }
     */
    public static void cblas_sbgemm(int Order, int TransA, int TransB, int M, int N, int K, float alpha, MemorySegment A, int lda, MemorySegment B, int ldb, float beta, MemorySegment C, int ldc) {
        var mh$ = cblas_sbgemm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cblas_sbgemm", Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
            }
            mh$.invokeExact(Order, TransA, TransB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_CHAR_CORENAME "generic"
     * }
     */
    public static MemorySegment OPENBLAS_CHAR_CORENAME() {
        class Holder {
            static final MemorySegment OPENBLAS_CHAR_CORENAME
                = cblas_h.LIBRARY_ARENA.allocateFrom("generic");
        }
        return Holder.OPENBLAS_CHAR_CORENAME;
    }
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_VERSION " OpenBLAS 0.3.20 "
     * }
     */
    public static MemorySegment OPENBLAS_VERSION() {
        class Holder {
            static final MemorySegment OPENBLAS_VERSION
                = cblas_h.LIBRARY_ARENA.allocateFrom(" OpenBLAS 0.3.20 ");
        }
        return Holder.OPENBLAS_VERSION;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = cblas_h.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final float _Complex_I = 0f;
    /**
     * {@snippet lang=c :
     * #define _Complex_I 0
     * }
     */
    public static float _Complex_I() {
        return _Complex_I;
    }
    private static final float I = 0f;
    /**
     * {@snippet lang=c :
     * #define I 0
     * }
     */
    public static float I() {
        return I;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final long __NCPUBITS = 64L;
    /**
     * {@snippet lang=c :
     * #define __NCPUBITS 64
     * }
     */
    public static long __NCPUBITS() {
        return __NCPUBITS;
    }
}

