// Generated by jextract

package smile.linalg.lapack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class clapack_h extends clapack_h_1 {

    clapack_h() {
        // Should not be called directly
    }

    private static class spftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spftri_$descriptor() {
        return spftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spftri_$handle() {
        return spftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spftri_$address() {
        return spftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static int spftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = spftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftri_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spftrs_$descriptor() {
        return spftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spftrs_$handle() {
        return spftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spftrs_$address() {
        return spftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int spftrs_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = spftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftrs_", __transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spocon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spocon_$descriptor() {
        return spocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spocon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spocon_$handle() {
        return spocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spocon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spocon_$address() {
        return spocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spocon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int spocon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = spocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spocon_", __uplo, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spoequ_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spoequ_$descriptor() {
        return spoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spoequ_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spoequ_$handle() {
        return spoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spoequ_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spoequ_$address() {
        return spoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spoequ_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int spoequ_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = spoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spoequ_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spoequb_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spoequb_$descriptor() {
        return spoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spoequb_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spoequb_$handle() {
        return spoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spoequb_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spoequb_$address() {
        return spoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spoequb_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int spoequb_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = spoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spoequb_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sporfs_$descriptor() {
        return sporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sporfs_$handle() {
        return sporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sporfs_$address() {
        return sporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sporfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sporfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sposv_$descriptor() {
        return sposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sposv_$handle() {
        return sposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sposv_$address() {
        return sposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sposv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposv_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sposvx_$descriptor() {
        return sposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sposvx_$handle() {
        return sposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sposvx_$address() {
        return sposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sposvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spotf2_$descriptor() {
        return spotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spotf2_$handle() {
        return spotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spotf2_$address() {
        return spotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int spotf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = spotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotf2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spotrf_$descriptor() {
        return spotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spotrf_$handle() {
        return spotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spotrf_$address() {
        return spotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int spotrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = spotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrf_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spotri_$descriptor() {
        return spotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spotri_$handle() {
        return spotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spotri_$address() {
        return spotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int spotri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = spotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotri_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spotrs_$descriptor() {
        return spotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spotrs_$handle() {
        return spotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spotrs_$address() {
        return spotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int spotrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = spotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrs_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sppcon_$descriptor() {
        return sppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sppcon_$handle() {
        return sppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sppcon_$address() {
        return sppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sppcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppcon_", __uplo, __n, __ap, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sppequ_$descriptor() {
        return sppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sppequ_$handle() {
        return sppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sppequ_$address() {
        return sppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int sppequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = sppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppequ_", __uplo, __n, __ap, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spprfs_$descriptor() {
        return spprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spprfs_$handle() {
        return spprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spprfs_$address() {
        return spprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int spprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = spprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spprfs_", __uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sppsv_$descriptor() {
        return sppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sppsv_$handle() {
        return sppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sppsv_$address() {
        return sppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sppsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppsv_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sppsvx_$descriptor() {
        return sppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sppsvx_$handle() {
        return sppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sppsvx_$address() {
        return sppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sppsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spptrf_$descriptor() {
        return spptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spptrf_$handle() {
        return spptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spptrf_$address() {
        return spptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static int spptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = spptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptrf_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spptri_$descriptor() {
        return spptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spptri_$handle() {
        return spptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spptri_$address() {
        return spptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static int spptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = spptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptri_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spptrs_$descriptor() {
        return spptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spptrs_$handle() {
        return spptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spptrs_$address() {
        return spptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int spptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = spptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptrs_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spstf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spstf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spstf2_$descriptor() {
        return spstf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spstf2_$handle() {
        return spstf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spstf2_$address() {
        return spstf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int spstf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = spstf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spstf2_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spstrf_$descriptor() {
        return spstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spstrf_$handle() {
        return spstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spstrf_$address() {
        return spstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int spstrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = spstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spstrf_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sptcon_$descriptor() {
        return sptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sptcon_$handle() {
        return sptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sptcon_$address() {
        return sptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sptcon_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = sptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptcon_", __n, __d__, __e, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spteqr_$descriptor() {
        return spteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spteqr_$handle() {
        return spteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spteqr_$address() {
        return spteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int spteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = spteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sptrfs_$descriptor() {
        return sptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sptrfs_$handle() {
        return sptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sptrfs_$address() {
        return sptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sptrfs_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __info) {
        var mh$ = sptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptrfs_", __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sptsv_$descriptor() {
        return sptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sptsv_$handle() {
        return sptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sptsv_$address() {
        return sptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sptsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptsv_", __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sptsvx_$descriptor() {
        return sptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sptsvx_$handle() {
        return sptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sptsvx_$address() {
        return sptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__df, __CLPK_real *__ef, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sptsvx_(MemorySegment __fact, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __info) {
        var mh$ = sptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptsvx_", __fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __info);
            }
            return (int)mh$.invokeExact(__fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spttrf_$descriptor() {
        return spttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spttrf_$handle() {
        return spttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spttrf_$address() {
        return spttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static int spttrf_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = spttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spttrf_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spttrs_$descriptor() {
        return spttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spttrs_$handle() {
        return spttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spttrs_$address() {
        return spttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int spttrs_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = spttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spttrs_", __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sptts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor sptts2_$descriptor() {
        return sptts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle sptts2_$handle() {
        return sptts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment sptts2_$address() {
        return sptts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int sptts2_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = sptts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptts2_", __n, __nrhs, __d__, __e, __b, __ldb);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srscl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("srscl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int srscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_real *__sx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor srscl_$descriptor() {
        return srscl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int srscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_real *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle srscl_$handle() {
        return srscl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int srscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_real *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment srscl_$address() {
        return srscl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int srscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_real *__sx, __CLPK_integer *__incx)
     * }
     */
    public static int srscl_(MemorySegment __n, MemorySegment __sa, MemorySegment __sx, MemorySegment __incx) {
        var mh$ = srscl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srscl_", __n, __sa, __sx, __incx);
            }
            return (int)mh$.invokeExact(__n, __sa, __sx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbev_$descriptor() {
        return ssbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbev_$handle() {
        return ssbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbev_$address() {
        return ssbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssbev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbev_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbevd_$descriptor() {
        return ssbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbevd_$handle() {
        return ssbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbevd_$address() {
        return ssbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ssbevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ssbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevd_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbevx_$descriptor() {
        return ssbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbevx_$handle() {
        return ssbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbevx_$address() {
        return ssbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int ssbevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = ssbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevx_", __jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbgst_$descriptor() {
        return ssbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbgst_$handle() {
        return ssbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbgst_$address() {
        return ssbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssbgst_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgst_", __vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbgv_$descriptor() {
        return ssbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbgv_$handle() {
        return ssbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbgv_$address() {
        return ssbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssbgv_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgv_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbgvd_$descriptor() {
        return ssbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbgvd_$handle() {
        return ssbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbgvd_$address() {
        return ssbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ssbgvd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ssbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgvd_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbgvx_$descriptor() {
        return ssbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbgvx_$handle() {
        return ssbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbgvx_$address() {
        return ssbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__bb, __CLPK_integer *__ldbb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int ssbgvx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = ssbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgvx_", __jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssbtrd_$descriptor() {
        return ssbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssbtrd_$handle() {
        return ssbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssbtrd_$address() {
        return ssbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssbtrd_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbtrd_", __vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_real *__c__)
     * }
     */
    public static FunctionDescriptor ssfrk_$descriptor() {
        return ssfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_real *__c__)
     * }
     */
    public static MethodHandle ssfrk_$handle() {
        return ssfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_real *__c__)
     * }
     */
    public static MemorySegment ssfrk_$address() {
        return ssfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_real *__c__)
     * }
     */
    public static int ssfrk_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __trans, MemorySegment __n, MemorySegment __k, MemorySegment __alpha, MemorySegment __a, MemorySegment __lda, MemorySegment __beta, MemorySegment __c__) {
        var mh$ = ssfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssfrk_", __transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspcon_$descriptor() {
        return sspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspcon_$handle() {
        return sspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspcon_$address() {
        return sspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sspcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspcon_", __uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspev_$descriptor() {
        return sspev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspev_$handle() {
        return sspev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspev_$address() {
        return sspev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sspev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = sspev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspev_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspevd_$descriptor() {
        return sspevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspevd_$handle() {
        return sspevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspevd_$address() {
        return sspevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sspevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sspevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspevd_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspevx_$descriptor() {
        return sspevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspevx_$handle() {
        return sspevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspevx_$address() {
        return sspevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int sspevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = sspevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspevx_", __jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspgst_$descriptor() {
        return sspgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspgst_$handle() {
        return sspgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspgst_$address() {
        return sspgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_integer *__info)
     * }
     */
    public static int sspgst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __info) {
        var mh$ = sspgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgst_", __itype, __uplo, __n, __ap, __bp, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __ap, __bp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspgv_$descriptor() {
        return sspgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspgv_$handle() {
        return sspgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspgv_$address() {
        return sspgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sspgv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = sspgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgv_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspgvd_$descriptor() {
        return sspgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspgvd_$handle() {
        return sspgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspgvd_$address() {
        return sspgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sspgvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sspgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgvd_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspgvx_$descriptor() {
        return sspgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspgvx_$handle() {
        return sspgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspgvx_$address() {
        return sspgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int sspgvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = sspgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgvx_", __itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssprfs_$descriptor() {
        return ssprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssprfs_$handle() {
        return ssprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssprfs_$address() {
        return ssprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ssprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ssprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssprfs_", __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspsv_$descriptor() {
        return sspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspsv_$handle() {
        return sspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspsv_$address() {
        return sspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sspsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspsv_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sspsvx_$descriptor() {
        return sspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sspsvx_$handle() {
        return sspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sspsvx_$address() {
        return sspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__afp, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sspsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssptrd_$descriptor() {
        return ssptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssptrd_$handle() {
        return ssptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssptrd_$address() {
        return ssptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static int ssptrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = ssptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrd_", __uplo, __n, __ap, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssptrf_$descriptor() {
        return ssptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssptrf_$handle() {
        return ssptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssptrf_$address() {
        return ssptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int ssptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = ssptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrf_", __uplo, __n, __ap, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssptri_$descriptor() {
        return ssptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssptri_$handle() {
        return ssptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssptri_$address() {
        return ssptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssptri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptri_", __uplo, __n, __ap, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssptrs_$descriptor() {
        return ssptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssptrs_$handle() {
        return ssptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssptrs_$address() {
        return ssptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ssptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ssptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrs_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstebz_$descriptor() {
        return sstebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstebz_$handle() {
        return sstebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstebz_$address() {
        return sstebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sstebz_(MemorySegment __range, MemorySegment __order, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __d__, MemorySegment __e, MemorySegment __m, MemorySegment __nsplit, MemorySegment __w, MemorySegment __iblock, MemorySegment __isplit, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sstebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstebz_", __range, __order, __n, __vl, __vu, __il, __iu, __abstol, __d__, __e, __m, __nsplit, __w, __iblock, __isplit, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__range, __order, __n, __vl, __vu, __il, __iu, __abstol, __d__, __e, __m, __nsplit, __w, __iblock, __isplit, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstedc_$descriptor() {
        return sstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstedc_$handle() {
        return sstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstedc_$address() {
        return sstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sstedc_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstedc_", __compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstegr_$descriptor() {
        return sstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstegr_$handle() {
        return sstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstegr_$address() {
        return sstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sstegr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstegr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstein_$descriptor() {
        return sstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstein_$handle() {
        return sstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstein_$address() {
        return sstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int sstein_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __m, MemorySegment __w, MemorySegment __iblock, MemorySegment __isplit, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = sstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstein_", __n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstemr_$descriptor() {
        return sstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstemr_$handle() {
        return sstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstemr_$address() {
        return sstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sstemr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __nzc, MemorySegment __isuppz, MemorySegment __tryrac, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstemr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssteqr_$descriptor() {
        return ssteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssteqr_$handle() {
        return ssteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssteqr_$address() {
        return ssteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssterf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssterf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssterf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssterf_$descriptor() {
        return ssterf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssterf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssterf_$handle() {
        return ssterf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssterf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssterf_$address() {
        return ssterf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssterf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static int ssterf_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = ssterf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssterf_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstev_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstev_$descriptor() {
        return sstev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstev_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstev_$handle() {
        return sstev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstev_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstev_$address() {
        return sstev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstev_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sstev_(MemorySegment __jobz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = sstev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstev_", __jobz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstevd_$descriptor() {
        return sstevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstevd_$handle() {
        return sstevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstevd_$address() {
        return sstevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sstevd_(MemorySegment __jobz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sstevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevd_", __jobz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstevr_$descriptor() {
        return sstevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstevr_$handle() {
        return sstevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstevr_$address() {
        return sstevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int sstevr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = sstevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sstevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sstevx_$descriptor() {
        return sstevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sstevx_$handle() {
        return sstevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sstevx_$address() {
        return sstevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int sstevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = sstevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevx_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssycon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssycon_$descriptor() {
        return ssycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssycon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssycon_$handle() {
        return ssycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssycon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssycon_$address() {
        return ssycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssycon_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ssycon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ssycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssycon_", __uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssyequb_$descriptor() {
        return ssyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssyequb_$handle() {
        return ssyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssyequb_$address() {
        return ssyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssyequb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyequb_", __uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssyev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssyev_$descriptor() {
        return ssyev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssyev_$handle() {
        return ssyev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssyev_$address() {
        return ssyev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ssyev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ssyev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyev_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssyevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssyevd_$descriptor() {
        return ssyevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssyevd_$handle() {
        return ssyevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssyevd_$address() {
        return ssyevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ssyevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ssyevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevd_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssyevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssyevr_$descriptor() {
        return ssyevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssyevr_$handle() {
        return ssyevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssyevr_$address() {
        return ssyevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ssyevr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ssyevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevr_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssyevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssyevx_$descriptor() {
        return ssyevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssyevx_$handle() {
        return ssyevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssyevx_$address() {
        return ssyevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int ssyevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = ssyevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevx_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssygs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssygs2_$descriptor() {
        return ssygs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssygs2_$handle() {
        return ssygs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssygs2_$address() {
        return ssygs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ssygs2_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ssygs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygs2_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssygst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssygst_$descriptor() {
        return ssygst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssygst_$handle() {
        return ssygst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssygst_$address() {
        return ssygst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ssygst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ssygst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygst_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssygv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssygv_$descriptor() {
        return ssygv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssygv_$handle() {
        return ssygv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssygv_$address() {
        return ssygv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ssygv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ssygv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygv_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssygvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssygvd_$descriptor() {
        return ssygvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssygvd_$handle() {
        return ssygvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssygvd_$address() {
        return ssygvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ssygvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ssygvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygvd_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssygvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssygvx_$descriptor() {
        return ssygvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssygvx_$handle() {
        return ssygvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssygvx_$address() {
        return ssygvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int ssygvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = ssygvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygvx_", __itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssyrfs_$descriptor() {
        return ssyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssyrfs_$handle() {
        return ssyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssyrfs_$address() {
        return ssyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ssyrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ssyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyrfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssysv_$descriptor() {
        return ssysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssysv_$handle() {
        return ssysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssysv_$address() {
        return ssysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ssysv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ssysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssysvx_$descriptor() {
        return ssysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssysvx_$handle() {
        return ssysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssysvx_$address() {
        return ssysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ssysvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ssysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssytd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssytd2_$descriptor() {
        return ssytd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssytd2_$handle() {
        return ssytd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssytd2_$address() {
        return ssytd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static int ssytd2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = ssytd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytd2_", __uplo, __n, __a, __lda, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssytf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssytf2_$descriptor() {
        return ssytf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssytf2_$handle() {
        return ssytf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssytf2_$address() {
        return ssytf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int ssytf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = ssytf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytf2_", __uplo, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssytrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssytrd_$descriptor() {
        return ssytrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssytrd_$handle() {
        return ssytrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssytrd_$address() {
        return ssytrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ssytrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ssytrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrd_", __uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssytrf_$descriptor() {
        return ssytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssytrf_$handle() {
        return ssytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssytrf_$address() {
        return ssytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ssytrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ssytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_", __uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssytri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssytri_$descriptor() {
        return ssytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssytri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssytri_$handle() {
        return ssytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssytri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssytri_$address() {
        return ssytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssytri_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int ssytri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = ssytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri_", __uplo, __n, __a, __lda, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ssytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ssytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ssytrs_$descriptor() {
        return ssytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ssytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ssytrs_$handle() {
        return ssytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ssytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ssytrs_$address() {
        return ssytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ssytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ssytrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ssytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stbcon_$descriptor() {
        return stbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stbcon_$handle() {
        return stbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stbcon_$address() {
        return stbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int stbcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = stbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbcon_", __norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stbrfs_$descriptor() {
        return stbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stbrfs_$handle() {
        return stbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stbrfs_$address() {
        return stbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int stbrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = stbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbrfs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stbtrs_$descriptor() {
        return stbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stbtrs_$handle() {
        return stbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stbtrs_$address() {
        return stbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int stbtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = stbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbtrs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor stfsm_$descriptor() {
        return stfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle stfsm_$handle() {
        return stfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment stfsm_$address() {
        return stfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__a, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int stfsm_(MemorySegment __transr, MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __a, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = stfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfsm_", __transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
            }
            return (int)mh$.invokeExact(__transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stftri_$descriptor() {
        return stftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stftri_$handle() {
        return stftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stftri_$address() {
        return stftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static int stftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = stftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stftri_", __transr, __uplo, __diag, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __diag, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stfttp_$descriptor() {
        return stfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stfttp_$handle() {
        return stfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stfttp_$address() {
        return stfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static int stfttp_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __ap, MemorySegment __info) {
        var mh$ = stfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfttp_", __transr, __uplo, __n, __arf, __ap, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stfttr_$descriptor() {
        return stfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stfttr_$handle() {
        return stfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stfttr_$address() {
        return stfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__arf, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int stfttr_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = stfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfttr_", __transr, __uplo, __n, __arf, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_real *__p, __CLPK_integer *__ldp, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgevc_$descriptor() {
        return stgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_real *__p, __CLPK_integer *__ldp, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgevc_$handle() {
        return stgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_real *__p, __CLPK_integer *__ldp, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgevc_$address() {
        return stgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_real *__p, __CLPK_integer *__ldp, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int stgevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __s, MemorySegment __lds, MemorySegment __p, MemorySegment __ldp, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __info) {
        var mh$ = stgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgevc_", __side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgex2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgex2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgex2_$descriptor() {
        return stgex2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgex2_$handle() {
        return stgex2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgex2_$address() {
        return stgex2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int stgex2_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __j1, MemorySegment __n1, MemorySegment __n2, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = stgex2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgex2_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __n1, __n2, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __n1, __n2, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgexc_$descriptor() {
        return stgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgexc_$handle() {
        return stgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgexc_$address() {
        return stgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int stgexc_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = stgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgexc_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgsen_$descriptor() {
        return stgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgsen_$handle() {
        return stgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgsen_$address() {
        return stgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int stgsen_(MemorySegment __ijob, MemorySegment __wantq, MemorySegment __wantz, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __m, MemorySegment __pl, MemorySegment __pr, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = stgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsen_", __ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgsja_$descriptor() {
        return stgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgsja_$handle() {
        return stgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgsja_$address() {
        return stgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static int stgsja_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __ncycle, MemorySegment __info) {
        var mh$ = stgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsja_", __jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgsna_$descriptor() {
        return stgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgsna_$handle() {
        return stgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgsna_$address() {
        return stgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int stgsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __dif, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = stgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsna_", __job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgsy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgsy2_$descriptor() {
        return stgsy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgsy2_$handle() {
        return stgsy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgsy2_$address() {
        return stgsy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static int stgsy2_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __iwork, MemorySegment __pq, MemorySegment __info) {
        var mh$ = stgsy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsy2_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __iwork, __pq, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __iwork, __pq, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stgsyl_$descriptor() {
        return stgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stgsyl_$handle() {
        return stgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stgsyl_$address() {
        return stgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__d__, __CLPK_integer *__ldd, __CLPK_real *__e, __CLPK_integer *__lde, __CLPK_real *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int stgsyl_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = stgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsyl_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stpcon_$descriptor() {
        return stpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stpcon_$handle() {
        return stpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stpcon_$address() {
        return stpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int stpcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = stpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcon_", __norm, __uplo, __diag, __n, __ap, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stprfs_$descriptor() {
        return stprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stprfs_$handle() {
        return stprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stprfs_$address() {
        return stprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int stprfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = stprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stprfs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stptri_$descriptor() {
        return stptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stptri_$handle() {
        return stptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stptri_$address() {
        return stptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static int stptri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = stptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stptri_", __uplo, __diag, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stptrs_$descriptor() {
        return stptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stptrs_$handle() {
        return stptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stptrs_$address() {
        return stptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__ap, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int stptrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = stptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stptrs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stpttf_$descriptor() {
        return stpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stpttf_$handle() {
        return stpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stpttf_$address() {
        return stpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static int stpttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __arf, MemorySegment __info) {
        var mh$ = stpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpttf_", __transr, __uplo, __n, __ap, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __ap, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stpttr_$descriptor() {
        return stpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stpttr_$handle() {
        return stpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stpttr_$address() {
        return stpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int stpttr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = stpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpttr_", __uplo, __n, __ap, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strcon_$descriptor() {
        return strcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strcon_$handle() {
        return strcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strcon_$address() {
        return strcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int strcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = strcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcon_", __norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strevc_$descriptor() {
        return strevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strevc_$handle() {
        return strevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strevc_$address() {
        return strevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int strevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __info) {
        var mh$ = strevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strevc_", __side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strexc_(char *__compq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strexc_$descriptor() {
        return strexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strexc_(char *__compq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strexc_$handle() {
        return strexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strexc_(char *__compq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strexc_$address() {
        return strexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strexc_(char *__compq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int strexc_(MemorySegment __compq, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __work, MemorySegment __info) {
        var mh$ = strexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strexc_", __compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __work, __info);
            }
            return (int)mh$.invokeExact(__compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strrfs_$descriptor() {
        return strrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strrfs_$handle() {
        return strrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strrfs_$address() {
        return strrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int strrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = strrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrfs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strsen_$descriptor() {
        return strsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strsen_$handle() {
        return strsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strsen_$address() {
        return strsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int strsen_(MemorySegment __job, MemorySegment __compq, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __wr, MemorySegment __wi, MemorySegment __m, MemorySegment __s, MemorySegment __sep, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = strsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsen_", __job, __compq, __select, __n, __t, __ldt, __q, __ldq, __wr, __wi, __m, __s, __sep, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __select, __n, __t, __ldt, __q, __ldq, __wr, __wi, __m, __s, __sep, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strsna_$descriptor() {
        return strsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strsna_$handle() {
        return strsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strsna_$address() {
        return strsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int strsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __sep, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __ldwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = strsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsna_", __job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strsyl_$descriptor() {
        return strsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strsyl_$handle() {
        return strsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strsyl_$address() {
        return strsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static int strsyl_(MemorySegment __trana, MemorySegment __tranb, MemorySegment __isgn, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __scale, MemorySegment __info) {
        var mh$ = strsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsyl_", __trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
            }
            return (int)mh$.invokeExact(__trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strti2_$descriptor() {
        return strti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strti2_$handle() {
        return strti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strti2_$address() {
        return strti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int strti2_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = strti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strti2_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strtri_$descriptor() {
        return strtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strtri_$handle() {
        return strtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strtri_$address() {
        return strtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int strtri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = strtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtri_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strtrs_$descriptor() {
        return strtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strtrs_$handle() {
        return strtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strtrs_$address() {
        return strtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int strtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = strtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtrs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strttf_$descriptor() {
        return strttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strttf_$handle() {
        return strttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strttf_$address() {
        return strttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__arf, __CLPK_integer *__info)
     * }
     */
    public static int strttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __arf, MemorySegment __info) {
        var mh$ = strttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strttf_", __transr, __uplo, __n, __a, __lda, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __lda, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("strttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strttp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor strttp_$descriptor() {
        return strttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strttp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle strttp_$handle() {
        return strttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strttp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment strttp_$address() {
        return strttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strttp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__ap, __CLPK_integer *__info)
     * }
     */
    public static int strttp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ap, MemorySegment __info) {
        var mh$ = strttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strttp_", __uplo, __n, __a, __lda, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stzrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stzrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stzrqf_$descriptor() {
        return stzrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stzrqf_$handle() {
        return stzrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stzrqf_$address() {
        return stzrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static int stzrqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __info) {
        var mh$ = stzrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stzrqf_", __m, __n, __a, __lda, __tau, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("stzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor stzrzf_$descriptor() {
        return stzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle stzrzf_$handle() {
        return stzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment stzrzf_$address() {
        return stzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int stzrzf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = stzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stzrzf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zbdsqr_$descriptor() {
        return zbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zbdsqr_$handle() {
        return zbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zbdsqr_$address() {
        return zbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zbdsqr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ncvt, MemorySegment __nru, MemorySegment __ncc, MemorySegment __d__, MemorySegment __e, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __u, MemorySegment __ldu, MemorySegment __c__, MemorySegment __ldc, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zbdsqr_", __uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zcgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zcgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zcgesv_$descriptor() {
        return zcgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zcgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zcgesv_$handle() {
        return zcgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zcgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zcgesv_$address() {
        return zcgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zcgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static int zcgesv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __swork, MemorySegment __rwork, MemorySegment __iter, MemorySegment __info) {
        var mh$ = zcgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcgesv_", __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __x, __ldx, __work, __swork, __rwork, __iter, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __x, __ldx, __work, __swork, __rwork, __iter, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zcposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zcposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zcposv_$descriptor() {
        return zcposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zcposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zcposv_$handle() {
        return zcposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zcposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zcposv_$address() {
        return zcposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zcposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_complex *__swork, __CLPK_doublereal *__rwork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static int zcposv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __swork, MemorySegment __rwork, MemorySegment __iter, MemorySegment __info) {
        var mh$ = zcposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcposv_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __work, __swork, __rwork, __iter, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __work, __swork, __rwork, __iter, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zdrscl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zdrscl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zdrscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublecomplex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor zdrscl_$descriptor() {
        return zdrscl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zdrscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublecomplex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle zdrscl_$handle() {
        return zdrscl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zdrscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublecomplex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment zdrscl_$address() {
        return zdrscl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zdrscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublecomplex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static int zdrscl_(MemorySegment __n, MemorySegment __sa, MemorySegment __sx, MemorySegment __incx) {
        var mh$ = zdrscl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zdrscl_", __n, __sa, __sx, __incx);
            }
            return (int)mh$.invokeExact(__n, __sa, __sx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__pt, __CLPK_integer *__ldpt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbbrd_$descriptor() {
        return zgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__pt, __CLPK_integer *__ldpt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbbrd_$handle() {
        return zgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__pt, __CLPK_integer *__ldpt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbbrd_$address() {
        return zgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__pt, __CLPK_integer *__ldpt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgbbrd_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __ncc, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __pt, MemorySegment __ldpt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbbrd_", __vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbcon_$descriptor() {
        return zgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbcon_$handle() {
        return zgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbcon_$address() {
        return zgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgbcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbcon_", __norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbequ_$descriptor() {
        return zgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbequ_$handle() {
        return zgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbequ_$address() {
        return zgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zgbequ_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbequ_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbequb_$descriptor() {
        return zgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbequb_$handle() {
        return zgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbequb_$address() {
        return zgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zgbequb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbequb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbrfs_$descriptor() {
        return zgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbrfs_$handle() {
        return zgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbrfs_$address() {
        return zgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgbrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbrfs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbsv_$descriptor() {
        return zgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbsv_$handle() {
        return zgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbsv_$address() {
        return zgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zgbsv_(MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsv_", __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbsvx_$descriptor() {
        return zgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbsvx_$handle() {
        return zgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbsvx_$address() {
        return zgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgbsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsvx_", __fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbtf2_$descriptor() {
        return zgbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbtf2_$handle() {
        return zgbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbtf2_$address() {
        return zgbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zgbtf2_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zgbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtf2_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbtrf_$descriptor() {
        return zgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbtrf_$handle() {
        return zgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbtrf_$address() {
        return zgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zgbtrf_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtrf_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgbtrs_$descriptor() {
        return zgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgbtrs_$handle() {
        return zgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgbtrs_$address() {
        return zgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zgbtrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtrs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgebak_$descriptor() {
        return zgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgebak_$handle() {
        return zgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgebak_$address() {
        return zgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int zgebak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = zgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebak_", __job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgebal_$descriptor() {
        return zgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgebal_$handle() {
        return zgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgebal_$address() {
        return zgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static int zgebal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __info) {
        var mh$ = zgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebal_", __job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgebd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgebd2_$descriptor() {
        return zgebd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgebd2_$handle() {
        return zgebd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgebd2_$address() {
        return zgebd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgebd2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgebd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebd2_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgebrd_$descriptor() {
        return zgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgebrd_$handle() {
        return zgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgebrd_$address() {
        return zgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgebrd_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebrd_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgecon_$descriptor() {
        return zgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgecon_$handle() {
        return zgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgecon_$address() {
        return zgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgecon_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgecon_", __norm, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeequ_$descriptor() {
        return zgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeequ_$handle() {
        return zgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeequ_$address() {
        return zgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zgeequ_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeequ_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeequb_$descriptor() {
        return zgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeequb_$handle() {
        return zgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeequb_$address() {
        return zgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zgeequb_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeequb_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgees_$descriptor() {
        return zgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgees_$handle() {
        return zgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgees_$address() {
        return zgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int zgees_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __w, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = zgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgees_", __jobvs, __sort, __select, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __work, __lwork, __rwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __work, __lwork, __rwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeesx_$descriptor() {
        return zgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeesx_$handle() {
        return zgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeesx_$address() {
        return zgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeesx_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __w, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = zgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeesx_", __jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __rwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __rwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeev_$descriptor() {
        return zgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeev_$handle() {
        return zgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeev_$address() {
        return zgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeev_", __jobvl, __jobvr, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeevx_$descriptor() {
        return zgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeevx_$handle() {
        return zgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeevx_$address() {
        return zgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __abnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgegs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgegs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgegs_$descriptor() {
        return zgegs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgegs_$handle() {
        return zgegs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgegs_$address() {
        return zgegs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgegs_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgegs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgegs_", __jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgegv_$descriptor() {
        return zgegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgegv_$handle() {
        return zgegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgegv_$address() {
        return zgegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgegv_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgegv_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgehd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgehd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgehd2_$descriptor() {
        return zgehd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgehd2_$handle() {
        return zgehd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgehd2_$address() {
        return zgehd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgehd2_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgehd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgehd2_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgehrd_$descriptor() {
        return zgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgehrd_$handle() {
        return zgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgehrd_$address() {
        return zgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgehrd_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgehrd_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgelq2_$descriptor() {
        return zgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgelq2_$handle() {
        return zgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgelq2_$address() {
        return zgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgelq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgelqf_$descriptor() {
        return zgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgelqf_$handle() {
        return zgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgelqf_$address() {
        return zgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgelqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgels_$descriptor() {
        return zgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgels_$handle() {
        return zgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgels_$address() {
        return zgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgels_(MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgels_", __trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgelsd_$descriptor() {
        return zgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgelsd_$handle() {
        return zgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgelsd_$address() {
        return zgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zgelsd_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsd_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgelss_$descriptor() {
        return zgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgelss_$handle() {
        return zgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgelss_$address() {
        return zgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgelss_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelss_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgelsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgelsx_$descriptor() {
        return zgelsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgelsx_$handle() {
        return zgelsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgelsx_$address() {
        return zgelsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgelsx_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgelsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsx_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgelsy_$descriptor() {
        return zgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgelsy_$handle() {
        return zgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgelsy_$address() {
        return zgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgelsy_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsy_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeql2_$descriptor() {
        return zgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeql2_$handle() {
        return zgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeql2_$address() {
        return zgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgeql2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeql2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeqlf_$descriptor() {
        return zgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeqlf_$handle() {
        return zgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeqlf_$address() {
        return zgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeqlf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqlf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeqp3_$descriptor() {
        return zgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeqp3_$handle() {
        return zgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeqp3_$address() {
        return zgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeqp3_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqp3_", __m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeqpf_$descriptor() {
        return zgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeqpf_$handle() {
        return zgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeqpf_$address() {
        return zgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeqpf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqpf_", __m, __n, __a, __lda, __jpvt, __tau, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeqr2_$descriptor() {
        return zgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeqr2_$handle() {
        return zgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeqr2_$address() {
        return zgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgeqr2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqr2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgeqrf_$descriptor() {
        return zgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgeqrf_$handle() {
        return zgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgeqrf_$address() {
        return zgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgeqrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgerfs_$descriptor() {
        return zgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgerfs_$handle() {
        return zgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgerfs_$address() {
        return zgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgerfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerfs_", __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgerq2_$descriptor() {
        return zgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgerq2_$handle() {
        return zgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgerq2_$address() {
        return zgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgerq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgerqf_$descriptor() {
        return zgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgerqf_$handle() {
        return zgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgerqf_$address() {
        return zgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgerqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgesc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgesc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static FunctionDescriptor zgesc2_$descriptor() {
        return zgesc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgesc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static MethodHandle zgesc2_$handle() {
        return zgesc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgesc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static MemorySegment zgesc2_$address() {
        return zgesc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgesc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static int zgesc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rhs, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __scale) {
        var mh$ = zgesc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesc2_", __n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgesdd_$descriptor() {
        return zgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgesdd_$handle() {
        return zgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgesdd_$address() {
        return zgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zgesdd_(MemorySegment __jobz, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesdd_", __jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgesv_$descriptor() {
        return zgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgesv_$handle() {
        return zgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgesv_$address() {
        return zgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zgesv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesv_", __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgesvd_$descriptor() {
        return zgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgesvd_$handle() {
        return zgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgesvd_$address() {
        return zgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__vt, __CLPK_integer *__ldvt, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgesvd_(MemorySegment __jobu, MemorySegment __jobvt, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvd_", __jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgesvx_$descriptor() {
        return zgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgesvx_$handle() {
        return zgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgesvx_$address() {
        return zgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgesvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvx_", __fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgetc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgetc2_$descriptor() {
        return zgetc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgetc2_$handle() {
        return zgetc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgetc2_$address() {
        return zgetc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetc2_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static int zgetc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __info) {
        var mh$ = zgetc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetc2_", __n, __a, __lda, __ipiv, __jpiv, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __jpiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgetf2_$descriptor() {
        return zgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgetf2_$handle() {
        return zgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgetf2_$address() {
        return zgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zgetf2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetf2_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgetrf_$descriptor() {
        return zgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgetrf_$handle() {
        return zgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgetrf_$address() {
        return zgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zgetrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrf_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetri_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgetri_$descriptor() {
        return zgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetri_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgetri_$handle() {
        return zgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetri_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgetri_$address() {
        return zgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetri_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgetri_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetri_", __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgetrs_$descriptor() {
        return zgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgetrs_$handle() {
        return zgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgetrs_$address() {
        return zgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zgetrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrs_", __trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggbak_$descriptor() {
        return zggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggbak_$handle() {
        return zggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggbak_$address() {
        return zggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int zggbak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = zggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggbak_", __job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggbal_$descriptor() {
        return zggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggbal_$handle() {
        return zggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggbal_$address() {
        return zggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int zggbal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __work, MemorySegment __info) {
        var mh$ = zggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggbal_", __job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgges_$descriptor() {
        return zgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgges_$handle() {
        return zgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgges_$address() {
        return zgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int zgges_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = zgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgges_", __jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggesx_$descriptor() {
        return zggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggesx_$handle() {
        return zggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggesx_$address() {
        return zggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublecomplex *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int zggesx_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = zggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggesx_", __jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __liwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __liwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggev_$descriptor() {
        return zggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggev_$handle() {
        return zggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggev_$address() {
        return zggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zggev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggev_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggevx_$descriptor() {
        return zggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggevx_$handle() {
        return zggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggevx_$address() {
        return zggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int zggevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __abnrm, MemorySegment __bbnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = zggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggglm_$descriptor() {
        return zggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggglm_$handle() {
        return zggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggglm_$address() {
        return zggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zggglm_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __d__, MemorySegment __x, MemorySegment __y, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggglm_", __n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgghrd_$descriptor() {
        return zgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgghrd_$handle() {
        return zgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgghrd_$address() {
        return zgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int zgghrd_(MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = zgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgghrd_", __compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgglse_$descriptor() {
        return zgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgglse_$handle() {
        return zgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgglse_$address() {
        return zgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zgglse_(MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __d__, MemorySegment __x, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgglse_", __m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggqrf_$descriptor() {
        return zggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggqrf_$handle() {
        return zggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggqrf_$address() {
        return zggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zggqrf_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggqrf_", __n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggrqf_$descriptor() {
        return zggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggrqf_$handle() {
        return zggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggrqf_$address() {
        return zggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__taua, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__taub, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zggrqf_(MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggrqf_", __m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggsvd_$descriptor() {
        return zggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggsvd_$handle() {
        return zggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggsvd_$address() {
        return zggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zggsvd_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvd_", __jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__rwork, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zggsvp_$descriptor() {
        return zggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__rwork, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zggsvp_$handle() {
        return zggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__rwork, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zggsvp_$address() {
        return zggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__rwork, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zggsvp_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __k, MemorySegment __l, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __iwork, MemorySegment __rwork, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvp_", __jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __rwork, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __rwork, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgtcon_$descriptor() {
        return zgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgtcon_$handle() {
        return zgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgtcon_$address() {
        return zgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zgtcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = zgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtcon_", __norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgtrfs_$descriptor() {
        return zgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgtrfs_$handle() {
        return zgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgtrfs_$address() {
        return zgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgtrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtrfs_", __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgtsv_$descriptor() {
        return zgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgtsv_$handle() {
        return zgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgtsv_$address() {
        return zgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zgtsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtsv_", __n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgtsvx_$descriptor() {
        return zgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgtsvx_$handle() {
        return zgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgtsvx_$address() {
        return zgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__dlf, __CLPK_doublecomplex *__df, __CLPK_doublecomplex *__duf, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zgtsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtsvx_", __fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgttrf_(__CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgttrf_$descriptor() {
        return zgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgttrf_(__CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgttrf_$handle() {
        return zgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgttrf_(__CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgttrf_$address() {
        return zgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgttrf_(__CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zgttrf_(MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgttrf_", __n, __dl, __d__, __du, __du2, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__n, __dl, __d__, __du, __du2, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zgttrs_$descriptor() {
        return zgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zgttrs_$handle() {
        return zgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zgttrs_$address() {
        return zgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zgttrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgttrs_", __trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zgtts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor zgtts2_$descriptor() {
        return zgtts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle zgtts2_$handle() {
        return zgtts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment zgtts2_$address() {
        return zgtts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__du2, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int zgtts2_(MemorySegment __itrans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = zgtts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtts2_", __itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
            }
            return (int)mh$.invokeExact(__itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbev_$descriptor() {
        return zhbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbev_$handle() {
        return zhbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbev_$address() {
        return zhbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhbev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbev_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbevd_$descriptor() {
        return zhbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbevd_$handle() {
        return zhbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbevd_$address() {
        return zhbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zhbevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zhbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevd_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbevx_$descriptor() {
        return zhbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbevx_$handle() {
        return zhbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbevx_$address() {
        return zhbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zhbevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zhbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevx_", __jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbgst_$descriptor() {
        return zhbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbgst_$handle() {
        return zhbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbgst_$address() {
        return zhbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhbgst_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgst_", __vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbgv_$descriptor() {
        return zhbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbgv_$handle() {
        return zhbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbgv_$address() {
        return zhbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhbgv_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgv_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbgvd_$descriptor() {
        return zhbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbgvd_$handle() {
        return zhbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbgvd_$address() {
        return zhbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zhbgvd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zhbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgvd_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbgvx_$descriptor() {
        return zhbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbgvx_$handle() {
        return zhbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbgvx_$address() {
        return zhbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__bb, __CLPK_integer *__ldbb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zhbgvx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zhbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgvx_", __jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhbtrd_$descriptor() {
        return zhbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhbtrd_$handle() {
        return zhbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhbtrd_$address() {
        return zhbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zhbtrd_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = zhbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbtrd_", __vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhecon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhecon_$descriptor() {
        return zhecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhecon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhecon_$handle() {
        return zhecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhecon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhecon_$address() {
        return zhecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhecon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zhecon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = zhecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhecon_", __uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zheequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zheequb_$descriptor() {
        return zheequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zheequb_$handle() {
        return zheequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zheequb_$address() {
        return zheequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zheequb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __work, MemorySegment __info) {
        var mh$ = zheequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheequb_", __uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zheev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zheev_$descriptor() {
        return zheev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zheev_$handle() {
        return zheev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zheev_$address() {
        return zheev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zheev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zheev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheev_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zheevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zheevd_$descriptor() {
        return zheevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zheevd_$handle() {
        return zheevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zheevd_$address() {
        return zheevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zheevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zheevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevd_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zheevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zheevr_$descriptor() {
        return zheevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zheevr_$handle() {
        return zheevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zheevr_$address() {
        return zheevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zheevr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zheevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevr_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zheevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zheevx_$descriptor() {
        return zheevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zheevx_$handle() {
        return zheevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zheevx_$address() {
        return zheevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zheevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zheevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevx_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhegs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhegs2_$descriptor() {
        return zhegs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhegs2_$handle() {
        return zhegs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhegs2_$address() {
        return zhegs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zhegs2_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zhegs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegs2_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhegst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhegst_$descriptor() {
        return zhegst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhegst_$handle() {
        return zhegst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhegst_$address() {
        return zhegst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zhegst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zhegst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegst_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhegv_$descriptor() {
        return zhegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhegv_$handle() {
        return zhegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhegv_$address() {
        return zhegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhegv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegv_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhegvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhegvd_$descriptor() {
        return zhegvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhegvd_$handle() {
        return zhegvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhegvd_$address() {
        return zhegvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zhegvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zhegvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegvd_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhegvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhegvx_$descriptor() {
        return zhegvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhegvx_$handle() {
        return zhegvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhegvx_$address() {
        return zhegvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zhegvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zhegvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegvx_", __itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zherfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zherfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zherfs_$descriptor() {
        return zherfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zherfs_$handle() {
        return zherfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zherfs_$address() {
        return zherfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zherfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zherfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zherfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhesv_$descriptor() {
        return zhesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhesv_$handle() {
        return zhesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhesv_$address() {
        return zhesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zhesv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zhesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhesvx_$descriptor() {
        return zhesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhesvx_$handle() {
        return zhesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhesvx_$address() {
        return zhesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhesvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhetd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhetd2_$descriptor() {
        return zhetd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhetd2_$handle() {
        return zhetd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhetd2_$address() {
        return zhetd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static int zhetd2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = zhetd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetd2_", __uplo, __n, __a, __lda, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhetf2_$descriptor() {
        return zhetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhetf2_$handle() {
        return zhetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhetf2_$address() {
        return zhetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zhetf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zhetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetf2_", __uplo, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhetrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhetrd_$descriptor() {
        return zhetrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhetrd_$handle() {
        return zhetrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhetrd_$address() {
        return zhetrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zhetrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zhetrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrd_", __uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhetrf_$descriptor() {
        return zhetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhetrf_$handle() {
        return zhetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhetrf_$address() {
        return zhetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zhetrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zhetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_", __uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhetri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhetri_$descriptor() {
        return zhetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhetri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhetri_$handle() {
        return zhetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhetri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhetri_$address() {
        return zhetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhetri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zhetri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = zhetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri_", __uplo, __n, __a, __lda, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhetrs_$descriptor() {
        return zhetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhetrs_$handle() {
        return zhetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhetrs_$address() {
        return zhetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zhetrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zhetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__c__)
     * }
     */
    public static FunctionDescriptor zhfrk_$descriptor() {
        return zhfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__c__)
     * }
     */
    public static MethodHandle zhfrk_$handle() {
        return zhfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__c__)
     * }
     */
    public static MemorySegment zhfrk_$address() {
        return zhfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__c__)
     * }
     */
    public static int zhfrk_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __trans, MemorySegment __n, MemorySegment __k, MemorySegment __alpha, MemorySegment __a, MemorySegment __lda, MemorySegment __beta, MemorySegment __c__) {
        var mh$ = zhfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhfrk_", __transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhgeqz_$descriptor() {
        return zhgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhgeqz_$handle() {
        return zhgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhgeqz_$address() {
        return zhgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhgeqz_(MemorySegment __job, MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __t, MemorySegment __ldt, MemorySegment __alpha, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhgeqz_", __job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alpha, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alpha, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpcon_$descriptor() {
        return zhpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpcon_$handle() {
        return zhpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpcon_$address() {
        return zhpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zhpcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = zhpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpcon_", __uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpev_$descriptor() {
        return zhpev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpev_$handle() {
        return zhpev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpev_$address() {
        return zhpev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhpev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhpev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpev_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpevd_$descriptor() {
        return zhpevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpevd_$handle() {
        return zhpevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpevd_$address() {
        return zhpevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zhpevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zhpevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpevd_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpevx_$descriptor() {
        return zhpevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpevx_$handle() {
        return zhpevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpevx_$address() {
        return zhpevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zhpevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zhpevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpevx_", __jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpgst_$descriptor() {
        return zhpgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpgst_$handle() {
        return zhpgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpgst_$address() {
        return zhpgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_integer *__info)
     * }
     */
    public static int zhpgst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __info) {
        var mh$ = zhpgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgst_", __itype, __uplo, __n, __ap, __bp, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __ap, __bp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpgv_$descriptor() {
        return zhpgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpgv_$handle() {
        return zhpgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpgv_$address() {
        return zhpgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhpgv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhpgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgv_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpgvd_$descriptor() {
        return zhpgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpgvd_$handle() {
        return zhpgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpgvd_$address() {
        return zhpgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zhpgvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zhpgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgvd_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpgvx_$descriptor() {
        return zhpgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpgvx_$handle() {
        return zhpgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpgvx_$address() {
        return zhpgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zhpgvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zhpgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgvx_", __itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhprfs_$descriptor() {
        return zhprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhprfs_$handle() {
        return zhprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhprfs_$address() {
        return zhprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhprfs_", __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpsv_$descriptor() {
        return zhpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpsv_$handle() {
        return zhpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpsv_$address() {
        return zhpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zhpsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zhpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpsv_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhpsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhpsvx_$descriptor() {
        return zhpsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhpsvx_$handle() {
        return zhpsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhpsvx_$address() {
        return zhpsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zhpsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zhpsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhptrd_$descriptor() {
        return zhptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhptrd_$handle() {
        return zhptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhptrd_$address() {
        return zhptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static int zhptrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = zhptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrd_", __uplo, __n, __ap, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhptrf_$descriptor() {
        return zhptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhptrf_$handle() {
        return zhptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhptrf_$address() {
        return zhptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zhptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zhptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrf_", __uplo, __n, __ap, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhptri_$descriptor() {
        return zhptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhptri_$handle() {
        return zhptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhptri_$address() {
        return zhptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zhptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = zhptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptri_", __uplo, __n, __ap, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhptrs_$descriptor() {
        return zhptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhptrs_$handle() {
        return zhptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhptrs_$address() {
        return zhptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zhptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zhptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrs_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhsein_$descriptor() {
        return zhsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhsein_$handle() {
        return zhsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhsein_$address() {
        return zhsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static int zhsein_(MemorySegment __side, MemorySegment __eigsrc, MemorySegment __initv, MemorySegment __select, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __rwork, MemorySegment __ifaill, MemorySegment __ifailr, MemorySegment __info) {
        var mh$ = zhsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhsein_", __side, __eigsrc, __initv, __select, __n, __h__, __ldh, __w, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __ifaill, __ifailr, __info);
            }
            return (int)mh$.invokeExact(__side, __eigsrc, __initv, __select, __n, __h__, __ldh, __w, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __ifaill, __ifailr, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zhseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zhseqr_$descriptor() {
        return zhseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zhseqr_$handle() {
        return zhseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zhseqr_$address() {
        return zhseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zhseqr_(MemorySegment __job, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zhseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhseqr_", __job, __compz, __n, __ilo, __ihi, __h__, __ldh, __w, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compz, __n, __ilo, __ihi, __h__, __ldh, __w, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlabrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlabrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor zlabrd_$descriptor() {
        return zlabrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle zlabrd_$handle() {
        return zlabrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment zlabrd_$address() {
        return zlabrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tauq, __CLPK_doublecomplex *__taup, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int zlabrd_(MemorySegment __m, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __x, MemorySegment __ldx, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = zlabrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlabrd_", __m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
            }
            return (int)mh$.invokeExact(__m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacgv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor zlacgv_$descriptor() {
        return zlacgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacgv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle zlacgv_$handle() {
        return zlacgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacgv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment zlacgv_$address() {
        return zlacgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacgv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx)
     * }
     */
    public static int zlacgv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx) {
        var mh$ = zlacgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacgv_", __n, __x, __incx);
            }
            return (int)mh$.invokeExact(__n, __x, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacn2_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static FunctionDescriptor zlacn2_$descriptor() {
        return zlacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacn2_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MethodHandle zlacn2_$handle() {
        return zlacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacn2_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MemorySegment zlacn2_$address() {
        return zlacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacn2_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static int zlacn2_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __est, MemorySegment __kase, MemorySegment __isave) {
        var mh$ = zlacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacn2_", __n, __v, __x, __est, __kase, __isave);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __est, __kase, __isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacon_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static FunctionDescriptor zlacon_$descriptor() {
        return zlacon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacon_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static MethodHandle zlacon_$handle() {
        return zlacon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacon_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static MemorySegment zlacon_$address() {
        return zlacon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacon_(__CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__x, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static int zlacon_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __est, MemorySegment __kase) {
        var mh$ = zlacon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacon_", __n, __v, __x, __est, __kase);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __est, __kase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor zlacp2_$descriptor() {
        return zlacp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle zlacp2_$handle() {
        return zlacp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment zlacp2_$address() {
        return zlacp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int zlacp2_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = zlacp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacp2_", __uplo, __m, __n, __a, __lda, __b, __ldb);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __a, __lda, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor zlacpy_$descriptor() {
        return zlacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle zlacpy_$handle() {
        return zlacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment zlacpy_$address() {
        return zlacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int zlacpy_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = zlacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacpy_", __uplo, __m, __n, __a, __lda, __b, __ldb);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __a, __lda, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacrm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacrm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static FunctionDescriptor zlacrm_$descriptor() {
        return zlacrm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static MethodHandle zlacrm_$handle() {
        return zlacrm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static MemorySegment zlacrm_$address() {
        return zlacrm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static int zlacrm_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __rwork) {
        var mh$ = zlacrm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacrm_", __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlacrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlacrt_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static FunctionDescriptor zlacrt_$descriptor() {
        return zlacrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlacrt_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static MethodHandle zlacrt_$handle() {
        return zlacrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlacrt_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static MemorySegment zlacrt_$address() {
        return zlacrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlacrt_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static int zlacrt_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx, MemorySegment __cy, MemorySegment __incy, MemorySegment __c__, MemorySegment __s) {
        var mh$ = zlacrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacrt_", __n, __cx, __incx, __cy, __incy, __c__, __s);
            }
            return (int)mh$.invokeExact(__n, __cx, __incx, __cy, __incy, __c__, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zladiv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zladiv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zladiv_(__CLPK_doublecomplex *__ret_val, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y)
     * }
     */
    public static FunctionDescriptor zladiv_$descriptor() {
        return zladiv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zladiv_(__CLPK_doublecomplex *__ret_val, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y)
     * }
     */
    public static MethodHandle zladiv_$handle() {
        return zladiv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zladiv_(__CLPK_doublecomplex *__ret_val, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y)
     * }
     */
    public static MemorySegment zladiv_$address() {
        return zladiv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zladiv_(__CLPK_doublecomplex *__ret_val, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y)
     * }
     */
    public static void zladiv_(MemorySegment __ret_val, MemorySegment __x, MemorySegment __y) {
        var mh$ = zladiv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zladiv_", __ret_val, __x, __y);
            }
            mh$.invokeExact(__ret_val, __x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaed0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaed0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlaed0_$descriptor() {
        return zlaed0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlaed0_$handle() {
        return zlaed0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlaed0_$address() {
        return zlaed0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zlaed0_(MemorySegment __qsiz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __qstore, MemorySegment __ldqs, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zlaed0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaed0_", __qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaed7_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaed7_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_integer *__indxq, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlaed7_$descriptor() {
        return zlaed7_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_integer *__indxq, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlaed7_$handle() {
        return zlaed7_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_integer *__indxq, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlaed7_$address() {
        return zlaed7_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_integer *__indxq, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zlaed7_(MemorySegment __n, MemorySegment __cutpnt, MemorySegment __qsiz, MemorySegment __tlvls, MemorySegment __curlvl, MemorySegment __curpbm, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __rho, MemorySegment __indxq, MemorySegment __qstore, MemorySegment __qptr, MemorySegment __prmptr, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zlaed7_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaed7_", __n, __cutpnt, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __rho, __indxq, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __cutpnt, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __rho, __indxq, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaed8_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaed8_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__d__, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublecomplex *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlaed8_$descriptor() {
        return zlaed8_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__d__, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublecomplex *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlaed8_$handle() {
        return zlaed8_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__d__, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublecomplex *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlaed8_$address() {
        return zlaed8_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__d__, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublecomplex *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__info)
     * }
     */
    public static int zlaed8_(MemorySegment __k, MemorySegment __n, MemorySegment __qsiz, MemorySegment __q, MemorySegment __ldq, MemorySegment __d__, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __z__, MemorySegment __dlamda, MemorySegment __q2, MemorySegment __ldq2, MemorySegment __w, MemorySegment __indxp, MemorySegment __indx, MemorySegment __indxq, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __info) {
        var mh$ = zlaed8_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaed8_", __k, __n, __qsiz, __q, __ldq, __d__, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __indxp, __indx, __indxq, __perm, __givptr, __givcol, __givnum, __info);
            }
            return (int)mh$.invokeExact(__k, __n, __qsiz, __q, __ldq, __d__, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __indxp, __indx, __indxq, __perm, __givptr, __givcol, __givnum, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rwork, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlaein_$descriptor() {
        return zlaein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rwork, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlaein_$handle() {
        return zlaein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rwork, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlaein_$address() {
        return zlaein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rwork, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static int zlaein_(MemorySegment __rightv, MemorySegment __noinit, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __v, MemorySegment __b, MemorySegment __ldb, MemorySegment __rwork, MemorySegment __eps3, MemorySegment __smlnum, MemorySegment __info) {
        var mh$ = zlaein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaein_", __rightv, __noinit, __n, __h__, __ldh, __w, __v, __b, __ldb, __rwork, __eps3, __smlnum, __info);
            }
            return (int)mh$.invokeExact(__rightv, __noinit, __n, __h__, __ldh, __w, __v, __b, __ldb, __rwork, __eps3, __smlnum, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaesy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaesy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaesy_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__rt1, __CLPK_doublecomplex *__rt2, __CLPK_doublecomplex *__evscal, __CLPK_doublecomplex *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static FunctionDescriptor zlaesy_$descriptor() {
        return zlaesy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaesy_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__rt1, __CLPK_doublecomplex *__rt2, __CLPK_doublecomplex *__evscal, __CLPK_doublecomplex *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static MethodHandle zlaesy_$handle() {
        return zlaesy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaesy_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__rt1, __CLPK_doublecomplex *__rt2, __CLPK_doublecomplex *__evscal, __CLPK_doublecomplex *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static MemorySegment zlaesy_$address() {
        return zlaesy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaesy_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublecomplex *__rt1, __CLPK_doublecomplex *__rt2, __CLPK_doublecomplex *__evscal, __CLPK_doublecomplex *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static int zlaesy_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2, MemorySegment __evscal, MemorySegment __cs1, MemorySegment __sn1) {
        var mh$ = zlaesy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaesy_", __a, __b, __c__, __rt1, __rt2, __evscal, __cs1, __sn1);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2, __evscal, __cs1, __sn1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaev2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaev2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaev2_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static FunctionDescriptor zlaev2_$descriptor() {
        return zlaev2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaev2_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static MethodHandle zlaev2_$handle() {
        return zlaev2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaev2_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static MemorySegment zlaev2_$address() {
        return zlaev2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaev2_(__CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_doublecomplex *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublecomplex *__sn1)
     * }
     */
    public static int zlaev2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2, MemorySegment __cs1, MemorySegment __sn1) {
        var mh$ = zlaev2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaev2_", __a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlag2c_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlag2c_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlag2c_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlag2c_$descriptor() {
        return zlag2c_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlag2c_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlag2c_$handle() {
        return zlag2c_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlag2c_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlag2c_$address() {
        return zlag2c_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlag2c_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static int zlag2c_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sa, MemorySegment __ldsa, MemorySegment __info) {
        var mh$ = zlag2c_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlag2c_", __m, __n, __a, __lda, __sa, __ldsa, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __sa, __ldsa, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlags2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlags2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublecomplex *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublecomplex *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublecomplex *__snu, __CLPK_doublereal *__csv, __CLPK_doublecomplex *__snv, __CLPK_doublereal *__csq, __CLPK_doublecomplex *__snq)
     * }
     */
    public static FunctionDescriptor zlags2_$descriptor() {
        return zlags2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublecomplex *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublecomplex *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublecomplex *__snu, __CLPK_doublereal *__csv, __CLPK_doublecomplex *__snv, __CLPK_doublereal *__csq, __CLPK_doublecomplex *__snq)
     * }
     */
    public static MethodHandle zlags2_$handle() {
        return zlags2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublecomplex *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublecomplex *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublecomplex *__snu, __CLPK_doublereal *__csv, __CLPK_doublecomplex *__snv, __CLPK_doublereal *__csq, __CLPK_doublecomplex *__snq)
     * }
     */
    public static MemorySegment zlags2_$address() {
        return zlags2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublecomplex *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublecomplex *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublecomplex *__snu, __CLPK_doublereal *__csv, __CLPK_doublecomplex *__snv, __CLPK_doublereal *__csq, __CLPK_doublecomplex *__snq)
     * }
     */
    public static int zlags2_(MemorySegment __upper, MemorySegment __a1, MemorySegment __a2, MemorySegment __a3, MemorySegment __b1, MemorySegment __b2, MemorySegment __b3, MemorySegment __csu, MemorySegment __snu, MemorySegment __csv, MemorySegment __snv, MemorySegment __csq, MemorySegment __snq) {
        var mh$ = zlags2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlags2_", __upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
            }
            return (int)mh$.invokeExact(__upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlagtm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlagtm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor zlagtm_$descriptor() {
        return zlagtm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle zlagtm_$handle() {
        return zlagtm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment zlagtm_$address() {
        return zlagtm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int zlagtm_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __alpha, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __x, MemorySegment __ldx, MemorySegment __beta, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = zlagtm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlagtm_", __trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlahef_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlahef_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlahef_$descriptor() {
        return zlahef_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlahef_$handle() {
        return zlahef_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlahef_$address() {
        return zlahef_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static int zlahef_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __w, MemorySegment __ldw, MemorySegment __info) {
        var mh$ = zlahef_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlahef_", __uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlahqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlahqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlahqr_$descriptor() {
        return zlahqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlahqr_$handle() {
        return zlahqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlahqr_$address() {
        return zlahqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int zlahqr_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = zlahqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlahqr_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlahr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlahr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor zlahr2_$descriptor() {
        return zlahr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle zlahr2_$handle() {
        return zlahr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment zlahr2_$address() {
        return zlahr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int zlahr2_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = zlahr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlahr2_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlahrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlahrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor zlahrd_$descriptor() {
        return zlahrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle zlahrd_$handle() {
        return zlahrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment zlahrd_$address() {
        return zlahrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int zlahrd_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = zlahrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlahrd_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaic1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaic1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublecomplex *__x, __CLPK_doublereal *__sest, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__c__)
     * }
     */
    public static FunctionDescriptor zlaic1_$descriptor() {
        return zlaic1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublecomplex *__x, __CLPK_doublereal *__sest, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__c__)
     * }
     */
    public static MethodHandle zlaic1_$handle() {
        return zlaic1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublecomplex *__x, __CLPK_doublereal *__sest, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__c__)
     * }
     */
    public static MemorySegment zlaic1_$address() {
        return zlaic1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublecomplex *__x, __CLPK_doublereal *__sest, __CLPK_doublecomplex *__w, __CLPK_doublecomplex *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__c__)
     * }
     */
    public static int zlaic1_(MemorySegment __job, MemorySegment __j, MemorySegment __x, MemorySegment __sest, MemorySegment __w, MemorySegment __gamma, MemorySegment __sestpr, MemorySegment __s, MemorySegment __c__) {
        var mh$ = zlaic1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaic1_", __job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
            }
            return (int)mh$.invokeExact(__job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlals0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlals0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlals0_$descriptor() {
        return zlals0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlals0_$handle() {
        return zlals0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlals0_$address() {
        return zlals0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zlals0_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __poles, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __k, MemorySegment __c__, MemorySegment __s, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zlals0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlals0_", __icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __rwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlalsa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlalsa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlalsa_$descriptor() {
        return zlalsa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlalsa_$handle() {
        return zlalsa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlalsa_$address() {
        return zlalsa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zlalsa_(MemorySegment __icompq, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __k, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __poles, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __perm, MemorySegment __givnum, MemorySegment __c__, MemorySegment __s, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zlalsa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlalsa_", __icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlalsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlalsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlalsd_$descriptor() {
        return zlalsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlalsd_$handle() {
        return zlalsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlalsd_$address() {
        return zlalsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zlalsd_(MemorySegment __uplo, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zlalsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlalsd_", __uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlangb_$descriptor() {
        return zlangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlangb_$handle() {
        return zlangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlangb_$address() {
        return zlangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double zlangb_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = zlangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlangb_", __norm, __n, __kl, __ku, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlange_$descriptor() {
        return zlange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlange_$handle() {
        return zlange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlange_$address() {
        return zlange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double zlange_(MemorySegment __norm, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = zlange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlange_", __norm, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du)
     * }
     */
    public static FunctionDescriptor zlangt_$descriptor() {
        return zlangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du)
     * }
     */
    public static MethodHandle zlangt_$handle() {
        return zlangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du)
     * }
     */
    public static MemorySegment zlangt_$address() {
        return zlangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__dl, __CLPK_doublecomplex *__d__, __CLPK_doublecomplex *__du)
     * }
     */
    public static double zlangt_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du) {
        var mh$ = zlangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlangt_", __norm, __n, __dl, __d__, __du);
            }
            return (double)mh$.invokeExact(__norm, __n, __dl, __d__, __du);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlanhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlanhb_$descriptor() {
        return zlanhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlanhb_$handle() {
        return zlanhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlanhb_$address() {
        return zlanhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double zlanhb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = zlanhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhb_", __norm, __uplo, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlanhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlanhe_$descriptor() {
        return zlanhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlanhe_$handle() {
        return zlanhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlanhe_$address() {
        return zlanhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double zlanhe_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = zlanhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhe_", __norm, __uplo, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlanhf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlanhf_$descriptor() {
        return zlanhf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlanhf_$handle() {
        return zlanhf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlanhf_$address() {
        return zlanhf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_doublereal *__work)
     * }
     */
    public static double zlanhf_(MemorySegment __norm, MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __work) {
        var mh$ = zlanhf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhf_", __norm, __transr, __uplo, __n, __a, __work);
            }
            return (double)mh$.invokeExact(__norm, __transr, __uplo, __n, __a, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlanhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlanhp_$descriptor() {
        return zlanhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlanhp_$handle() {
        return zlanhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlanhp_$address() {
        return zlanhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static double zlanhp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = zlanhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhp_", __norm, __uplo, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlanhs_$descriptor() {
        return zlanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlanhs_$handle() {
        return zlanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlanhs_$address() {
        return zlanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double zlanhs_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = zlanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhs_", __norm, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanht_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlanht_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanht_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e)
     * }
     */
    public static FunctionDescriptor zlanht_$descriptor() {
        return zlanht_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanht_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e)
     * }
     */
    public static MethodHandle zlanht_$handle() {
        return zlanht_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlanht_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e)
     * }
     */
    public static MemorySegment zlanht_$address() {
        return zlanht_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlanht_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e)
     * }
     */
    public static double zlanht_(MemorySegment __norm, MemorySegment __n, MemorySegment __d__, MemorySegment __e) {
        var mh$ = zlanht_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanht_", __norm, __n, __d__, __e);
            }
            return (double)mh$.invokeExact(__norm, __n, __d__, __e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlansb_$descriptor() {
        return zlansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlansb_$handle() {
        return zlansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlansb_$address() {
        return zlansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double zlansb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = zlansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansb_", __norm, __uplo, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlansp_$descriptor() {
        return zlansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlansp_$handle() {
        return zlansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlansp_$address() {
        return zlansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static double zlansp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = zlansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansp_", __norm, __uplo, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlansy_$descriptor() {
        return zlansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlansy_$handle() {
        return zlansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlansy_$address() {
        return zlansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double zlansy_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = zlansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansy_", __norm, __uplo, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlantb_$descriptor() {
        return zlantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlantb_$handle() {
        return zlantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlantb_$address() {
        return zlantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double zlantb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = zlantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantb_", __norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlantp_$descriptor() {
        return zlantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlantp_$handle() {
        return zlantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlantp_$address() {
        return zlantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static double zlantp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = zlantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantp_", __norm, __uplo, __diag, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlantr_$descriptor() {
        return zlantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlantr_$handle() {
        return zlantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal zlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlantr_$address() {
        return zlantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal zlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double zlantr_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = zlantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantr_", __norm, __uplo, __diag, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlapll_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlapll_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlapll_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static FunctionDescriptor zlapll_$descriptor() {
        return zlapll_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlapll_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static MethodHandle zlapll_$handle() {
        return zlapll_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlapll_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static MemorySegment zlapll_$address() {
        return zlapll_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlapll_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static int zlapll_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __ssmin) {
        var mh$ = zlapll_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlapll_", __n, __x, __incx, __y, __incy, __ssmin);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __ssmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static FunctionDescriptor zlapmt_$descriptor() {
        return zlapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MethodHandle zlapmt_$handle() {
        return zlapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MemorySegment zlapmt_$address() {
        return zlapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static int zlapmt_(MemorySegment __forwrd, MemorySegment __m, MemorySegment __n, MemorySegment __x, MemorySegment __ldx, MemorySegment __k) {
        var mh$ = zlapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlapmt_", __forwrd, __m, __n, __x, __ldx, __k);
            }
            return (int)mh$.invokeExact(__forwrd, __m, __n, __x, __ldx, __k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqgb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqgb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqgb_$descriptor() {
        return zlaqgb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqgb_$handle() {
        return zlaqgb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqgb_$address() {
        return zlaqgb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqgb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqgb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqgb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqge_$descriptor() {
        return zlaqge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqge_$handle() {
        return zlaqge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqge_$address() {
        return zlaqge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqge_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqge_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqhb_$descriptor() {
        return zlaqhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqhb_$handle() {
        return zlaqhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqhb_$address() {
        return zlaqhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqhb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqhb_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqhe_$descriptor() {
        return zlaqhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqhe_$handle() {
        return zlaqhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqhe_$address() {
        return zlaqhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqhe_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqhe_", __uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqhp_$descriptor() {
        return zlaqhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqhp_$handle() {
        return zlaqhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqhp_$address() {
        return zlaqhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqhp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqhp_", __uplo, __n, __ap, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__work)
     * }
     */
    public static FunctionDescriptor zlaqp2_$descriptor() {
        return zlaqp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__work)
     * }
     */
    public static MethodHandle zlaqp2_$handle() {
        return zlaqp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__work)
     * }
     */
    public static MemorySegment zlaqp2_$address() {
        return zlaqp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__work)
     * }
     */
    public static int zlaqp2_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __work) {
        var mh$ = zlaqp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqp2_", __m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__auxv, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static FunctionDescriptor zlaqps_$descriptor() {
        return zlaqps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__auxv, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MethodHandle zlaqps_$handle() {
        return zlaqps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__auxv, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MemorySegment zlaqps_$address() {
        return zlaqps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublecomplex *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublecomplex *__auxv, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static int zlaqps_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __auxv, MemorySegment __f, MemorySegment __ldf) {
        var mh$ = zlaqps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqps_", __m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqr0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqr0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlaqr0_$descriptor() {
        return zlaqr0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlaqr0_$handle() {
        return zlaqr0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlaqr0_$address() {
        return zlaqr0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zlaqr0_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zlaqr0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqr0_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqr1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqr1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqr1_(__CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__s1, __CLPK_doublecomplex *__s2, __CLPK_doublecomplex *__v)
     * }
     */
    public static FunctionDescriptor zlaqr1_$descriptor() {
        return zlaqr1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqr1_(__CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__s1, __CLPK_doublecomplex *__s2, __CLPK_doublecomplex *__v)
     * }
     */
    public static MethodHandle zlaqr1_$handle() {
        return zlaqr1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqr1_(__CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__s1, __CLPK_doublecomplex *__s2, __CLPK_doublecomplex *__v)
     * }
     */
    public static MemorySegment zlaqr1_$address() {
        return zlaqr1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqr1_(__CLPK_integer *__n, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__s1, __CLPK_doublecomplex *__s2, __CLPK_doublecomplex *__v)
     * }
     */
    public static int zlaqr1_(MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __s1, MemorySegment __s2, MemorySegment __v) {
        var mh$ = zlaqr1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqr1_", __n, __h__, __ldh, __s1, __s2, __v);
            }
            return (int)mh$.invokeExact(__n, __h__, __ldh, __s1, __s2, __v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor zlaqr2_$descriptor() {
        return zlaqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle zlaqr2_$handle() {
        return zlaqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment zlaqr2_$address() {
        return zlaqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int zlaqr2_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sh, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = zlaqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqr2_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor zlaqr3_$descriptor() {
        return zlaqr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle zlaqr3_$handle() {
        return zlaqr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment zlaqr3_$address() {
        return zlaqr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublecomplex *__sh, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int zlaqr3_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sh, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = zlaqr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqr3_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqr4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqr4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlaqr4_$descriptor() {
        return zlaqr4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlaqr4_$handle() {
        return zlaqr4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlaqr4_$address() {
        return zlaqr4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_doublecomplex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zlaqr4_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zlaqr4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqr4_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqr5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqr5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublecomplex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static FunctionDescriptor zlaqr5_$descriptor() {
        return zlaqr5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublecomplex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MethodHandle zlaqr5_$handle() {
        return zlaqr5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublecomplex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MemorySegment zlaqr5_$address() {
        return zlaqr5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublecomplex *__s, __CLPK_doublecomplex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublecomplex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublecomplex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static int zlaqr5_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __kacc22, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nshfts, MemorySegment __s, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __v, MemorySegment __ldv, MemorySegment __u, MemorySegment __ldu, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __nh, MemorySegment __wh, MemorySegment __ldwh) {
        var mh$ = zlaqr5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqr5_", __wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __s, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __s, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqsb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqsb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqsb_$descriptor() {
        return zlaqsb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqsb_$handle() {
        return zlaqsb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqsb_$address() {
        return zlaqsb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqsb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqsb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqsb_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqsp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqsp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqsp_$descriptor() {
        return zlaqsp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqsp_$handle() {
        return zlaqsp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqsp_$address() {
        return zlaqsp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqsp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqsp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqsp_", __uplo, __n, __ap, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaqsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaqsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor zlaqsy_$descriptor() {
        return zlaqsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle zlaqsy_$handle() {
        return zlaqsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment zlaqsy_$address() {
        return zlaqsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int zlaqsy_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = zlaqsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaqsy_", __uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlar1v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlar1v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublecomplex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor zlar1v_$descriptor() {
        return zlar1v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublecomplex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle zlar1v_$handle() {
        return zlar1v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublecomplex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment zlar1v_$address() {
        return zlar1v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublecomplex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static int zlar1v_(MemorySegment __n, MemorySegment __b1, MemorySegment __bn, MemorySegment __lambda, MemorySegment __d__, MemorySegment __l, MemorySegment __ld, MemorySegment __lld, MemorySegment __pivmin, MemorySegment __gaptol, MemorySegment __z__, MemorySegment __wantnc, MemorySegment __negcnt, MemorySegment __ztz, MemorySegment __mingma, MemorySegment __r__, MemorySegment __isuppz, MemorySegment __nrminv, MemorySegment __resid, MemorySegment __rqcorr, MemorySegment __work) {
        var mh$ = zlar1v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlar1v_", __n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
            }
            return (int)mh$.invokeExact(__n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlar2v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlar2v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlar2v_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor zlar2v_$descriptor() {
        return zlar2v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlar2v_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle zlar2v_$handle() {
        return zlar2v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlar2v_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment zlar2v_$address() {
        return zlar2v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlar2v_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_doublecomplex *__y, __CLPK_doublecomplex *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static int zlar2v_(MemorySegment __n, MemorySegment __x, MemorySegment __y, MemorySegment __z__, MemorySegment __incx, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = zlar2v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlar2v_", __n, __x, __y, __z__, __incx, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __y, __z__, __incx, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarcm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarcm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static FunctionDescriptor zlarcm_$descriptor() {
        return zlarcm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static MethodHandle zlarcm_$handle() {
        return zlarcm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static MemorySegment zlarcm_$address() {
        return zlarcm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__rwork)
     * }
     */
    public static int zlarcm_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __rwork) {
        var mh$ = zlarcm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarcm_", __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static FunctionDescriptor zlarf_$descriptor() {
        return zlarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MethodHandle zlarf_$handle() {
        return zlarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MemorySegment zlarf_$address() {
        return zlarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static int zlarf_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = zlarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarf_", __side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor zlarfb_$descriptor() {
        return zlarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle zlarfb_$handle() {
        return zlarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment zlarfb_$address() {
        return zlarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int zlarfb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = zlarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfb_", __side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarfg_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static FunctionDescriptor zlarfg_$descriptor() {
        return zlarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarfg_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static MethodHandle zlarfg_$handle() {
        return zlarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarfg_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static MemorySegment zlarfg_$address() {
        return zlarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarfg_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static int zlarfg_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = zlarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfg_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarfp_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static FunctionDescriptor zlarfp_$descriptor() {
        return zlarfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarfp_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static MethodHandle zlarfp_$handle() {
        return zlarfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarfp_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static MemorySegment zlarfp_$address() {
        return zlarfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarfp_(__CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__tau)
     * }
     */
    public static int zlarfp_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = zlarfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfp_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor zlarft_$descriptor() {
        return zlarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle zlarft_$handle() {
        return zlarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment zlarft_$address() {
        return zlarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int zlarft_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = zlarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarft_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static FunctionDescriptor zlarfx_$descriptor() {
        return zlarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MethodHandle zlarfx_$handle() {
        return zlarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MemorySegment zlarfx_$address() {
        return zlarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static int zlarfx_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = zlarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfx_", __side, __m, __n, __v, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlargv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlargv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlargv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor zlargv_$descriptor() {
        return zlargv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlargv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle zlargv_$handle() {
        return zlargv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlargv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment zlargv_$address() {
        return zlargv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlargv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static int zlargv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __incc) {
        var mh$ = zlargv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlargv_", __n, __x, __incx, __y, __incy, __c__, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublecomplex *__x)
     * }
     */
    public static FunctionDescriptor zlarnv_$descriptor() {
        return zlarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublecomplex *__x)
     * }
     */
    public static MethodHandle zlarnv_$handle() {
        return zlarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublecomplex *__x)
     * }
     */
    public static MemorySegment zlarnv_$address() {
        return zlarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublecomplex *__x)
     * }
     */
    public static int zlarnv_(MemorySegment __idist, MemorySegment __iseed, MemorySegment __n, MemorySegment __x) {
        var mh$ = zlarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarnv_", __idist, __iseed, __n, __x);
            }
            return (int)mh$.invokeExact(__idist, __iseed, __n, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarrv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarrv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlarrv_$descriptor() {
        return zlarrv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlarrv_$handle() {
        return zlarrv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlarrv_$address() {
        return zlarrv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int zlarrv_(MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __d__, MemorySegment __l, MemorySegment __pivmin, MemorySegment __isplit, MemorySegment __m, MemorySegment __dol, MemorySegment __dou, MemorySegment __minrgp, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __w, MemorySegment __werr, MemorySegment __wgap, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __gers, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = zlarrv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarrv_", __n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarscl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarscl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor zlarscl2_$descriptor() {
        return zlarscl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle zlarscl2_$handle() {
        return zlarscl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment zlarscl2_$address() {
        return zlarscl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int zlarscl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = zlarscl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarscl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlartg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlartg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlartg_(__CLPK_doublecomplex *__f, __CLPK_doublecomplex *__g, __CLPK_doublereal *__cs, __CLPK_doublecomplex *__sn, __CLPK_doublecomplex *__r__)
     * }
     */
    public static FunctionDescriptor zlartg_$descriptor() {
        return zlartg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlartg_(__CLPK_doublecomplex *__f, __CLPK_doublecomplex *__g, __CLPK_doublereal *__cs, __CLPK_doublecomplex *__sn, __CLPK_doublecomplex *__r__)
     * }
     */
    public static MethodHandle zlartg_$handle() {
        return zlartg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlartg_(__CLPK_doublecomplex *__f, __CLPK_doublecomplex *__g, __CLPK_doublereal *__cs, __CLPK_doublecomplex *__sn, __CLPK_doublecomplex *__r__)
     * }
     */
    public static MemorySegment zlartg_$address() {
        return zlartg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlartg_(__CLPK_doublecomplex *__f, __CLPK_doublecomplex *__g, __CLPK_doublereal *__cs, __CLPK_doublecomplex *__sn, __CLPK_doublecomplex *__r__)
     * }
     */
    public static int zlartg_(MemorySegment __f, MemorySegment __g, MemorySegment __cs, MemorySegment __sn, MemorySegment __r__) {
        var mh$ = zlartg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlartg_", __f, __g, __cs, __sn, __r__);
            }
            return (int)mh$.invokeExact(__f, __g, __cs, __sn, __r__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlartv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlartv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlartv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor zlartv_$descriptor() {
        return zlartv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlartv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle zlartv_$handle() {
        return zlartv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlartv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment zlartv_$address() {
        return zlartv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlartv_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s, __CLPK_integer *__incc)
     * }
     */
    public static int zlartv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = zlartv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlartv_", __n, __x, __incx, __y, __incy, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static FunctionDescriptor zlarz_$descriptor() {
        return zlarz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MethodHandle zlarz_$handle() {
        return zlarz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MemorySegment zlarz_$address() {
        return zlarz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static int zlarz_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = zlarz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarz_", __side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarzb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarzb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor zlarzb_$descriptor() {
        return zlarzb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle zlarzb_$handle() {
        return zlarzb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment zlarzb_$address() {
        return zlarzb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int zlarzb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = zlarzb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarzb_", __side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarzt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlarzt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor zlarzt_$descriptor() {
        return zlarzt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle zlarzt_$handle() {
        return zlarzt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment zlarzt_$address() {
        return zlarzt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int zlarzt_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = zlarzt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarzt_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlascl_$descriptor() {
        return zlascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlascl_$handle() {
        return zlascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlascl_$address() {
        return zlascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int zlascl_(MemorySegment __type__, MemorySegment __kl, MemorySegment __ku, MemorySegment __cfrom, MemorySegment __cto, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = zlascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlascl_", __type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlascl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlascl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor zlascl2_$descriptor() {
        return zlascl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle zlascl2_$handle() {
        return zlascl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment zlascl2_$address() {
        return zlascl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int zlascl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = zlascl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlascl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor zlaset_$descriptor() {
        return zlaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle zlaset_$handle() {
        return zlaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment zlaset_$address() {
        return zlaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int zlaset_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __beta, MemorySegment __a, MemorySegment __lda) {
        var mh$ = zlaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaset_", __uplo, __m, __n, __alpha, __beta, __a, __lda);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __alpha, __beta, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlasr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlasr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor zlasr_$descriptor() {
        return zlasr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle zlasr_$handle() {
        return zlasr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment zlasr_$address() {
        return zlasr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int zlasr_(MemorySegment __side, MemorySegment __pivot, MemorySegment __direct, MemorySegment __m, MemorySegment __n, MemorySegment __c__, MemorySegment __s, MemorySegment __a, MemorySegment __lda) {
        var mh$ = zlasr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlasr_", __side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
            }
            return (int)mh$.invokeExact(__side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlassq_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static FunctionDescriptor zlassq_$descriptor() {
        return zlassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlassq_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static MethodHandle zlassq_$handle() {
        return zlassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlassq_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static MemorySegment zlassq_$address() {
        return zlassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlassq_(__CLPK_integer *__n, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static int zlassq_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __scale, MemorySegment __sumsq) {
        var mh$ = zlassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlassq_", __n, __x, __incx, __scale, __sumsq);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __scale, __sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlaswp_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor zlaswp_$descriptor() {
        return zlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlaswp_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle zlaswp_$handle() {
        return zlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlaswp_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment zlaswp_$address() {
        return zlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlaswp_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static int zlaswp_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __k1, MemorySegment __k2, MemorySegment __ipiv, MemorySegment __incx) {
        var mh$ = zlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaswp_", __n, __a, __lda, __k1, __k2, __ipiv, __incx);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __k1, __k2, __ipiv, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlasyf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlasyf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlasyf_$descriptor() {
        return zlasyf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlasyf_$handle() {
        return zlasyf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlasyf_$address() {
        return zlasyf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static int zlasyf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __w, MemorySegment __ldw, MemorySegment __info) {
        var mh$ = zlasyf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlasyf_", __uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlat2c_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlat2c_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlat2c_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlat2c_$descriptor() {
        return zlat2c_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlat2c_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlat2c_$handle() {
        return zlat2c_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlat2c_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlat2c_$address() {
        return zlat2c_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlat2c_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static int zlat2c_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sa, MemorySegment __ldsa, MemorySegment __info) {
        var mh$ = zlat2c_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlat2c_", __uplo, __n, __a, __lda, __sa, __ldsa, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __sa, __ldsa, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatbs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatbs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlatbs_$descriptor() {
        return zlatbs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlatbs_$handle() {
        return zlatbs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlatbs_$address() {
        return zlatbs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int zlatbs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = zlatbs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatbs_", __uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatdf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatdf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static FunctionDescriptor zlatdf_$descriptor() {
        return zlatdf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MethodHandle zlatdf_$handle() {
        return zlatdf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MemorySegment zlatdf_$address() {
        return zlatdf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static int zlatdf_(MemorySegment __ijob, MemorySegment __n, MemorySegment __z__, MemorySegment __ldz, MemorySegment __rhs, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __ipiv, MemorySegment __jpiv) {
        var mh$ = zlatdf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatdf_", __ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
            }
            return (int)mh$.invokeExact(__ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlatps_$descriptor() {
        return zlatps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlatps_$handle() {
        return zlatps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlatps_$address() {
        return zlatps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int zlatps_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __ap, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = zlatps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatps_", __uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static FunctionDescriptor zlatrd_$descriptor() {
        return zlatrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MethodHandle zlatrd_$handle() {
        return zlatrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MemorySegment zlatrd_$address() {
        return zlatrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static int zlatrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __e, MemorySegment __tau, MemorySegment __w, MemorySegment __ldw) {
        var mh$ = zlatrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatrd_", __uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlatrs_$descriptor() {
        return zlatrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlatrs_$handle() {
        return zlatrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlatrs_$address() {
        return zlatrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int zlatrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = zlatrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatrs_", __uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work)
     * }
     */
    public static FunctionDescriptor zlatrz_$descriptor() {
        return zlatrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work)
     * }
     */
    public static MethodHandle zlatrz_$handle() {
        return zlatrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work)
     * }
     */
    public static MemorySegment zlatrz_$address() {
        return zlatrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work)
     * }
     */
    public static int zlatrz_(MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work) {
        var mh$ = zlatrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatrz_", __m, __n, __l, __a, __lda, __tau, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __l, __a, __lda, __tau, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatzm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlatzm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c1, __CLPK_doublecomplex *__c2, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static FunctionDescriptor zlatzm_$descriptor() {
        return zlatzm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c1, __CLPK_doublecomplex *__c2, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MethodHandle zlatzm_$handle() {
        return zlatzm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c1, __CLPK_doublecomplex *__c2, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static MemorySegment zlatzm_$address() {
        return zlatzm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__v, __CLPK_integer *__incv, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c1, __CLPK_doublecomplex *__c2, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work)
     * }
     */
    public static int zlatzm_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c1, MemorySegment __c2, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = zlatzm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatzm_", __side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlauu2_$descriptor() {
        return zlauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlauu2_$handle() {
        return zlauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlauu2_$address() {
        return zlauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int zlauu2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = zlauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlauu2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zlauum_$descriptor() {
        return zlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zlauum_$handle() {
        return zlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zlauum_$address() {
        return zlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int zlauum_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = zlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlauum_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbcon_$descriptor() {
        return zpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbcon_$handle() {
        return zpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbcon_$address() {
        return zpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zpbcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbcon_", __uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbequ_$descriptor() {
        return zpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbequ_$handle() {
        return zpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbequ_$address() {
        return zpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zpbequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbequ_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbrfs_$descriptor() {
        return zpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbrfs_$handle() {
        return zpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbrfs_$address() {
        return zpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zpbrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbrfs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbstf_$descriptor() {
        return zpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbstf_$handle() {
        return zpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbstf_$address() {
        return zpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int zpbstf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = zpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbstf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbsv_$descriptor() {
        return zpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbsv_$handle() {
        return zpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbsv_$address() {
        return zpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zpbsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbsv_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbsvx_$descriptor() {
        return zpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbsvx_$handle() {
        return zpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbsvx_$address() {
        return zpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zpbsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbsvx_", __fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbtf2_$descriptor() {
        return zpbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbtf2_$handle() {
        return zpbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbtf2_$address() {
        return zpbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int zpbtf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = zpbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtf2_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbtrf_$descriptor() {
        return zpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbtrf_$handle() {
        return zpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbtrf_$address() {
        return zpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int zpbtrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = zpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtrf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpbtrs_$descriptor() {
        return zpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpbtrs_$handle() {
        return zpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpbtrs_$address() {
        return zpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zpbtrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtrs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpftrf_$descriptor() {
        return zpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpftrf_$handle() {
        return zpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpftrf_$address() {
        return zpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static int zpftrf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = zpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftrf_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpftri_$descriptor() {
        return zpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpftri_$handle() {
        return zpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpftri_$address() {
        return zpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static int zpftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = zpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftri_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpftrs_$descriptor() {
        return zpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpftrs_$handle() {
        return zpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpftrs_$address() {
        return zpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zpftrs_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftrs_", __transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpocon_$descriptor() {
        return zpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpocon_$handle() {
        return zpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpocon_$address() {
        return zpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zpocon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpocon_", __uplo, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpoequ_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpoequ_$descriptor() {
        return zpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpoequ_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpoequ_$handle() {
        return zpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpoequ_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpoequ_$address() {
        return zpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpoequ_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zpoequ_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpoequ_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpoequb_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpoequb_$descriptor() {
        return zpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpoequb_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpoequb_$handle() {
        return zpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpoequb_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpoequb_$address() {
        return zpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpoequb_(__CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zpoequb_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpoequb_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zporfs_$descriptor() {
        return zporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zporfs_$handle() {
        return zporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zporfs_$address() {
        return zporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zporfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zporfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zposv_$descriptor() {
        return zposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zposv_$handle() {
        return zposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zposv_$address() {
        return zposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zposv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposv_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zposvx_$descriptor() {
        return zposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zposvx_$handle() {
        return zposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zposvx_$address() {
        return zposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zposvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpotf2_$descriptor() {
        return zpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpotf2_$handle() {
        return zpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpotf2_$address() {
        return zpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int zpotf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = zpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotf2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpotrf_$descriptor() {
        return zpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpotrf_$handle() {
        return zpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpotrf_$address() {
        return zpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int zpotrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = zpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrf_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpotri_$descriptor() {
        return zpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpotri_$handle() {
        return zpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpotri_$address() {
        return zpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int zpotri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = zpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotri_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpotrs_$descriptor() {
        return zpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpotrs_$handle() {
        return zpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpotrs_$address() {
        return zpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zpotrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrs_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zppcon_$descriptor() {
        return zppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zppcon_$handle() {
        return zppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zppcon_$address() {
        return zppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zppcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppcon_", __uplo, __n, __ap, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zppequ_$descriptor() {
        return zppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zppequ_$handle() {
        return zppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zppequ_$address() {
        return zppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int zppequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = zppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppequ_", __uplo, __n, __ap, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpprfs_$descriptor() {
        return zpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpprfs_$handle() {
        return zpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpprfs_$address() {
        return zpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zpprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpprfs_", __uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zppsv_$descriptor() {
        return zppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zppsv_$handle() {
        return zppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zppsv_$address() {
        return zppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zppsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppsv_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zppsvx_$descriptor() {
        return zppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zppsvx_$handle() {
        return zppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zppsvx_$address() {
        return zppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zppsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpptrf_$descriptor() {
        return zpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpptrf_$handle() {
        return zpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpptrf_$address() {
        return zpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int zpptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = zpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptrf_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpptri_$descriptor() {
        return zpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpptri_$handle() {
        return zpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpptri_$address() {
        return zpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int zpptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = zpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptri_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpptrs_$descriptor() {
        return zpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpptrs_$handle() {
        return zpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpptrs_$address() {
        return zpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zpptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptrs_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpstf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpstf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpstf2_$descriptor() {
        return zpstf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpstf2_$handle() {
        return zpstf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpstf2_$address() {
        return zpstf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int zpstf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = zpstf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpstf2_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpstrf_$descriptor() {
        return zpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpstrf_$handle() {
        return zpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpstrf_$address() {
        return zpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int zpstrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = zpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpstrf_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zptcon_$descriptor() {
        return zptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zptcon_$handle() {
        return zptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zptcon_$address() {
        return zptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zptcon_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptcon_", __n, __d__, __e, __anorm, __rcond, __rwork, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __anorm, __rcond, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpteqr_$descriptor() {
        return zpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpteqr_$handle() {
        return zpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpteqr_$address() {
        return zpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int zpteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = zpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zptrfs_$descriptor() {
        return zptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zptrfs_$handle() {
        return zptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zptrfs_$address() {
        return zptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zptrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptrfs_", __uplo, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zptsv_$descriptor() {
        return zptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zptsv_$handle() {
        return zptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zptsv_$address() {
        return zptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zptsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptsv_", __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zptsvx_$descriptor() {
        return zptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zptsvx_$handle() {
        return zptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zptsvx_$address() {
        return zptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublereal *__df, __CLPK_doublecomplex *__ef, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zptsvx_(MemorySegment __fact, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptsvx_", __fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpttrf_$descriptor() {
        return zpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpttrf_$handle() {
        return zpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpttrf_$address() {
        return zpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_integer *__info)
     * }
     */
    public static int zpttrf_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = zpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpttrf_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zpttrs_$descriptor() {
        return zpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zpttrs_$handle() {
        return zpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zpttrs_$address() {
        return zpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zpttrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpttrs_", __uplo, __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zptts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor zptts2_$descriptor() {
        return zptts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle zptts2_$handle() {
        return zptts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment zptts2_$address() {
        return zptts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublecomplex *__e, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int zptts2_(MemorySegment __iuplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = zptts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptts2_", __iuplo, __n, __nrhs, __d__, __e, __b, __ldb);
            }
            return (int)mh$.invokeExact(__iuplo, __n, __nrhs, __d__, __e, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zrot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zrot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zrot_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static FunctionDescriptor zrot_$descriptor() {
        return zrot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zrot_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static MethodHandle zrot_$handle() {
        return zrot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zrot_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static MemorySegment zrot_$address() {
        return zrot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zrot_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx, __CLPK_doublecomplex *__cy, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublecomplex *__s)
     * }
     */
    public static int zrot_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx, MemorySegment __cy, MemorySegment __incy, MemorySegment __c__, MemorySegment __s) {
        var mh$ = zrot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zrot_", __n, __cx, __incx, __cy, __incy, __c__, __s);
            }
            return (int)mh$.invokeExact(__n, __cx, __incx, __cy, __incy, __c__, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zspcon_$descriptor() {
        return zspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zspcon_$handle() {
        return zspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zspcon_$address() {
        return zspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zspcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = zspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspcon_", __uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static FunctionDescriptor zspmv_$descriptor() {
        return zspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MethodHandle zspmv_$handle() {
        return zspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MemorySegment zspmv_$address() {
        return zspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static int zspmv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __ap, MemorySegment __x, MemorySegment __incx, MemorySegment __beta, MemorySegment __y, MemorySegment __incy) {
        var mh$ = zspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspmv_", __uplo, __n, __alpha, __ap, __x, __incx, __beta, __y, __incy);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __ap, __x, __incx, __beta, __y, __incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zspr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__ap)
     * }
     */
    public static FunctionDescriptor zspr_$descriptor() {
        return zspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zspr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__ap)
     * }
     */
    public static MethodHandle zspr_$handle() {
        return zspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zspr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__ap)
     * }
     */
    public static MemorySegment zspr_$address() {
        return zspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zspr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__ap)
     * }
     */
    public static int zspr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __ap) {
        var mh$ = zspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspr_", __uplo, __n, __alpha, __x, __incx, __ap);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __x, __incx, __ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsprfs_$descriptor() {
        return zsprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsprfs_$handle() {
        return zsprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsprfs_$address() {
        return zsprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zsprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zsprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsprfs_", __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zspsv_$descriptor() {
        return zspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zspsv_$handle() {
        return zspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zspsv_$address() {
        return zspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zspsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspsv_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zspsvx_$descriptor() {
        return zspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zspsvx_$handle() {
        return zspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zspsvx_$address() {
        return zspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__afp, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zspsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsptrf_$descriptor() {
        return zsptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsptrf_$handle() {
        return zsptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsptrf_$address() {
        return zsptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zsptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zsptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptrf_", __uplo, __n, __ap, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsptri_$descriptor() {
        return zsptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsptri_$handle() {
        return zsptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsptri_$address() {
        return zsptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zsptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = zsptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptri_", __uplo, __n, __ap, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsptrs_$descriptor() {
        return zsptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsptrs_$handle() {
        return zsptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsptrs_$address() {
        return zsptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zsptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zsptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptrs_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zstedc_$descriptor() {
        return zstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zstedc_$handle() {
        return zstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zstedc_$address() {
        return zstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zstedc_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstedc_", __compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zstegr_$descriptor() {
        return zstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zstegr_$handle() {
        return zstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zstegr_$address() {
        return zstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zstegr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstegr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zstein_$descriptor() {
        return zstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zstein_$handle() {
        return zstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zstein_$address() {
        return zstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int zstein_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __m, MemorySegment __w, MemorySegment __iblock, MemorySegment __isplit, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = zstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstein_", __n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zstemr_$descriptor() {
        return zstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zstemr_$handle() {
        return zstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zstemr_$address() {
        return zstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int zstemr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __nzc, MemorySegment __isuppz, MemorySegment __tryrac, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = zstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstemr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsteqr_$descriptor() {
        return zsteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsteqr_$handle() {
        return zsteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsteqr_$address() {
        return zsteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int zsteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = zsteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsycon_$descriptor() {
        return zsycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsycon_$handle() {
        return zsycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsycon_$address() {
        return zsycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zsycon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = zsycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsycon_", __uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsyequb_$descriptor() {
        return zsyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsyequb_$handle() {
        return zsyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsyequb_$address() {
        return zsyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zsyequb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __work, MemorySegment __info) {
        var mh$ = zsyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyequb_", __uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsymv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static FunctionDescriptor zsymv_$descriptor() {
        return zsymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsymv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MethodHandle zsymv_$handle() {
        return zsymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsymv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MemorySegment zsymv_$address() {
        return zsymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsymv_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__y, __CLPK_integer *__incy)
     * }
     */
    public static int zsymv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __a, MemorySegment __lda, MemorySegment __x, MemorySegment __incx, MemorySegment __beta, MemorySegment __y, MemorySegment __incy) {
        var mh$ = zsymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsymv_", __uplo, __n, __alpha, __a, __lda, __x, __incx, __beta, __y, __incy);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __a, __lda, __x, __incx, __beta, __y, __incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsyr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor zsyr_$descriptor() {
        return zsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsyr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle zsyr_$handle() {
        return zsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsyr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment zsyr_$address() {
        return zsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsyr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__x, __CLPK_integer *__incx, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int zsyr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __a, MemorySegment __lda) {
        var mh$ = zsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyr_", __uplo, __n, __alpha, __x, __incx, __a, __lda);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __x, __incx, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsyrfs_$descriptor() {
        return zsyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsyrfs_$handle() {
        return zsyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsyrfs_$address() {
        return zsyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zsyrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zsyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyrfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsysv_$descriptor() {
        return zsysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsysv_$handle() {
        return zsysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsysv_$address() {
        return zsysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zsysv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zsysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsysvx_$descriptor() {
        return zsysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsysvx_$handle() {
        return zsysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsysvx_$address() {
        return zsysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int zsysvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = zsysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsytf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsytf2_$descriptor() {
        return zsytf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsytf2_$handle() {
        return zsytf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsytf2_$address() {
        return zsytf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int zsytf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = zsytf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytf2_", __uplo, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsytrf_$descriptor() {
        return zsytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsytrf_$handle() {
        return zsytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsytrf_$address() {
        return zsytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zsytrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zsytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_", __uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsytri_$descriptor() {
        return zsytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsytri_$handle() {
        return zsytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsytri_$address() {
        return zsytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zsytri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = zsytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri_", __uplo, __n, __a, __lda, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zsytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zsytrs_$descriptor() {
        return zsytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zsytrs_$handle() {
        return zsytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zsytrs_$address() {
        return zsytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int zsytrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = zsytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztbcon_$descriptor() {
        return ztbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztbcon_$handle() {
        return ztbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztbcon_$address() {
        return ztbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztbcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbcon_", __norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztbrfs_$descriptor() {
        return ztbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztbrfs_$handle() {
        return ztbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztbrfs_$address() {
        return ztbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztbrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbrfs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztbtrs_$descriptor() {
        return ztbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztbtrs_$handle() {
        return ztbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztbtrs_$address() {
        return ztbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ab, __CLPK_integer *__ldab, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ztbtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ztbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbtrs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor ztfsm_$descriptor() {
        return ztfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle ztfsm_$handle() {
        return ztfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment ztfsm_$address() {
        return ztfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__a, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int ztfsm_(MemorySegment __transr, MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __a, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = ztfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfsm_", __transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
            }
            return (int)mh$.invokeExact(__transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztftri_$descriptor() {
        return ztftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztftri_$handle() {
        return ztftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztftri_$address() {
        return ztftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__info)
     * }
     */
    public static int ztftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = ztftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztftri_", __transr, __uplo, __diag, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __diag, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztfttp_$descriptor() {
        return ztfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztfttp_$handle() {
        return ztfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztfttp_$address() {
        return ztfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int ztfttp_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __ap, MemorySegment __info) {
        var mh$ = ztfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfttp_", __transr, __uplo, __n, __arf, __ap, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztfttr_$descriptor() {
        return ztfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztfttr_$handle() {
        return ztfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztfttr_$address() {
        return ztfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__arf, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ztfttr_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ztfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfttr_", __transr, __uplo, __n, __arf, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__s, __CLPK_integer *__lds, __CLPK_doublecomplex *__p, __CLPK_integer *__ldp, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgevc_$descriptor() {
        return ztgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__s, __CLPK_integer *__lds, __CLPK_doublecomplex *__p, __CLPK_integer *__ldp, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgevc_$handle() {
        return ztgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__s, __CLPK_integer *__lds, __CLPK_doublecomplex *__p, __CLPK_integer *__ldp, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgevc_$address() {
        return ztgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__s, __CLPK_integer *__lds, __CLPK_doublecomplex *__p, __CLPK_integer *__ldp, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztgevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __s, MemorySegment __lds, MemorySegment __p, MemorySegment __ldp, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgevc_", __side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgex2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgex2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgex2_$descriptor() {
        return ztgex2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgex2_$handle() {
        return ztgex2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgex2_$address() {
        return ztgex2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static int ztgex2_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __j1, MemorySegment __info) {
        var mh$ = ztgex2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgex2_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgexc_$descriptor() {
        return ztgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgexc_$handle() {
        return ztgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgexc_$address() {
        return ztgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static int ztgexc_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __info) {
        var mh$ = ztgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgexc_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgsen_$descriptor() {
        return ztgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgsen_$handle() {
        return ztgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgsen_$address() {
        return ztgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__alpha, __CLPK_doublecomplex *__beta, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ztgsen_(MemorySegment __ijob, MemorySegment __wantq, MemorySegment __wantz, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __m, MemorySegment __pl, MemorySegment __pr, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ztgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsen_", __ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alpha, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alpha, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgsja_$descriptor() {
        return ztgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgsja_$handle() {
        return ztgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgsja_$address() {
        return ztgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublecomplex *__u, __CLPK_integer *__ldu, __CLPK_doublecomplex *__v, __CLPK_integer *__ldv, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static int ztgsja_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __ncycle, MemorySegment __info) {
        var mh$ = ztgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsja_", __jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgsna_$descriptor() {
        return ztgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgsna_$handle() {
        return ztgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgsna_$address() {
        return ztgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ztgsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __dif, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ztgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsna_", __job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgsy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgsy2_$descriptor() {
        return ztgsy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgsy2_$handle() {
        return ztgsy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgsy2_$address() {
        return ztgsy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static int ztgsy2_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __info) {
        var mh$ = ztgsy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsy2_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztgsyl_$descriptor() {
        return ztgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztgsyl_$handle() {
        return ztgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztgsyl_$address() {
        return ztgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__d__, __CLPK_integer *__ldd, __CLPK_doublecomplex *__e, __CLPK_integer *__lde, __CLPK_doublecomplex *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ztgsyl_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ztgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsyl_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztpcon_$descriptor() {
        return ztpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztpcon_$handle() {
        return ztpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztpcon_$address() {
        return ztpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztpcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpcon_", __norm, __uplo, __diag, __n, __ap, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztprfs_$descriptor() {
        return ztprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztprfs_$handle() {
        return ztprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztprfs_$address() {
        return ztprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztprfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztprfs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztptri_$descriptor() {
        return ztptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztptri_$handle() {
        return ztptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztptri_$address() {
        return ztptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int ztptri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = ztptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztptri_", __uplo, __diag, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztptrs_$descriptor() {
        return ztptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztptrs_$handle() {
        return ztptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztptrs_$address() {
        return ztptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ztptrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ztptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztptrs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztpttf_$descriptor() {
        return ztpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztpttf_$handle() {
        return ztpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztpttf_$address() {
        return ztpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static int ztpttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __arf, MemorySegment __info) {
        var mh$ = ztpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpttf_", __transr, __uplo, __n, __ap, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __ap, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztpttr_$descriptor() {
        return ztpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztpttr_$handle() {
        return ztpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztpttr_$address() {
        return ztpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ztpttr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ztpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpttr_", __uplo, __n, __ap, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrcon_$descriptor() {
        return ztrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrcon_$handle() {
        return ztrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrcon_$address() {
        return ztrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztrcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrcon_", __norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrevc_$descriptor() {
        return ztrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrevc_$handle() {
        return ztrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrevc_$address() {
        return ztrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztrevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrevc_", __side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrexc_$descriptor() {
        return ztrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrexc_$handle() {
        return ztrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrexc_$address() {
        return ztrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static int ztrexc_(MemorySegment __compq, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __info) {
        var mh$ = ztrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrexc_", __compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __info);
            }
            return (int)mh$.invokeExact(__compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrrfs_$descriptor() {
        return ztrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrrfs_$handle() {
        return ztrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrrfs_$address() {
        return ztrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublecomplex *__work, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztrrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrrfs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__w, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrsen_$descriptor() {
        return ztrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__w, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrsen_$handle() {
        return ztrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__w, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrsen_$address() {
        return ztrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__w, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ztrsen_(MemorySegment __job, MemorySegment __compq, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __w, MemorySegment __m, MemorySegment __s, MemorySegment __sep, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ztrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsen_", __job, __compq, __select, __n, __t, __ldt, __q, __ldq, __w, __m, __s, __sep, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __select, __n, __t, __ldt, __q, __ldq, __w, __m, __s, __sep, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrsna_$descriptor() {
        return ztrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrsna_$handle() {
        return ztrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrsna_$address() {
        return ztrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublecomplex *__t, __CLPK_integer *__ldt, __CLPK_doublecomplex *__vl, __CLPK_integer *__ldvl, __CLPK_doublecomplex *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublecomplex *__work, __CLPK_integer *__ldwork, __CLPK_doublereal *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ztrsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __sep, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __ldwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ztrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsna_", __job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrsyl_$descriptor() {
        return ztrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrsyl_$handle() {
        return ztrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrsyl_$address() {
        return ztrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static int ztrsyl_(MemorySegment __trana, MemorySegment __tranb, MemorySegment __isgn, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __scale, MemorySegment __info) {
        var mh$ = ztrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsyl_", __trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
            }
            return (int)mh$.invokeExact(__trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrti2_$descriptor() {
        return ztrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrti2_$handle() {
        return ztrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrti2_$address() {
        return ztrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ztrti2_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ztrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrti2_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrtri_$descriptor() {
        return ztrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrtri_$handle() {
        return ztrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrtri_$address() {
        return ztrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ztrtri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ztrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtri_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrtrs_$descriptor() {
        return ztrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrtrs_$handle() {
        return ztrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrtrs_$address() {
        return ztrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ztrtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ztrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtrs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrttf_$descriptor() {
        return ztrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrttf_$handle() {
        return ztrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrttf_$address() {
        return ztrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__arf, __CLPK_integer *__info)
     * }
     */
    public static int ztrttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __arf, MemorySegment __info) {
        var mh$ = ztrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrttf_", __transr, __uplo, __n, __a, __lda, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __lda, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztrttp_$descriptor() {
        return ztrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztrttp_$handle() {
        return ztrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztrttp_$address() {
        return ztrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int ztrttp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ap, MemorySegment __info) {
        var mh$ = ztrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrttp_", __uplo, __n, __a, __lda, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztzrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztzrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztzrqf_$descriptor() {
        return ztzrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztzrqf_$handle() {
        return ztzrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztzrqf_$address() {
        return ztzrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_integer *__info)
     * }
     */
    public static int ztzrqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __info) {
        var mh$ = ztzrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztzrqf_", __m, __n, __a, __lda, __tau, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ztzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ztzrzf_$descriptor() {
        return ztzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ztzrzf_$handle() {
        return ztzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ztzrzf_$address() {
        return ztzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ztzrzf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ztzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztzrzf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zung2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zung2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zung2l_$descriptor() {
        return zung2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zung2l_$handle() {
        return zung2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zung2l_$address() {
        return zung2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zung2l_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zung2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zung2l_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zung2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zung2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zung2r_$descriptor() {
        return zung2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zung2r_$handle() {
        return zung2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zung2r_$address() {
        return zung2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zung2r_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zung2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zung2r_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungbr_$descriptor() {
        return zungbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungbr_$handle() {
        return zungbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungbr_$address() {
        return zungbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zungbr_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zungbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungbr_", __vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunghr_$descriptor() {
        return zunghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunghr_$handle() {
        return zunghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunghr_$address() {
        return zunghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunghr_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunghr_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungl2_$descriptor() {
        return zungl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungl2_$handle() {
        return zungl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungl2_$address() {
        return zungl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zungl2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zungl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungl2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunglq_$descriptor() {
        return zunglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunglq_$handle() {
        return zunglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunglq_$address() {
        return zunglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunglq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunglq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungql_$descriptor() {
        return zungql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungql_$handle() {
        return zungql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungql_$address() {
        return zungql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zungql_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zungql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungql_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungqr_$descriptor() {
        return zungqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungqr_$handle() {
        return zungqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungqr_$address() {
        return zungqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zungqr_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zungqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungqr_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungr2_$descriptor() {
        return zungr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungr2_$handle() {
        return zungr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungr2_$address() {
        return zungr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zungr2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = zungr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungr2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungrq_$descriptor() {
        return zungrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungrq_$handle() {
        return zungrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungrq_$address() {
        return zungrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zungrq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zungrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungrq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zungtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zungtr_$descriptor() {
        return zungtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zungtr_$handle() {
        return zungtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zungtr_$address() {
        return zungtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zungtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zungtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungtr_", __uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunm2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunm2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunm2l_$descriptor() {
        return zunm2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunm2l_$handle() {
        return zunm2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunm2l_$address() {
        return zunm2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zunm2l_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = zunm2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunm2l_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunm2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunm2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunm2r_$descriptor() {
        return zunm2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunm2r_$handle() {
        return zunm2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunm2r_$address() {
        return zunm2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zunm2r_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = zunm2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunm2r_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmbr_$descriptor() {
        return zunmbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmbr_$handle() {
        return zunmbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmbr_$address() {
        return zunmbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmbr_(MemorySegment __vect, MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmbr_", __vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmhr_$descriptor() {
        return zunmhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmhr_$handle() {
        return zunmhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmhr_$address() {
        return zunmhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmhr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmhr_", __side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunml2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunml2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunml2_$descriptor() {
        return zunml2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunml2_$handle() {
        return zunml2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunml2_$address() {
        return zunml2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zunml2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = zunml2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunml2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmlq_$descriptor() {
        return zunmlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmlq_$handle() {
        return zunmlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmlq_$address() {
        return zunmlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmlq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmlq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmql_$descriptor() {
        return zunmql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmql_$handle() {
        return zunmql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmql_$address() {
        return zunmql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmql_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmql_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmqr_$descriptor() {
        return zunmqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmqr_$handle() {
        return zunmqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmqr_$address() {
        return zunmqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmqr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmqr_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmr2_$descriptor() {
        return zunmr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmr2_$handle() {
        return zunmr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmr2_$address() {
        return zunmr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zunmr2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = zunmr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmr2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmr3_$descriptor() {
        return zunmr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmr3_$handle() {
        return zunmr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmr3_$address() {
        return zunmr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zunmr3_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = zunmr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmr3_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmrq_$descriptor() {
        return zunmrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmrq_$handle() {
        return zunmrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmrq_$address() {
        return zunmrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmrq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmrq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmrz_$descriptor() {
        return zunmrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmrz_$handle() {
        return zunmrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmrz_$address() {
        return zunmrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmrz_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmrz_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zunmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zunmtr_$descriptor() {
        return zunmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zunmtr_$handle() {
        return zunmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zunmtr_$address() {
        return zunmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int zunmtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = zunmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmtr_", __side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zupgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zupgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zupgtr_$descriptor() {
        return zupgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zupgtr_$handle() {
        return zupgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zupgtr_$address() {
        return zupgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__q, __CLPK_integer *__ldq, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zupgtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = zupgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zupgtr_", __uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zupmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("zupmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor zupmtr_$descriptor() {
        return zupmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle zupmtr_$handle() {
        return zupmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment zupmtr_$address() {
        return zupmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__ap, __CLPK_doublecomplex *__tau, __CLPK_doublecomplex *__c__, __CLPK_integer *__ldc, __CLPK_doublecomplex *__work, __CLPK_integer *__info)
     * }
     */
    public static int zupmtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = zupmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zupmtr_", __side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamc1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamc1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static FunctionDescriptor dlamc1_$descriptor() {
        return dlamc1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static MethodHandle dlamc1_$handle() {
        return dlamc1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static MemorySegment dlamc1_$address() {
        return dlamc1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static int dlamc1_(MemorySegment __beta, MemorySegment __t, MemorySegment __rnd, MemorySegment __ieee1) {
        var mh$ = dlamc1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamc1_", __beta, __t, __rnd, __ieee1);
            }
            return (int)mh$.invokeExact(__beta, __t, __rnd, __ieee1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slamch_(char *__cmach)
     * }
     */
    public static FunctionDescriptor slamch_$descriptor() {
        return slamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slamch_(char *__cmach)
     * }
     */
    public static MethodHandle slamch_$handle() {
        return slamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slamch_(char *__cmach)
     * }
     */
    public static MemorySegment slamch_$address() {
        return slamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slamch_(char *__cmach)
     * }
     */
    public static double slamch_(MemorySegment __cmach) {
        var mh$ = slamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamch_", __cmach);
            }
            return (double)mh$.invokeExact(__cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamc1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamc1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static FunctionDescriptor slamc1_$descriptor() {
        return slamc1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static MethodHandle slamc1_$handle() {
        return slamc1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static MemorySegment slamc1_$address() {
        return slamc1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slamc1_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_logical *__ieee1)
     * }
     */
    public static int slamc1_(MemorySegment __beta, MemorySegment __t, MemorySegment __rnd, MemorySegment __ieee1) {
        var mh$ = slamc1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamc1_", __beta, __t, __rnd, __ieee1);
            }
            return (int)mh$.invokeExact(__beta, __t, __rnd, __ieee1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_real *__eps, __CLPK_integer *__emin, __CLPK_real *__rmin, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static FunctionDescriptor slamc2_$descriptor() {
        return slamc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_real *__eps, __CLPK_integer *__emin, __CLPK_real *__rmin, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static MethodHandle slamc2_$handle() {
        return slamc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_real *__eps, __CLPK_integer *__emin, __CLPK_real *__rmin, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static MemorySegment slamc2_$address() {
        return slamc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_real *__eps, __CLPK_integer *__emin, __CLPK_real *__rmin, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static int slamc2_(MemorySegment __beta, MemorySegment __t, MemorySegment __rnd, MemorySegment __eps, MemorySegment __emin, MemorySegment __rmin, MemorySegment __emax, MemorySegment __rmax) {
        var mh$ = slamc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamc2_", __beta, __t, __rnd, __eps, __emin, __rmin, __emax, __rmax);
            }
            return (int)mh$.invokeExact(__beta, __t, __rnd, __eps, __emin, __rmin, __emax, __rmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slamc3_(__CLPK_real *__a, __CLPK_real *__b)
     * }
     */
    public static FunctionDescriptor slamc3_$descriptor() {
        return slamc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slamc3_(__CLPK_real *__a, __CLPK_real *__b)
     * }
     */
    public static MethodHandle slamc3_$handle() {
        return slamc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slamc3_(__CLPK_real *__a, __CLPK_real *__b)
     * }
     */
    public static MemorySegment slamc3_$address() {
        return slamc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slamc3_(__CLPK_real *__a, __CLPK_real *__b)
     * }
     */
    public static double slamc3_(MemorySegment __a, MemorySegment __b) {
        var mh$ = slamc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamc3_", __a, __b);
            }
            return (double)mh$.invokeExact(__a, __b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamc4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamc4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slamc4_(__CLPK_integer *__emin, __CLPK_real *__start, __CLPK_integer *__base)
     * }
     */
    public static FunctionDescriptor slamc4_$descriptor() {
        return slamc4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slamc4_(__CLPK_integer *__emin, __CLPK_real *__start, __CLPK_integer *__base)
     * }
     */
    public static MethodHandle slamc4_$handle() {
        return slamc4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slamc4_(__CLPK_integer *__emin, __CLPK_real *__start, __CLPK_integer *__base)
     * }
     */
    public static MemorySegment slamc4_$address() {
        return slamc4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slamc4_(__CLPK_integer *__emin, __CLPK_real *__start, __CLPK_integer *__base)
     * }
     */
    public static int slamc4_(MemorySegment __emin, MemorySegment __start, MemorySegment __base) {
        var mh$ = slamc4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamc4_", __emin, __start, __base);
            }
            return (int)mh$.invokeExact(__emin, __start, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamc5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamc5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static FunctionDescriptor slamc5_$descriptor() {
        return slamc5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static MethodHandle slamc5_$handle() {
        return slamc5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static MemorySegment slamc5_$address() {
        return slamc5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_real *__rmax)
     * }
     */
    public static int slamc5_(MemorySegment __beta, MemorySegment __p, MemorySegment __emin, MemorySegment __ieee, MemorySegment __emax, MemorySegment __rmax) {
        var mh$ = slamc5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamc5_", __beta, __p, __emin, __ieee, __emax, __rmax);
            }
            return (int)mh$.invokeExact(__beta, __p, __emin, __ieee, __emax, __rmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlamch_(char *__cmach)
     * }
     */
    public static FunctionDescriptor dlamch_$descriptor() {
        return dlamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlamch_(char *__cmach)
     * }
     */
    public static MethodHandle dlamch_$handle() {
        return dlamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlamch_(char *__cmach)
     * }
     */
    public static MemorySegment dlamch_$address() {
        return dlamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlamch_(char *__cmach)
     * }
     */
    public static double dlamch_(MemorySegment __cmach) {
        var mh$ = dlamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamch_", __cmach);
            }
            return (double)mh$.invokeExact(__cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_doublereal *__eps, __CLPK_integer *__emin, __CLPK_doublereal *__rmin, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static FunctionDescriptor dlamc2_$descriptor() {
        return dlamc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_doublereal *__eps, __CLPK_integer *__emin, __CLPK_doublereal *__rmin, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static MethodHandle dlamc2_$handle() {
        return dlamc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_doublereal *__eps, __CLPK_integer *__emin, __CLPK_doublereal *__rmin, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static MemorySegment dlamc2_$address() {
        return dlamc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlamc2_(__CLPK_integer *__beta, __CLPK_integer *__t, __CLPK_logical *__rnd, __CLPK_doublereal *__eps, __CLPK_integer *__emin, __CLPK_doublereal *__rmin, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static int dlamc2_(MemorySegment __beta, MemorySegment __t, MemorySegment __rnd, MemorySegment __eps, MemorySegment __emin, MemorySegment __rmin, MemorySegment __emax, MemorySegment __rmax) {
        var mh$ = dlamc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamc2_", __beta, __t, __rnd, __eps, __emin, __rmin, __emax, __rmax);
            }
            return (int)mh$.invokeExact(__beta, __t, __rnd, __eps, __emin, __rmin, __emax, __rmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlamc3_(__CLPK_doublereal *__a, __CLPK_doublereal *__b)
     * }
     */
    public static FunctionDescriptor dlamc3_$descriptor() {
        return dlamc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlamc3_(__CLPK_doublereal *__a, __CLPK_doublereal *__b)
     * }
     */
    public static MethodHandle dlamc3_$handle() {
        return dlamc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlamc3_(__CLPK_doublereal *__a, __CLPK_doublereal *__b)
     * }
     */
    public static MemorySegment dlamc3_$address() {
        return dlamc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlamc3_(__CLPK_doublereal *__a, __CLPK_doublereal *__b)
     * }
     */
    public static double dlamc3_(MemorySegment __a, MemorySegment __b) {
        var mh$ = dlamc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamc3_", __a, __b);
            }
            return (double)mh$.invokeExact(__a, __b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamc4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamc4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlamc4_(__CLPK_integer *__emin, __CLPK_doublereal *__start, __CLPK_integer *__base)
     * }
     */
    public static FunctionDescriptor dlamc4_$descriptor() {
        return dlamc4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlamc4_(__CLPK_integer *__emin, __CLPK_doublereal *__start, __CLPK_integer *__base)
     * }
     */
    public static MethodHandle dlamc4_$handle() {
        return dlamc4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlamc4_(__CLPK_integer *__emin, __CLPK_doublereal *__start, __CLPK_integer *__base)
     * }
     */
    public static MemorySegment dlamc4_$address() {
        return dlamc4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlamc4_(__CLPK_integer *__emin, __CLPK_doublereal *__start, __CLPK_integer *__base)
     * }
     */
    public static int dlamc4_(MemorySegment __emin, MemorySegment __start, MemorySegment __base) {
        var mh$ = dlamc4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamc4_", __emin, __start, __base);
            }
            return (int)mh$.invokeExact(__emin, __start, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamc5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamc5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static FunctionDescriptor dlamc5_$descriptor() {
        return dlamc5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static MethodHandle dlamc5_$handle() {
        return dlamc5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static MemorySegment dlamc5_$address() {
        return dlamc5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlamc5_(__CLPK_integer *__beta, __CLPK_integer *__p, __CLPK_integer *__emin, __CLPK_logical *__ieee, __CLPK_integer *__emax, __CLPK_doublereal *__rmax)
     * }
     */
    public static int dlamc5_(MemorySegment __beta, MemorySegment __p, MemorySegment __emin, MemorySegment __ieee, MemorySegment __emax, MemorySegment __rmax) {
        var mh$ = dlamc5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamc5_", __beta, __p, __emin, __ieee, __emax, __rmax);
            }
            return (int)mh$.invokeExact(__beta, __p, __emin, __ieee, __emax, __rmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

