// Generated by jextract

package smile.linalg.lapack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class clapack_h_1 {

    clapack_h_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final String OS = System.getProperty("os.name", "linux").toLowerCase().split(" ")[0];
    static final String LIBRARY_NAME = System.getProperty("smile.lib.lapack", switch (OS) {
        case "mac" -> "lapack"; // macOS's builtin Accelerate framework
        case "windows" -> "mkl_rt.2"; // Intel's MKL
        default -> "openblas"; // OpenBLAS
    });
    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName(LIBRARY_NAME), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __CLPK_integer
     * }
     */
    public static final OfInt __CLPK_integer = clapack_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __CLPK_logical
     * }
     */
    public static final OfInt __CLPK_logical = clapack_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float __CLPK_real
     * }
     */
    public static final OfFloat __CLPK_real = clapack_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double __CLPK_doublereal
     * }
     */
    public static final OfDouble __CLPK_doublereal = clapack_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef int __CLPK_ftnlen
     * }
     */
    public static final OfInt __CLPK_ftnlen = clapack_h.C_INT;

    private static class cbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cbdsqr_$descriptor() {
        return cbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cbdsqr_$handle() {
        return cbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cbdsqr_$address() {
        return cbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cbdsqr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ncvt, MemorySegment __nru, MemorySegment __ncc, MemorySegment __d__, MemorySegment __e, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __u, MemorySegment __ldu, MemorySegment __c__, MemorySegment __ldc, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbdsqr_", __uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__pt, __CLPK_integer *__ldpt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbbrd_$descriptor() {
        return cgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__pt, __CLPK_integer *__ldpt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbbrd_$handle() {
        return cgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__pt, __CLPK_integer *__ldpt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbbrd_$address() {
        return cgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__pt, __CLPK_integer *__ldpt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgbbrd_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __ncc, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __pt, MemorySegment __ldpt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbbrd_", __vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbcon_$descriptor() {
        return cgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbcon_$handle() {
        return cgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbcon_$address() {
        return cgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgbcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbcon_", __norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbequ_$descriptor() {
        return cgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbequ_$handle() {
        return cgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbequ_$address() {
        return cgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cgbequ_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbequ_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbequb_$descriptor() {
        return cgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbequb_$handle() {
        return cgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbequb_$address() {
        return cgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cgbequb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbequb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbrfs_$descriptor() {
        return cgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbrfs_$handle() {
        return cgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbrfs_$address() {
        return cgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgbrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbrfs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbsv_$descriptor() {
        return cgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbsv_$handle() {
        return cgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbsv_$address() {
        return cgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cgbsv_(MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsv_", __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbsvx_$descriptor() {
        return cgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbsvx_$handle() {
        return cgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbsvx_$address() {
        return cgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgbsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsvx_", __fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbtf2_$descriptor() {
        return cgbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbtf2_$handle() {
        return cgbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbtf2_$address() {
        return cgbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int cgbtf2_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = cgbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtf2_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbtrf_$descriptor() {
        return cgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbtrf_$handle() {
        return cgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbtrf_$address() {
        return cgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int cgbtrf_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = cgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtrf_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgbtrs_$descriptor() {
        return cgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgbtrs_$handle() {
        return cgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgbtrs_$address() {
        return cgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cgbtrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtrs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgebak_$descriptor() {
        return cgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgebak_$handle() {
        return cgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgebak_$address() {
        return cgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int cgebak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = cgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebak_", __job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgebal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgebal_$descriptor() {
        return cgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgebal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgebal_$handle() {
        return cgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgebal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgebal_$address() {
        return cgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgebal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static int cgebal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __info) {
        var mh$ = cgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebal_", __job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgebd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgebd2_$descriptor() {
        return cgebd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgebd2_$handle() {
        return cgebd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgebd2_$address() {
        return cgebd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgebd2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgebd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebd2_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgebrd_$descriptor() {
        return cgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgebrd_$handle() {
        return cgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgebrd_$address() {
        return cgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgebrd_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebrd_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgecon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgecon_$descriptor() {
        return cgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgecon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgecon_$handle() {
        return cgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgecon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgecon_$address() {
        return cgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgecon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgecon_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgecon_", __norm, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeequ_$descriptor() {
        return cgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeequ_$handle() {
        return cgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeequ_$address() {
        return cgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cgeequ_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeequ_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeequb_$descriptor() {
        return cgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeequb_$handle() {
        return cgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeequb_$address() {
        return cgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cgeequb_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeequb_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgees_$descriptor() {
        return cgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgees_$handle() {
        return cgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgees_$address() {
        return cgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int cgees_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __w, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = cgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgees_", __jobvs, __sort, __select, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __work, __lwork, __rwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __work, __lwork, __rwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeesx_$descriptor() {
        return cgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeesx_$handle() {
        return cgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeesx_$address() {
        return cgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeesx_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __w, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = cgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeesx_", __jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __rwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __w, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __rwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeev_$descriptor() {
        return cgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeev_$handle() {
        return cgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeev_$address() {
        return cgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeev_", __jobvl, __jobvr, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeevx_$descriptor() {
        return cgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeevx_$handle() {
        return cgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeevx_$address() {
        return cgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __abnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __w, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgegs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgegs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgegs_$descriptor() {
        return cgegs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgegs_$handle() {
        return cgegs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgegs_$address() {
        return cgegs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgegs_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgegs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgegs_", __jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgegv_$descriptor() {
        return cgegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgegv_$handle() {
        return cgegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgegv_$address() {
        return cgegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgegv_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgegv_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgehd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgehd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgehd2_$descriptor() {
        return cgehd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgehd2_$handle() {
        return cgehd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgehd2_$address() {
        return cgehd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgehd2_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgehd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgehd2_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgehrd_$descriptor() {
        return cgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgehrd_$handle() {
        return cgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgehrd_$address() {
        return cgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgehrd_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgehrd_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgelq2_$descriptor() {
        return cgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgelq2_$handle() {
        return cgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgelq2_$address() {
        return cgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgelq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgelqf_$descriptor() {
        return cgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgelqf_$handle() {
        return cgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgelqf_$address() {
        return cgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgelqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgels_$descriptor() {
        return cgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgels_$handle() {
        return cgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgels_$address() {
        return cgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgels_(MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgels_", __trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgelsd_$descriptor() {
        return cgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgelsd_$handle() {
        return cgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgelsd_$address() {
        return cgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int cgelsd_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = cgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsd_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgelss_$descriptor() {
        return cgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgelss_$handle() {
        return cgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgelss_$address() {
        return cgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgelss_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelss_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgelsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgelsx_$descriptor() {
        return cgelsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgelsx_$handle() {
        return cgelsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgelsx_$address() {
        return cgelsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgelsx_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgelsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsx_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgelsy_$descriptor() {
        return cgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgelsy_$handle() {
        return cgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgelsy_$address() {
        return cgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgelsy_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsy_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeql2_$descriptor() {
        return cgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeql2_$handle() {
        return cgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeql2_$address() {
        return cgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgeql2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeql2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeqlf_$descriptor() {
        return cgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeqlf_$handle() {
        return cgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeqlf_$address() {
        return cgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeqlf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqlf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeqp3_$descriptor() {
        return cgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeqp3_$handle() {
        return cgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeqp3_$address() {
        return cgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeqp3_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqp3_", __m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeqpf_$descriptor() {
        return cgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeqpf_$handle() {
        return cgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeqpf_$address() {
        return cgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeqpf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqpf_", __m, __n, __a, __lda, __jpvt, __tau, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeqr2_$descriptor() {
        return cgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeqr2_$handle() {
        return cgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeqr2_$address() {
        return cgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgeqr2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqr2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgeqrf_$descriptor() {
        return cgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgeqrf_$handle() {
        return cgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgeqrf_$address() {
        return cgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgeqrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgerfs_$descriptor() {
        return cgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgerfs_$handle() {
        return cgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgerfs_$address() {
        return cgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgerfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerfs_", __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgerq2_$descriptor() {
        return cgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgerq2_$handle() {
        return cgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgerq2_$address() {
        return cgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgerq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgerqf_$descriptor() {
        return cgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgerqf_$handle() {
        return cgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgerqf_$address() {
        return cgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgerqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgesc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgesc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static FunctionDescriptor cgesc2_$descriptor() {
        return cgesc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgesc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static MethodHandle cgesc2_$handle() {
        return cgesc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgesc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static MemorySegment cgesc2_$address() {
        return cgesc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgesc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static int cgesc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rhs, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __scale) {
        var mh$ = cgesc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesc2_", __n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgesdd_$descriptor() {
        return cgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgesdd_$handle() {
        return cgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgesdd_$address() {
        return cgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int cgesdd_(MemorySegment __jobz, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = cgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesdd_", __jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgesv_$descriptor() {
        return cgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgesv_$handle() {
        return cgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgesv_$address() {
        return cgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cgesv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesv_", __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgesvd_$descriptor() {
        return cgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgesvd_$handle() {
        return cgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgesvd_$address() {
        return cgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgesvd_(MemorySegment __jobu, MemorySegment __jobvt, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvd_", __jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgesvx_$descriptor() {
        return cgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgesvx_$handle() {
        return cgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgesvx_$address() {
        return cgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgesvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvx_", __fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgetc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgetc2_$descriptor() {
        return cgetc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgetc2_$handle() {
        return cgetc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgetc2_$address() {
        return cgetc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static int cgetc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __info) {
        var mh$ = cgetc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetc2_", __n, __a, __lda, __ipiv, __jpiv, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __jpiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgetf2_$descriptor() {
        return cgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgetf2_$handle() {
        return cgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgetf2_$address() {
        return cgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int cgetf2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = cgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetf2_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgetrf_$descriptor() {
        return cgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgetrf_$handle() {
        return cgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgetrf_$address() {
        return cgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int cgetrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = cgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrf_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetri_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgetri_$descriptor() {
        return cgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetri_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgetri_$handle() {
        return cgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetri_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgetri_$address() {
        return cgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetri_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgetri_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetri_", __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgetrs_$descriptor() {
        return cgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgetrs_$handle() {
        return cgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgetrs_$address() {
        return cgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cgetrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrs_", __trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggbak_$descriptor() {
        return cggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggbak_$handle() {
        return cggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggbak_$address() {
        return cggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int cggbak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = cggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggbak_", __job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggbal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggbal_$descriptor() {
        return cggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggbal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggbal_$handle() {
        return cggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggbal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggbal_$address() {
        return cggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggbal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int cggbal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __work, MemorySegment __info) {
        var mh$ = cggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggbal_", __job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgges_$descriptor() {
        return cgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgges_$handle() {
        return cgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgges_$address() {
        return cgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int cgges_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = cgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgges_", __jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __rwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggesx_$descriptor() {
        return cggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggesx_$handle() {
        return cggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggesx_$address() {
        return cggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int cggesx_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = cggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggesx_", __jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __liwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alpha, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __liwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggev_$descriptor() {
        return cggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggev_$handle() {
        return cggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggev_$address() {
        return cggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cggev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggev_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggevx_$descriptor() {
        return cggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggevx_$handle() {
        return cggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggevx_$address() {
        return cggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int cggevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __abnrm, MemorySegment __bbnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = cggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alpha, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __rwork, __iwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggglm_$descriptor() {
        return cggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggglm_$handle() {
        return cggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggglm_$address() {
        return cggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cggglm_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __d__, MemorySegment __x, MemorySegment __y, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggglm_", __n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgghrd_$descriptor() {
        return cgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgghrd_$handle() {
        return cgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgghrd_$address() {
        return cgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int cgghrd_(MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = cgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgghrd_", __compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgglse_$descriptor() {
        return cgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgglse_$handle() {
        return cgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgglse_$address() {
        return cgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_complex *__d__, __CLPK_complex *__x, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cgglse_(MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __d__, MemorySegment __x, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgglse_", __m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggqrf_$descriptor() {
        return cggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggqrf_$handle() {
        return cggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggqrf_$address() {
        return cggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cggqrf_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggqrf_", __n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggrqf_$descriptor() {
        return cggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggrqf_$handle() {
        return cggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggrqf_$address() {
        return cggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cggrqf_(MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggrqf_", __m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggsvd_$descriptor() {
        return cggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggsvd_$handle() {
        return cggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggsvd_$address() {
        return cggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int cggsvd_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = cggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvd_", __jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__rwork, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cggsvp_$descriptor() {
        return cggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__rwork, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cggsvp_$handle() {
        return cggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__rwork, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cggsvp_$address() {
        return cggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__rwork, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cggsvp_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __k, MemorySegment __l, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __iwork, MemorySegment __rwork, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvp_", __jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __rwork, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __rwork, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgtcon_$descriptor() {
        return cgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgtcon_$handle() {
        return cgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgtcon_$address() {
        return cgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cgtcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = cgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtcon_", __norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgtrfs_$descriptor() {
        return cgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgtrfs_$handle() {
        return cgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgtrfs_$address() {
        return cgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgtrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtrfs_", __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgtsv_$descriptor() {
        return cgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgtsv_$handle() {
        return cgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgtsv_$address() {
        return cgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cgtsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtsv_", __n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgtsvx_$descriptor() {
        return cgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgtsvx_$handle() {
        return cgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgtsvx_$address() {
        return cgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cgtsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtsvx_", __fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgttrf_(__CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgttrf_$descriptor() {
        return cgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgttrf_(__CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgttrf_$handle() {
        return cgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgttrf_(__CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgttrf_$address() {
        return cgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgttrf_(__CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int cgttrf_(MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = cgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgttrf_", __n, __dl, __d__, __du, __du2, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__n, __dl, __d__, __du, __du2, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cgttrs_$descriptor() {
        return cgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cgttrs_$handle() {
        return cgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cgttrs_$address() {
        return cgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cgttrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgttrs_", __trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cgtts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor cgtts2_$descriptor() {
        return cgtts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle cgtts2_$handle() {
        return cgtts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment cgtts2_$address() {
        return cgtts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int cgtts2_(MemorySegment __itrans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = cgtts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtts2_", __itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
            }
            return (int)mh$.invokeExact(__itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbev_$descriptor() {
        return chbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbev_$handle() {
        return chbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbev_$address() {
        return chbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chbev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbev_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbevd_$descriptor() {
        return chbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbevd_$handle() {
        return chbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbevd_$address() {
        return chbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int chbevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = chbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevd_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbevx_$descriptor() {
        return chbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbevx_$handle() {
        return chbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbevx_$address() {
        return chbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int chbevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = chbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevx_", __jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbgst_$descriptor() {
        return chbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbgst_$handle() {
        return chbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbgst_$address() {
        return chbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chbgst_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgst_", __vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbgv_$descriptor() {
        return chbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbgv_$handle() {
        return chbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbgv_$address() {
        return chbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chbgv_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgv_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbgvd_$descriptor() {
        return chbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbgvd_$handle() {
        return chbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbgvd_$address() {
        return chbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int chbgvd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = chbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgvd_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbgvx_$descriptor() {
        return chbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbgvx_$handle() {
        return chbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbgvx_$address() {
        return chbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int chbgvx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = chbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgvx_", __jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chbtrd_$descriptor() {
        return chbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chbtrd_$handle() {
        return chbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chbtrd_$address() {
        return chbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int chbtrd_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = chbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbtrd_", __vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("checon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor checon_$descriptor() {
        return checon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle checon_$handle() {
        return checon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment checon_$address() {
        return checon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int checon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = checon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checon_", __uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cheequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cheequb_$descriptor() {
        return cheequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cheequb_$handle() {
        return cheequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cheequb_$address() {
        return cheequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cheequb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __work, MemorySegment __info) {
        var mh$ = cheequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheequb_", __uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cheev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cheev_$descriptor() {
        return cheev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cheev_$handle() {
        return cheev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cheev_$address() {
        return cheev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cheev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cheev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheev_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cheevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cheevd_$descriptor() {
        return cheevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cheevd_$handle() {
        return cheevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cheevd_$address() {
        return cheevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int cheevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = cheevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevd_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cheevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cheevr_$descriptor() {
        return cheevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cheevr_$handle() {
        return cheevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cheevr_$address() {
        return cheevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int cheevr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = cheevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevr_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cheevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cheevx_$descriptor() {
        return cheevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cheevx_$handle() {
        return cheevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cheevx_$address() {
        return cheevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int cheevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = cheevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevx_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chegs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chegs2_$descriptor() {
        return chegs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chegs2_$handle() {
        return chegs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chegs2_$address() {
        return chegs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int chegs2_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = chegs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegs2_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chegst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chegst_$descriptor() {
        return chegst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chegst_$handle() {
        return chegst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chegst_$address() {
        return chegst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int chegst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = chegst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegst_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chegv_$descriptor() {
        return chegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chegv_$handle() {
        return chegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chegv_$address() {
        return chegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chegv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegv_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chegvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chegvd_$descriptor() {
        return chegvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chegvd_$handle() {
        return chegvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chegvd_$address() {
        return chegvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int chegvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = chegvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegvd_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chegvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chegvx_$descriptor() {
        return chegvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chegvx_$handle() {
        return chegvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chegvx_$address() {
        return chegvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int chegvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = chegvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegvx_", __itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cherfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cherfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cherfs_$descriptor() {
        return cherfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cherfs_$handle() {
        return cherfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cherfs_$address() {
        return cherfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cherfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cherfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cherfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chesv_$descriptor() {
        return chesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chesv_$handle() {
        return chesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chesv_$address() {
        return chesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int chesv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = chesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chesvx_$descriptor() {
        return chesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chesvx_$handle() {
        return chesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chesvx_$address() {
        return chesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chesvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chesvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chetd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chetd2_$descriptor() {
        return chetd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chetd2_$handle() {
        return chetd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chetd2_$address() {
        return chetd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static int chetd2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = chetd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetd2_", __uplo, __n, __a, __lda, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chetf2_$descriptor() {
        return chetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chetf2_$handle() {
        return chetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chetf2_$address() {
        return chetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int chetf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = chetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetf2_", __uplo, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chetrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chetrd_$descriptor() {
        return chetrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chetrd_$handle() {
        return chetrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chetrd_$address() {
        return chetrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int chetrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = chetrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrd_", __uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chetrf_$descriptor() {
        return chetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chetrf_$handle() {
        return chetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chetrf_$address() {
        return chetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int chetrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = chetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_", __uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chetri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chetri_$descriptor() {
        return chetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chetri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chetri_$handle() {
        return chetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chetri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chetri_$address() {
        return chetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chetri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int chetri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = chetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri_", __uplo, __n, __a, __lda, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chetrs_$descriptor() {
        return chetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chetrs_$handle() {
        return chetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chetrs_$address() {
        return chetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int chetrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = chetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_complex *__c__)
     * }
     */
    public static FunctionDescriptor chfrk_$descriptor() {
        return chfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_complex *__c__)
     * }
     */
    public static MethodHandle chfrk_$handle() {
        return chfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_complex *__c__)
     * }
     */
    public static MemorySegment chfrk_$address() {
        return chfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__beta, __CLPK_complex *__c__)
     * }
     */
    public static int chfrk_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __trans, MemorySegment __n, MemorySegment __k, MemorySegment __alpha, MemorySegment __a, MemorySegment __lda, MemorySegment __beta, MemorySegment __c__) {
        var mh$ = chfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chfrk_", __transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chgeqz_$descriptor() {
        return chgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chgeqz_$handle() {
        return chgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chgeqz_$address() {
        return chgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chgeqz_(MemorySegment __job, MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __t, MemorySegment __ldt, MemorySegment __alpha, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chgeqz_", __job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alpha, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alpha, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chla_transtype__ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            clapack_h.C_POINTER,
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chla_transtype__");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chla_transtype__(char *__ret_val, __CLPK_ftnlen __ret_val_len, __CLPK_integer *__trans)
     * }
     */
    public static FunctionDescriptor chla_transtype__$descriptor() {
        return chla_transtype__.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chla_transtype__(char *__ret_val, __CLPK_ftnlen __ret_val_len, __CLPK_integer *__trans)
     * }
     */
    public static MethodHandle chla_transtype__$handle() {
        return chla_transtype__.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chla_transtype__(char *__ret_val, __CLPK_ftnlen __ret_val_len, __CLPK_integer *__trans)
     * }
     */
    public static MemorySegment chla_transtype__$address() {
        return chla_transtype__.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chla_transtype__(char *__ret_val, __CLPK_ftnlen __ret_val_len, __CLPK_integer *__trans)
     * }
     */
    public static void chla_transtype__(MemorySegment __ret_val, int __ret_val_len, MemorySegment __trans) {
        var mh$ = chla_transtype__.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chla_transtype__", __ret_val, __ret_val_len, __trans);
            }
            mh$.invokeExact(__ret_val, __ret_val_len, __trans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpcon_$descriptor() {
        return chpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpcon_$handle() {
        return chpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpcon_$address() {
        return chpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int chpcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = chpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpcon_", __uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpev_$descriptor() {
        return chpev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpev_$handle() {
        return chpev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpev_$address() {
        return chpev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chpev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chpev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpev_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpevd_$descriptor() {
        return chpevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpevd_$handle() {
        return chpevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpevd_$address() {
        return chpevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int chpevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = chpevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpevd_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpevx_$descriptor() {
        return chpevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpevx_$handle() {
        return chpevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpevx_$address() {
        return chpevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int chpevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = chpevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpevx_", __jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpgst_$descriptor() {
        return chpgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpgst_$handle() {
        return chpgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpgst_$address() {
        return chpgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_integer *__info)
     * }
     */
    public static int chpgst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __info) {
        var mh$ = chpgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgst_", __itype, __uplo, __n, __ap, __bp, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __ap, __bp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpgv_$descriptor() {
        return chpgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpgv_$handle() {
        return chpgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpgv_$address() {
        return chpgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chpgv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chpgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgv_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpgvd_$descriptor() {
        return chpgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpgvd_$handle() {
        return chpgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpgvd_$address() {
        return chpgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int chpgvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = chpgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgvd_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpgvx_$descriptor() {
        return chpgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpgvx_$handle() {
        return chpgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpgvx_$address() {
        return chpgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int chpgvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = chpgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgvx_", __itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __rwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chprfs_$descriptor() {
        return chprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chprfs_$handle() {
        return chprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chprfs_$address() {
        return chprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chprfs_", __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpsv_$descriptor() {
        return chpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpsv_$handle() {
        return chpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpsv_$address() {
        return chpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int chpsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = chpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpsv_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chpsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chpsvx_$descriptor() {
        return chpsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chpsvx_$handle() {
        return chpsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chpsvx_$address() {
        return chpsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int chpsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = chpsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chptrd_$descriptor() {
        return chptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chptrd_$handle() {
        return chptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chptrd_$address() {
        return chptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static int chptrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = chptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrd_", __uplo, __n, __ap, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chptrf_$descriptor() {
        return chptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chptrf_$handle() {
        return chptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chptrf_$address() {
        return chptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int chptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = chptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrf_", __uplo, __n, __ap, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chptri_$descriptor() {
        return chptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chptri_$handle() {
        return chptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chptri_$address() {
        return chptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int chptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = chptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptri_", __uplo, __n, __ap, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chptrs_$descriptor() {
        return chptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chptrs_$handle() {
        return chptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chptrs_$address() {
        return chptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int chptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = chptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrs_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chsein_$descriptor() {
        return chsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chsein_$handle() {
        return chsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chsein_$address() {
        return chsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static int chsein_(MemorySegment __side, MemorySegment __eigsrc, MemorySegment __initv, MemorySegment __select, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __rwork, MemorySegment __ifaill, MemorySegment __ifailr, MemorySegment __info) {
        var mh$ = chsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chsein_", __side, __eigsrc, __initv, __select, __n, __h__, __ldh, __w, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __ifaill, __ifailr, __info);
            }
            return (int)mh$.invokeExact(__side, __eigsrc, __initv, __select, __n, __h__, __ldh, __w, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __ifaill, __ifailr, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("chseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor chseqr_$descriptor() {
        return chseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle chseqr_$handle() {
        return chseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment chseqr_$address() {
        return chseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int chseqr_(MemorySegment __job, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = chseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chseqr_", __job, __compz, __n, __ilo, __ihi, __h__, __ldh, __w, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compz, __n, __ilo, __ihi, __h__, __ldh, __w, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clabrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clabrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor clabrd_$descriptor() {
        return clabrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle clabrd_$handle() {
        return clabrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment clabrd_$address() {
        return clabrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int clabrd_(MemorySegment __m, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __x, MemorySegment __ldx, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = clabrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clabrd_", __m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
            }
            return (int)mh$.invokeExact(__m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacgv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor clacgv_$descriptor() {
        return clacgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacgv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle clacgv_$handle() {
        return clacgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacgv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment clacgv_$address() {
        return clacgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacgv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx)
     * }
     */
    public static int clacgv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx) {
        var mh$ = clacgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacgv_", __n, __x, __incx);
            }
            return (int)mh$.invokeExact(__n, __x, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacn2_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static FunctionDescriptor clacn2_$descriptor() {
        return clacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacn2_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MethodHandle clacn2_$handle() {
        return clacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacn2_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MemorySegment clacn2_$address() {
        return clacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacn2_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static int clacn2_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __est, MemorySegment __kase, MemorySegment __isave) {
        var mh$ = clacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacn2_", __n, __v, __x, __est, __kase, __isave);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __est, __kase, __isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacon_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static FunctionDescriptor clacon_$descriptor() {
        return clacon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacon_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static MethodHandle clacon_$handle() {
        return clacon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacon_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static MemorySegment clacon_$address() {
        return clacon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacon_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static int clacon_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __est, MemorySegment __kase) {
        var mh$ = clacon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacon_", __n, __v, __x, __est, __kase);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __est, __kase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor clacp2_$descriptor() {
        return clacp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle clacp2_$handle() {
        return clacp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment clacp2_$address() {
        return clacp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int clacp2_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = clacp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacp2_", __uplo, __m, __n, __a, __lda, __b, __ldb);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __a, __lda, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor clacpy_$descriptor() {
        return clacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle clacpy_$handle() {
        return clacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment clacpy_$address() {
        return clacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int clacpy_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = clacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacpy_", __uplo, __m, __n, __a, __lda, __b, __ldb);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __a, __lda, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacrm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacrm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static FunctionDescriptor clacrm_$descriptor() {
        return clacrm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static MethodHandle clacrm_$handle() {
        return clacrm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static MemorySegment clacrm_$address() {
        return clacrm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static int clacrm_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __rwork) {
        var mh$ = clacrm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacrm_", __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clacrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clacrt_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_complex *__c__, __CLPK_complex *__s)
     * }
     */
    public static FunctionDescriptor clacrt_$descriptor() {
        return clacrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clacrt_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_complex *__c__, __CLPK_complex *__s)
     * }
     */
    public static MethodHandle clacrt_$handle() {
        return clacrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clacrt_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_complex *__c__, __CLPK_complex *__s)
     * }
     */
    public static MemorySegment clacrt_$address() {
        return clacrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clacrt_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_complex *__c__, __CLPK_complex *__s)
     * }
     */
    public static int clacrt_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx, MemorySegment __cy, MemorySegment __incy, MemorySegment __c__, MemorySegment __s) {
        var mh$ = clacrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacrt_", __n, __cx, __incx, __cy, __incy, __c__, __s);
            }
            return (int)mh$.invokeExact(__n, __cx, __incx, __cy, __incy, __c__, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cladiv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cladiv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cladiv_(__CLPK_complex *__ret_val, __CLPK_complex *__x, __CLPK_complex *__y)
     * }
     */
    public static FunctionDescriptor cladiv_$descriptor() {
        return cladiv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cladiv_(__CLPK_complex *__ret_val, __CLPK_complex *__x, __CLPK_complex *__y)
     * }
     */
    public static MethodHandle cladiv_$handle() {
        return cladiv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cladiv_(__CLPK_complex *__ret_val, __CLPK_complex *__x, __CLPK_complex *__y)
     * }
     */
    public static MemorySegment cladiv_$address() {
        return cladiv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cladiv_(__CLPK_complex *__ret_val, __CLPK_complex *__x, __CLPK_complex *__y)
     * }
     */
    public static void cladiv_(MemorySegment __ret_val, MemorySegment __x, MemorySegment __y) {
        var mh$ = cladiv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cladiv_", __ret_val, __x, __y);
            }
            mh$.invokeExact(__ret_val, __x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claed0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claed0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor claed0_$descriptor() {
        return claed0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle claed0_$handle() {
        return claed0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment claed0_$address() {
        return claed0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int claed0_(MemorySegment __qsiz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __qstore, MemorySegment __ldqs, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = claed0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claed0_", __qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claed7_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claed7_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_integer *__indxq, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor claed7_$descriptor() {
        return claed7_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_integer *__indxq, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle claed7_$handle() {
        return claed7_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_integer *__indxq, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment claed7_$address() {
        return claed7_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_integer *__indxq, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int claed7_(MemorySegment __n, MemorySegment __cutpnt, MemorySegment __qsiz, MemorySegment __tlvls, MemorySegment __curlvl, MemorySegment __curpbm, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __rho, MemorySegment __indxq, MemorySegment __qstore, MemorySegment __qptr, MemorySegment __prmptr, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = claed7_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claed7_", __n, __cutpnt, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __rho, __indxq, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __cutpnt, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __rho, __indxq, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claed8_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claed8_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__d__, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_complex *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor claed8_$descriptor() {
        return claed8_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__d__, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_complex *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle claed8_$handle() {
        return claed8_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__d__, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_complex *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment claed8_$address() {
        return claed8_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__d__, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_complex *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__indxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__info)
     * }
     */
    public static int claed8_(MemorySegment __k, MemorySegment __n, MemorySegment __qsiz, MemorySegment __q, MemorySegment __ldq, MemorySegment __d__, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __z__, MemorySegment __dlamda, MemorySegment __q2, MemorySegment __ldq2, MemorySegment __w, MemorySegment __indxp, MemorySegment __indx, MemorySegment __indxq, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __info) {
        var mh$ = claed8_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claed8_", __k, __n, __qsiz, __q, __ldq, __d__, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __indxp, __indx, __indxq, __perm, __givptr, __givcol, __givnum, __info);
            }
            return (int)mh$.invokeExact(__k, __n, __qsiz, __q, __ldq, __d__, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __indxp, __indx, __indxq, __perm, __givptr, __givcol, __givnum, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__v, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rwork, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor claein_$descriptor() {
        return claein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__v, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rwork, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle claein_$handle() {
        return claein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__v, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rwork, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment claein_$address() {
        return claein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__v, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rwork, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_integer *__info)
     * }
     */
    public static int claein_(MemorySegment __rightv, MemorySegment __noinit, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __v, MemorySegment __b, MemorySegment __ldb, MemorySegment __rwork, MemorySegment __eps3, MemorySegment __smlnum, MemorySegment __info) {
        var mh$ = claein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claein_", __rightv, __noinit, __n, __h__, __ldh, __w, __v, __b, __ldb, __rwork, __eps3, __smlnum, __info);
            }
            return (int)mh$.invokeExact(__rightv, __noinit, __n, __h__, __ldh, __w, __v, __b, __ldb, __rwork, __eps3, __smlnum, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claesy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claesy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claesy_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_complex *__rt1, __CLPK_complex *__rt2, __CLPK_complex *__evscal, __CLPK_complex *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static FunctionDescriptor claesy_$descriptor() {
        return claesy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claesy_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_complex *__rt1, __CLPK_complex *__rt2, __CLPK_complex *__evscal, __CLPK_complex *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static MethodHandle claesy_$handle() {
        return claesy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claesy_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_complex *__rt1, __CLPK_complex *__rt2, __CLPK_complex *__evscal, __CLPK_complex *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static MemorySegment claesy_$address() {
        return claesy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claesy_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_complex *__rt1, __CLPK_complex *__rt2, __CLPK_complex *__evscal, __CLPK_complex *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static int claesy_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2, MemorySegment __evscal, MemorySegment __cs1, MemorySegment __sn1) {
        var mh$ = claesy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claesy_", __a, __b, __c__, __rt1, __rt2, __evscal, __cs1, __sn1);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2, __evscal, __cs1, __sn1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claev2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claev2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claev2_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static FunctionDescriptor claev2_$descriptor() {
        return claev2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claev2_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static MethodHandle claev2_$handle() {
        return claev2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claev2_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static MemorySegment claev2_$address() {
        return claev2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claev2_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_complex *__sn1)
     * }
     */
    public static int claev2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2, MemorySegment __cs1, MemorySegment __sn1) {
        var mh$ = claev2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claev2_", __a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clag2z_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clag2z_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clag2z_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clag2z_$descriptor() {
        return clag2z_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clag2z_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clag2z_$handle() {
        return clag2z_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clag2z_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clag2z_$address() {
        return clag2z_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clag2z_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__sa, __CLPK_integer *__ldsa, __CLPK_doublecomplex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int clag2z_(MemorySegment __m, MemorySegment __n, MemorySegment __sa, MemorySegment __ldsa, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = clag2z_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clag2z_", __m, __n, __sa, __ldsa, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __sa, __ldsa, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clags2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clags2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_complex *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_complex *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_complex *__snu, __CLPK_real *__csv, __CLPK_complex *__snv, __CLPK_real *__csq, __CLPK_complex *__snq)
     * }
     */
    public static FunctionDescriptor clags2_$descriptor() {
        return clags2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_complex *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_complex *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_complex *__snu, __CLPK_real *__csv, __CLPK_complex *__snv, __CLPK_real *__csq, __CLPK_complex *__snq)
     * }
     */
    public static MethodHandle clags2_$handle() {
        return clags2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_complex *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_complex *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_complex *__snu, __CLPK_real *__csv, __CLPK_complex *__snv, __CLPK_real *__csq, __CLPK_complex *__snq)
     * }
     */
    public static MemorySegment clags2_$address() {
        return clags2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_complex *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_complex *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_complex *__snu, __CLPK_real *__csv, __CLPK_complex *__snv, __CLPK_real *__csq, __CLPK_complex *__snq)
     * }
     */
    public static int clags2_(MemorySegment __upper, MemorySegment __a1, MemorySegment __a2, MemorySegment __a3, MemorySegment __b1, MemorySegment __b2, MemorySegment __b3, MemorySegment __csu, MemorySegment __snu, MemorySegment __csv, MemorySegment __snv, MemorySegment __csq, MemorySegment __snq) {
        var mh$ = clags2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clags2_", __upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
            }
            return (int)mh$.invokeExact(__upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clagtm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clagtm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor clagtm_$descriptor() {
        return clagtm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle clagtm_$handle() {
        return clagtm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment clagtm_$address() {
        return clagtm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int clagtm_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __alpha, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __x, MemorySegment __ldx, MemorySegment __beta, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = clagtm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clagtm_", __trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clahef_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clahef_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clahef_$descriptor() {
        return clahef_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clahef_$handle() {
        return clahef_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clahef_$address() {
        return clahef_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static int clahef_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __w, MemorySegment __ldw, MemorySegment __info) {
        var mh$ = clahef_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clahef_", __uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clahqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clahqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clahqr_$descriptor() {
        return clahqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clahqr_$handle() {
        return clahqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clahqr_$address() {
        return clahqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int clahqr_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = clahqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clahqr_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clahr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clahr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor clahr2_$descriptor() {
        return clahr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle clahr2_$handle() {
        return clahr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment clahr2_$address() {
        return clahr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int clahr2_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = clahr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clahr2_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clahrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clahrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor clahrd_$descriptor() {
        return clahrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle clahrd_$handle() {
        return clahrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment clahrd_$address() {
        return clahrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int clahrd_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = clahrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clahrd_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claic1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claic1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_complex *__x, __CLPK_real *__sest, __CLPK_complex *__w, __CLPK_complex *__gamma, __CLPK_real *__sestpr, __CLPK_complex *__s, __CLPK_complex *__c__)
     * }
     */
    public static FunctionDescriptor claic1_$descriptor() {
        return claic1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_complex *__x, __CLPK_real *__sest, __CLPK_complex *__w, __CLPK_complex *__gamma, __CLPK_real *__sestpr, __CLPK_complex *__s, __CLPK_complex *__c__)
     * }
     */
    public static MethodHandle claic1_$handle() {
        return claic1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_complex *__x, __CLPK_real *__sest, __CLPK_complex *__w, __CLPK_complex *__gamma, __CLPK_real *__sestpr, __CLPK_complex *__s, __CLPK_complex *__c__)
     * }
     */
    public static MemorySegment claic1_$address() {
        return claic1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_complex *__x, __CLPK_real *__sest, __CLPK_complex *__w, __CLPK_complex *__gamma, __CLPK_real *__sestpr, __CLPK_complex *__s, __CLPK_complex *__c__)
     * }
     */
    public static int claic1_(MemorySegment __job, MemorySegment __j, MemorySegment __x, MemorySegment __sest, MemorySegment __w, MemorySegment __gamma, MemorySegment __sestpr, MemorySegment __s, MemorySegment __c__) {
        var mh$ = claic1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claic1_", __job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
            }
            return (int)mh$.invokeExact(__job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clals0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clals0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clals0_$descriptor() {
        return clals0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clals0_$handle() {
        return clals0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clals0_$address() {
        return clals0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int clals0_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __poles, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __k, MemorySegment __c__, MemorySegment __s, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = clals0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clals0_", __icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __rwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clalsa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clalsa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clalsa_$descriptor() {
        return clalsa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clalsa_$handle() {
        return clalsa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clalsa_$address() {
        return clalsa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int clalsa_(MemorySegment __icompq, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __k, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __poles, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __perm, MemorySegment __givnum, MemorySegment __c__, MemorySegment __s, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = clalsa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clalsa_", __icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clalsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clalsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clalsd_$descriptor() {
        return clalsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clalsd_$handle() {
        return clalsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clalsd_$address() {
        return clalsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int clalsd_(MemorySegment __uplo, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __rwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = clalsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clalsd_", __uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __rwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __rwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clangb_$descriptor() {
        return clangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clangb_$handle() {
        return clangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clangb_$address() {
        return clangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double clangb_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = clangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clangb_", __norm, __n, __kl, __ku, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clange_$descriptor() {
        return clange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clange_$handle() {
        return clange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clange_$address() {
        return clange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double clange_(MemorySegment __norm, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = clange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clange_", __norm, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clangt_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du)
     * }
     */
    public static FunctionDescriptor clangt_$descriptor() {
        return clangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clangt_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du)
     * }
     */
    public static MethodHandle clangt_$handle() {
        return clangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clangt_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du)
     * }
     */
    public static MemorySegment clangt_$address() {
        return clangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clangt_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du)
     * }
     */
    public static double clangt_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du) {
        var mh$ = clangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clangt_", __norm, __n, __dl, __d__, __du);
            }
            return (double)mh$.invokeExact(__norm, __n, __dl, __d__, __du);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clanhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clanhb_$descriptor() {
        return clanhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clanhb_$handle() {
        return clanhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clanhb_$address() {
        return clanhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clanhb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double clanhb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = clanhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhb_", __norm, __uplo, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clanhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clanhe_$descriptor() {
        return clanhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clanhe_$handle() {
        return clanhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clanhe_$address() {
        return clanhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clanhe_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double clanhe_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = clanhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhe_", __norm, __uplo, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clanhf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clanhf_$descriptor() {
        return clanhf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clanhf_$handle() {
        return clanhf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clanhf_$address() {
        return clanhf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clanhf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_real *__work)
     * }
     */
    public static double clanhf_(MemorySegment __norm, MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __work) {
        var mh$ = clanhf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhf_", __norm, __transr, __uplo, __n, __a, __work);
            }
            return (double)mh$.invokeExact(__norm, __transr, __uplo, __n, __a, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clanhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clanhp_$descriptor() {
        return clanhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clanhp_$handle() {
        return clanhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clanhp_$address() {
        return clanhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clanhp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static double clanhp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = clanhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhp_", __norm, __uplo, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhs_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clanhs_$descriptor() {
        return clanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhs_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clanhs_$handle() {
        return clanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanhs_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clanhs_$address() {
        return clanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clanhs_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double clanhs_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = clanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhs_", __norm, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanht_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clanht_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanht_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e)
     * }
     */
    public static FunctionDescriptor clanht_$descriptor() {
        return clanht_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanht_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e)
     * }
     */
    public static MethodHandle clanht_$handle() {
        return clanht_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clanht_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e)
     * }
     */
    public static MemorySegment clanht_$address() {
        return clanht_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clanht_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e)
     * }
     */
    public static double clanht_(MemorySegment __norm, MemorySegment __n, MemorySegment __d__, MemorySegment __e) {
        var mh$ = clanht_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanht_", __norm, __n, __d__, __e);
            }
            return (double)mh$.invokeExact(__norm, __n, __d__, __e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clansb_$descriptor() {
        return clansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clansb_$handle() {
        return clansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clansb_$address() {
        return clansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double clansb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = clansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansb_", __norm, __uplo, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clansp_$descriptor() {
        return clansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clansp_$handle() {
        return clansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clansp_$address() {
        return clansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static double clansp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = clansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansp_", __norm, __uplo, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clansy_$descriptor() {
        return clansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clansy_$handle() {
        return clansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clansy_$address() {
        return clansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double clansy_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = clansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansy_", __norm, __uplo, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clantb_$descriptor() {
        return clantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clantb_$handle() {
        return clantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clantb_$address() {
        return clantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double clantb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = clantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantb_", __norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clantp_$descriptor() {
        return clantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clantp_$handle() {
        return clantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clantp_$address() {
        return clantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__work)
     * }
     */
    public static double clantp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = clantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantp_", __norm, __uplo, __diag, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clantr_$descriptor() {
        return clantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clantr_$handle() {
        return clantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal clantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clantr_$address() {
        return clantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal clantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double clantr_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = clantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantr_", __norm, __uplo, __diag, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clapll_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clapll_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clapll_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static FunctionDescriptor clapll_$descriptor() {
        return clapll_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clapll_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static MethodHandle clapll_$handle() {
        return clapll_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clapll_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static MemorySegment clapll_$address() {
        return clapll_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clapll_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static int clapll_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __ssmin) {
        var mh$ = clapll_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clapll_", __n, __x, __incx, __y, __incy, __ssmin);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __ssmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static FunctionDescriptor clapmt_$descriptor() {
        return clapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MethodHandle clapmt_$handle() {
        return clapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MemorySegment clapmt_$address() {
        return clapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static int clapmt_(MemorySegment __forwrd, MemorySegment __m, MemorySegment __n, MemorySegment __x, MemorySegment __ldx, MemorySegment __k) {
        var mh$ = clapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clapmt_", __forwrd, __m, __n, __x, __ldx, __k);
            }
            return (int)mh$.invokeExact(__forwrd, __m, __n, __x, __ldx, __k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqgb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqgb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqgb_$descriptor() {
        return claqgb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqgb_$handle() {
        return claqgb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqgb_$address() {
        return claqgb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqgb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqgb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqgb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqge_$descriptor() {
        return claqge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqge_$handle() {
        return claqge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqge_$address() {
        return claqge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqge_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqge_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqhb_$descriptor() {
        return claqhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqhb_$handle() {
        return claqhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqhb_$address() {
        return claqhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqhb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqhb_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqhe_$descriptor() {
        return claqhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqhe_$handle() {
        return claqhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqhe_$address() {
        return claqhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqhe_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqhe_", __uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqhp_$descriptor() {
        return claqhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqhp_$handle() {
        return claqhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqhp_$address() {
        return claqhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqhp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqhp_", __uplo, __n, __ap, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__work)
     * }
     */
    public static FunctionDescriptor claqp2_$descriptor() {
        return claqp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__work)
     * }
     */
    public static MethodHandle claqp2_$handle() {
        return claqp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__work)
     * }
     */
    public static MemorySegment claqp2_$address() {
        return claqp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__work)
     * }
     */
    public static int claqp2_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __work) {
        var mh$ = claqp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqp2_", __m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__auxv, __CLPK_complex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static FunctionDescriptor claqps_$descriptor() {
        return claqps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__auxv, __CLPK_complex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MethodHandle claqps_$handle() {
        return claqps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__auxv, __CLPK_complex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MemorySegment claqps_$address() {
        return claqps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__auxv, __CLPK_complex *__f, __CLPK_integer *__ldf)
     * }
     */
    public static int claqps_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __auxv, MemorySegment __f, MemorySegment __ldf) {
        var mh$ = claqps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqps_", __m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqr0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqr0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor claqr0_$descriptor() {
        return claqr0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle claqr0_$handle() {
        return claqr0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment claqr0_$address() {
        return claqr0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int claqr0_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = claqr0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqr0_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqr1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqr1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqr1_(__CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__s1, __CLPK_complex *__s2, __CLPK_complex *__v)
     * }
     */
    public static FunctionDescriptor claqr1_$descriptor() {
        return claqr1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqr1_(__CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__s1, __CLPK_complex *__s2, __CLPK_complex *__v)
     * }
     */
    public static MethodHandle claqr1_$handle() {
        return claqr1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqr1_(__CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__s1, __CLPK_complex *__s2, __CLPK_complex *__v)
     * }
     */
    public static MemorySegment claqr1_$address() {
        return claqr1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqr1_(__CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__s1, __CLPK_complex *__s2, __CLPK_complex *__v)
     * }
     */
    public static int claqr1_(MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __s1, MemorySegment __s2, MemorySegment __v) {
        var mh$ = claqr1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqr1_", __n, __h__, __ldh, __s1, __s2, __v);
            }
            return (int)mh$.invokeExact(__n, __h__, __ldh, __s1, __s2, __v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor claqr2_$descriptor() {
        return claqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle claqr2_$handle() {
        return claqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment claqr2_$address() {
        return claqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int claqr2_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sh, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = claqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqr2_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor claqr3_$descriptor() {
        return claqr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle claqr3_$handle() {
        return claqr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment claqr3_$address() {
        return claqr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_complex *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int claqr3_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sh, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = claqr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqr3_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sh, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqr4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqr4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor claqr4_$descriptor() {
        return claqr4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle claqr4_$handle() {
        return claqr4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment claqr4_$address() {
        return claqr4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int claqr4_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __w, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = claqr4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqr4_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __w, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqr5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqr5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_complex *__s, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_complex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static FunctionDescriptor claqr5_$descriptor() {
        return claqr5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_complex *__s, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_complex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MethodHandle claqr5_$handle() {
        return claqr5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_complex *__s, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_complex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MemorySegment claqr5_$address() {
        return claqr5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_complex *__s, __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_complex *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static int claqr5_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __kacc22, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nshfts, MemorySegment __s, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __v, MemorySegment __ldv, MemorySegment __u, MemorySegment __ldu, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __nh, MemorySegment __wh, MemorySegment __ldwh) {
        var mh$ = claqr5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqr5_", __wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __s, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __s, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqsb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqsb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqsb_$descriptor() {
        return claqsb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqsb_$handle() {
        return claqsb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqsb_$address() {
        return claqsb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqsb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqsb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqsb_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqsp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqsp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqsp_$descriptor() {
        return claqsp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqsp_$handle() {
        return claqsp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqsp_$address() {
        return claqsp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqsp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqsp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqsp_", __uplo, __n, __ap, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claqsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claqsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor claqsy_$descriptor() {
        return claqsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle claqsy_$handle() {
        return claqsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment claqsy_$address() {
        return claqsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int claqsy_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = claqsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claqsy_", __uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clar1v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clar1v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_complex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor clar1v_$descriptor() {
        return clar1v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_complex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static MethodHandle clar1v_$handle() {
        return clar1v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_complex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static MemorySegment clar1v_$address() {
        return clar1v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_complex *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static int clar1v_(MemorySegment __n, MemorySegment __b1, MemorySegment __bn, MemorySegment __lambda, MemorySegment __d__, MemorySegment __l, MemorySegment __ld, MemorySegment __lld, MemorySegment __pivmin, MemorySegment __gaptol, MemorySegment __z__, MemorySegment __wantnc, MemorySegment __negcnt, MemorySegment __ztz, MemorySegment __mingma, MemorySegment __r__, MemorySegment __isuppz, MemorySegment __nrminv, MemorySegment __resid, MemorySegment __rqcorr, MemorySegment __work) {
        var mh$ = clar1v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clar1v_", __n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
            }
            return (int)mh$.invokeExact(__n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clar2v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clar2v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clar2v_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor clar2v_$descriptor() {
        return clar2v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clar2v_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle clar2v_$handle() {
        return clar2v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clar2v_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment clar2v_$address() {
        return clar2v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clar2v_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_complex *__y, __CLPK_complex *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static int clar2v_(MemorySegment __n, MemorySegment __x, MemorySegment __y, MemorySegment __z__, MemorySegment __incx, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = clar2v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clar2v_", __n, __x, __y, __z__, __incx, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __y, __z__, __incx, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarcm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarcm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static FunctionDescriptor clarcm_$descriptor() {
        return clarcm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static MethodHandle clarcm_$handle() {
        return clarcm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static MemorySegment clarcm_$address() {
        return clarcm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__rwork)
     * }
     */
    public static int clarcm_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __rwork) {
        var mh$ = clarcm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarcm_", __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static FunctionDescriptor clarf_$descriptor() {
        return clarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MethodHandle clarf_$handle() {
        return clarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MemorySegment clarf_$address() {
        return clarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static int clarf_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = clarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarf_", __side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor clarfb_$descriptor() {
        return clarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle clarfb_$handle() {
        return clarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment clarfb_$address() {
        return clarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int clarfb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = clarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfb_", __side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarfg_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static FunctionDescriptor clarfg_$descriptor() {
        return clarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarfg_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static MethodHandle clarfg_$handle() {
        return clarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarfg_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static MemorySegment clarfg_$address() {
        return clarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarfg_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static int clarfg_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = clarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfg_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarfp_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static FunctionDescriptor clarfp_$descriptor() {
        return clarfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarfp_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static MethodHandle clarfp_$handle() {
        return clarfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarfp_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static MemorySegment clarfp_$address() {
        return clarfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarfp_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__tau)
     * }
     */
    public static int clarfp_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = clarfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfp_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor clarft_$descriptor() {
        return clarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle clarft_$handle() {
        return clarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment clarft_$address() {
        return clarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int clarft_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = clarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarft_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static FunctionDescriptor clarfx_$descriptor() {
        return clarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MethodHandle clarfx_$handle() {
        return clarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MemorySegment clarfx_$address() {
        return clarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static int clarfx_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = clarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfx_", __side, __m, __n, __v, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clargv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clargv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clargv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor clargv_$descriptor() {
        return clargv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clargv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle clargv_$handle() {
        return clargv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clargv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment clargv_$address() {
        return clargv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clargv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static int clargv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __incc) {
        var mh$ = clargv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clargv_", __n, __x, __incx, __y, __incy, __c__, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_complex *__x)
     * }
     */
    public static FunctionDescriptor clarnv_$descriptor() {
        return clarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_complex *__x)
     * }
     */
    public static MethodHandle clarnv_$handle() {
        return clarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_complex *__x)
     * }
     */
    public static MemorySegment clarnv_$address() {
        return clarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_complex *__x)
     * }
     */
    public static int clarnv_(MemorySegment __idist, MemorySegment __iseed, MemorySegment __n, MemorySegment __x) {
        var mh$ = clarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarnv_", __idist, __iseed, __n, __x);
            }
            return (int)mh$.invokeExact(__idist, __iseed, __n, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarrv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarrv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clarrv_$descriptor() {
        return clarrv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clarrv_$handle() {
        return clarrv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clarrv_$address() {
        return clarrv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int clarrv_(MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __d__, MemorySegment __l, MemorySegment __pivmin, MemorySegment __isplit, MemorySegment __m, MemorySegment __dol, MemorySegment __dou, MemorySegment __minrgp, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __w, MemorySegment __werr, MemorySegment __wgap, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __gers, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = clarrv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarrv_", __n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarscl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarscl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor clarscl2_$descriptor() {
        return clarscl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle clarscl2_$handle() {
        return clarscl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment clarscl2_$address() {
        return clarscl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int clarscl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = clarscl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarscl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clartg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clartg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clartg_(__CLPK_complex *__f, __CLPK_complex *__g, __CLPK_real *__cs, __CLPK_complex *__sn, __CLPK_complex *__r__)
     * }
     */
    public static FunctionDescriptor clartg_$descriptor() {
        return clartg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clartg_(__CLPK_complex *__f, __CLPK_complex *__g, __CLPK_real *__cs, __CLPK_complex *__sn, __CLPK_complex *__r__)
     * }
     */
    public static MethodHandle clartg_$handle() {
        return clartg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clartg_(__CLPK_complex *__f, __CLPK_complex *__g, __CLPK_real *__cs, __CLPK_complex *__sn, __CLPK_complex *__r__)
     * }
     */
    public static MemorySegment clartg_$address() {
        return clartg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clartg_(__CLPK_complex *__f, __CLPK_complex *__g, __CLPK_real *__cs, __CLPK_complex *__sn, __CLPK_complex *__r__)
     * }
     */
    public static int clartg_(MemorySegment __f, MemorySegment __g, MemorySegment __cs, MemorySegment __sn, MemorySegment __r__) {
        var mh$ = clartg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clartg_", __f, __g, __cs, __sn, __r__);
            }
            return (int)mh$.invokeExact(__f, __g, __cs, __sn, __r__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clartv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clartv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clartv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor clartv_$descriptor() {
        return clartv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clartv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle clartv_$handle() {
        return clartv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clartv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment clartv_$address() {
        return clartv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clartv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s, __CLPK_integer *__incc)
     * }
     */
    public static int clartv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = clartv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clartv_", __n, __x, __incx, __y, __incy, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static FunctionDescriptor clarz_$descriptor() {
        return clarz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MethodHandle clarz_$handle() {
        return clarz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MemorySegment clarz_$address() {
        return clarz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static int clarz_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = clarz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarz_", __side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarzb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarzb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor clarzb_$descriptor() {
        return clarzb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle clarzb_$handle() {
        return clarzb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment clarzb_$address() {
        return clarzb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int clarzb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = clarzb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarzb_", __side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarzt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clarzt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor clarzt_$descriptor() {
        return clarzt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle clarzt_$handle() {
        return clarzt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment clarzt_$address() {
        return clarzt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__tau, __CLPK_complex *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int clarzt_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = clarzt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarzt_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clascl_$descriptor() {
        return clascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clascl_$handle() {
        return clascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clascl_$address() {
        return clascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int clascl_(MemorySegment __type__, MemorySegment __kl, MemorySegment __ku, MemorySegment __cfrom, MemorySegment __cto, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = clascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clascl_", __type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clascl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clascl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor clascl2_$descriptor() {
        return clascl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle clascl2_$handle() {
        return clascl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment clascl2_$address() {
        return clascl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int clascl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = clascl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clascl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor claset_$descriptor() {
        return claset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle claset_$handle() {
        return claset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment claset_$address() {
        return claset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int claset_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __beta, MemorySegment __a, MemorySegment __lda) {
        var mh$ = claset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claset_", __uplo, __m, __n, __alpha, __beta, __a, __lda);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __alpha, __beta, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clasr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clasr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor clasr_$descriptor() {
        return clasr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle clasr_$handle() {
        return clasr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment clasr_$address() {
        return clasr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int clasr_(MemorySegment __side, MemorySegment __pivot, MemorySegment __direct, MemorySegment __m, MemorySegment __n, MemorySegment __c__, MemorySegment __s, MemorySegment __a, MemorySegment __lda) {
        var mh$ = clasr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clasr_", __side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
            }
            return (int)mh$.invokeExact(__side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class classq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("classq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int classq_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static FunctionDescriptor classq_$descriptor() {
        return classq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int classq_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static MethodHandle classq_$handle() {
        return classq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int classq_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static MemorySegment classq_$address() {
        return classq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int classq_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static int classq_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __scale, MemorySegment __sumsq) {
        var mh$ = classq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("classq_", __n, __x, __incx, __scale, __sumsq);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __scale, __sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("claswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int claswp_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor claswp_$descriptor() {
        return claswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int claswp_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle claswp_$handle() {
        return claswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int claswp_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment claswp_$address() {
        return claswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int claswp_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static int claswp_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __k1, MemorySegment __k2, MemorySegment __ipiv, MemorySegment __incx) {
        var mh$ = claswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claswp_", __n, __a, __lda, __k1, __k2, __ipiv, __incx);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __k1, __k2, __ipiv, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clasyf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clasyf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clasyf_$descriptor() {
        return clasyf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clasyf_$handle() {
        return clasyf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clasyf_$address() {
        return clasyf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static int clasyf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __w, MemorySegment __ldw, MemorySegment __info) {
        var mh$ = clasyf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clasyf_", __uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatbs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatbs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clatbs_$descriptor() {
        return clatbs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clatbs_$handle() {
        return clatbs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clatbs_$address() {
        return clatbs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int clatbs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = clatbs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatbs_", __uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatdf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatdf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static FunctionDescriptor clatdf_$descriptor() {
        return clatdf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MethodHandle clatdf_$handle() {
        return clatdf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MemorySegment clatdf_$address() {
        return clatdf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static int clatdf_(MemorySegment __ijob, MemorySegment __n, MemorySegment __z__, MemorySegment __ldz, MemorySegment __rhs, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __ipiv, MemorySegment __jpiv) {
        var mh$ = clatdf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatdf_", __ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
            }
            return (int)mh$.invokeExact(__ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clatps_$descriptor() {
        return clatps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clatps_$handle() {
        return clatps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clatps_$address() {
        return clatps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int clatps_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __ap, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = clatps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatps_", __uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static FunctionDescriptor clatrd_$descriptor() {
        return clatrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MethodHandle clatrd_$handle() {
        return clatrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MemorySegment clatrd_$address() {
        return clatrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_complex *__tau, __CLPK_complex *__w, __CLPK_integer *__ldw)
     * }
     */
    public static int clatrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __e, MemorySegment __tau, MemorySegment __w, MemorySegment __ldw) {
        var mh$ = clatrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatrd_", __uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clatrs_$descriptor() {
        return clatrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clatrs_$handle() {
        return clatrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clatrs_$address() {
        return clatrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int clatrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = clatrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatrs_", __uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work)
     * }
     */
    public static FunctionDescriptor clatrz_$descriptor() {
        return clatrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work)
     * }
     */
    public static MethodHandle clatrz_$handle() {
        return clatrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work)
     * }
     */
    public static MemorySegment clatrz_$address() {
        return clatrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work)
     * }
     */
    public static int clatrz_(MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work) {
        var mh$ = clatrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatrz_", __m, __n, __l, __a, __lda, __tau, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __l, __a, __lda, __tau, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatzm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clatzm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c1, __CLPK_complex *__c2, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static FunctionDescriptor clatzm_$descriptor() {
        return clatzm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c1, __CLPK_complex *__c2, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MethodHandle clatzm_$handle() {
        return clatzm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c1, __CLPK_complex *__c2, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static MemorySegment clatzm_$address() {
        return clatzm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau, __CLPK_complex *__c1, __CLPK_complex *__c2, __CLPK_integer *__ldc, __CLPK_complex *__work)
     * }
     */
    public static int clatzm_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c1, MemorySegment __c2, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = clatzm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatzm_", __side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clauu2_$descriptor() {
        return clauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clauu2_$handle() {
        return clauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clauu2_$address() {
        return clauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int clauu2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = clauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clauu2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("clauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clauum_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor clauum_$descriptor() {
        return clauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clauum_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle clauum_$handle() {
        return clauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clauum_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment clauum_$address() {
        return clauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clauum_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int clauum_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = clauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clauum_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbcon_$descriptor() {
        return cpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbcon_$handle() {
        return cpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbcon_$address() {
        return cpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cpbcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbcon_", __uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbequ_$descriptor() {
        return cpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbequ_$handle() {
        return cpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbequ_$address() {
        return cpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cpbequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbequ_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbrfs_$descriptor() {
        return cpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbrfs_$handle() {
        return cpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbrfs_$address() {
        return cpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cpbrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbrfs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbstf_$descriptor() {
        return cpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbstf_$handle() {
        return cpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbstf_$address() {
        return cpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int cpbstf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = cpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbstf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbsv_$descriptor() {
        return cpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbsv_$handle() {
        return cpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbsv_$address() {
        return cpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cpbsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbsv_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbsvx_$descriptor() {
        return cpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbsvx_$handle() {
        return cpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbsvx_$address() {
        return cpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cpbsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbsvx_", __fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbtf2_$descriptor() {
        return cpbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbtf2_$handle() {
        return cpbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbtf2_$address() {
        return cpbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int cpbtf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = cpbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtf2_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbtrf_$descriptor() {
        return cpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbtrf_$handle() {
        return cpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbtrf_$address() {
        return cpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int cpbtrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = cpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtrf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpbtrs_$descriptor() {
        return cpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpbtrs_$handle() {
        return cpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpbtrs_$address() {
        return cpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cpbtrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtrs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpftrf_$descriptor() {
        return cpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpftrf_$handle() {
        return cpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpftrf_$address() {
        return cpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static int cpftrf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = cpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftrf_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpftri_$descriptor() {
        return cpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpftri_$handle() {
        return cpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpftri_$address() {
        return cpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static int cpftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = cpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftri_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpftrs_$descriptor() {
        return cpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpftrs_$handle() {
        return cpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpftrs_$address() {
        return cpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cpftrs_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftrs_", __transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpocon_$descriptor() {
        return cpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpocon_$handle() {
        return cpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpocon_$address() {
        return cpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cpocon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpocon_", __uplo, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpoequ_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpoequ_$descriptor() {
        return cpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpoequ_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpoequ_$handle() {
        return cpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpoequ_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpoequ_$address() {
        return cpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpoequ_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cpoequ_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpoequ_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpoequb_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpoequb_$descriptor() {
        return cpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpoequb_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpoequb_$handle() {
        return cpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpoequb_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpoequb_$address() {
        return cpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpoequb_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cpoequb_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpoequb_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cporfs_$descriptor() {
        return cporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cporfs_$handle() {
        return cporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cporfs_$address() {
        return cporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cporfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cporfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cposv_$descriptor() {
        return cposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cposv_$handle() {
        return cposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cposv_$address() {
        return cposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cposv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposv_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cposvx_$descriptor() {
        return cposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cposvx_$handle() {
        return cposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cposvx_$address() {
        return cposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cposvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpotf2_$descriptor() {
        return cpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpotf2_$handle() {
        return cpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpotf2_$address() {
        return cpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int cpotf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = cpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotf2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpotrf_$descriptor() {
        return cpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpotrf_$handle() {
        return cpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpotrf_$address() {
        return cpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int cpotrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = cpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrf_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpotri_$descriptor() {
        return cpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpotri_$handle() {
        return cpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpotri_$address() {
        return cpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int cpotri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = cpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotri_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpotrs_$descriptor() {
        return cpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpotrs_$handle() {
        return cpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpotrs_$address() {
        return cpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cpotrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrs_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cppcon_$descriptor() {
        return cppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cppcon_$handle() {
        return cppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cppcon_$address() {
        return cppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cppcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppcon_", __uplo, __n, __ap, __anorm, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __anorm, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cppequ_$descriptor() {
        return cppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cppequ_$handle() {
        return cppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cppequ_$address() {
        return cppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int cppequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = cppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppequ_", __uplo, __n, __ap, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpprfs_$descriptor() {
        return cpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpprfs_$handle() {
        return cpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpprfs_$address() {
        return cpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cpprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpprfs_", __uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cppsv_$descriptor() {
        return cppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cppsv_$handle() {
        return cppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cppsv_$address() {
        return cppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cppsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppsv_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cppsvx_$descriptor() {
        return cppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cppsvx_$handle() {
        return cppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cppsvx_$address() {
        return cppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, char *__equed, __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cppsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpptrf_$descriptor() {
        return cpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpptrf_$handle() {
        return cpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpptrf_$address() {
        return cpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int cpptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = cpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptrf_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpptri_$descriptor() {
        return cpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpptri_$handle() {
        return cpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpptri_$address() {
        return cpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int cpptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = cpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptri_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpptrs_$descriptor() {
        return cpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpptrs_$handle() {
        return cpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpptrs_$address() {
        return cpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cpptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptrs_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpstf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpstf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpstf2_$descriptor() {
        return cpstf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpstf2_$handle() {
        return cpstf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpstf2_$address() {
        return cpstf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int cpstf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = cpstf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpstf2_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpstrf_$descriptor() {
        return cpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpstrf_$handle() {
        return cpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpstrf_$address() {
        return cpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_real *__tol, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int cpstrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = cpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpstrf_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cptcon_$descriptor() {
        return cptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cptcon_$handle() {
        return cptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cptcon_$address() {
        return cptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cptcon_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptcon_", __n, __d__, __e, __anorm, __rcond, __rwork, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __anorm, __rcond, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpteqr_$descriptor() {
        return cpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpteqr_$handle() {
        return cpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpteqr_$address() {
        return cpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int cpteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = cpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cptrfs_$descriptor() {
        return cptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cptrfs_$handle() {
        return cptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cptrfs_$address() {
        return cptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cptrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptrfs_", __uplo, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cptsv_$descriptor() {
        return cptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cptsv_$handle() {
        return cptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cptsv_$address() {
        return cptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cptsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptsv_", __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cptsvx_$descriptor() {
        return cptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cptsvx_$handle() {
        return cptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cptsvx_$address() {
        return cptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df, __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cptsvx_(MemorySegment __fact, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptsvx_", __fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpttrf_$descriptor() {
        return cpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpttrf_$handle() {
        return cpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpttrf_$address() {
        return cpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_integer *__info)
     * }
     */
    public static int cpttrf_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = cpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpttrf_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cpttrs_$descriptor() {
        return cpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cpttrs_$handle() {
        return cpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cpttrs_$address() {
        return cpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cpttrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpttrs_", __uplo, __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cptts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor cptts2_$descriptor() {
        return cptts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle cptts2_$handle() {
        return cptts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment cptts2_$address() {
        return cptts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int cptts2_(MemorySegment __iuplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = cptts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptts2_", __iuplo, __n, __nrhs, __d__, __e, __b, __ldb);
            }
            return (int)mh$.invokeExact(__iuplo, __n, __nrhs, __d__, __e, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crot_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("crot_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int crot_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s)
     * }
     */
    public static FunctionDescriptor crot_$descriptor() {
        return crot_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int crot_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s)
     * }
     */
    public static MethodHandle crot_$handle() {
        return crot_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int crot_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s)
     * }
     */
    public static MemorySegment crot_$address() {
        return crot_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int crot_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx, __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_complex *__s)
     * }
     */
    public static int crot_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx, MemorySegment __cy, MemorySegment __incy, MemorySegment __c__, MemorySegment __s) {
        var mh$ = crot_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crot_", __n, __cx, __incx, __cy, __incy, __c__, __s);
            }
            return (int)mh$.invokeExact(__n, __cx, __incx, __cy, __incy, __c__, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cspcon_$descriptor() {
        return cspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cspcon_$handle() {
        return cspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cspcon_$address() {
        return cspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cspcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = cspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspcon_", __uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspmv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cspmv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static FunctionDescriptor cspmv_$descriptor() {
        return cspmv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MethodHandle cspmv_$handle() {
        return cspmv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MemorySegment cspmv_$address() {
        return cspmv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static int cspmv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __ap, MemorySegment __x, MemorySegment __incx, MemorySegment __beta, MemorySegment __y, MemorySegment __incy) {
        var mh$ = cspmv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspmv_", __uplo, __n, __alpha, __ap, __x, __incx, __beta, __y, __incy);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __ap, __x, __incx, __beta, __y, __incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cspr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cspr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__ap)
     * }
     */
    public static FunctionDescriptor cspr_$descriptor() {
        return cspr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cspr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__ap)
     * }
     */
    public static MethodHandle cspr_$handle() {
        return cspr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cspr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__ap)
     * }
     */
    public static MemorySegment cspr_$address() {
        return cspr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cspr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__ap)
     * }
     */
    public static int cspr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __ap) {
        var mh$ = cspr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspr_", __uplo, __n, __alpha, __x, __incx, __ap);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __x, __incx, __ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csprfs_$descriptor() {
        return csprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csprfs_$handle() {
        return csprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csprfs_$address() {
        return csprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int csprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = csprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csprfs_", __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cspsv_$descriptor() {
        return cspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cspsv_$handle() {
        return cspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cspsv_$address() {
        return cspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int cspsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = cspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspsv_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cspsvx_$descriptor() {
        return cspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cspsvx_$handle() {
        return cspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cspsvx_$address() {
        return cspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int cspsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = cspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csptrf_$descriptor() {
        return csptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csptrf_$handle() {
        return csptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csptrf_$address() {
        return csptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int csptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = csptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptrf_", __uplo, __n, __ap, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csptri_$descriptor() {
        return csptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csptri_$handle() {
        return csptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csptri_$address() {
        return csptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int csptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = csptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptri_", __uplo, __n, __ap, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csptrs_$descriptor() {
        return csptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csptrs_$handle() {
        return csptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csptrs_$address() {
        return csptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int csptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = csptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptrs_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csrscl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csrscl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csrscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_complex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor csrscl_$descriptor() {
        return csrscl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csrscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_complex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle csrscl_$handle() {
        return csrscl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csrscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_complex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment csrscl_$address() {
        return csrscl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csrscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_complex *__sx, __CLPK_integer *__incx)
     * }
     */
    public static int csrscl_(MemorySegment __n, MemorySegment __sa, MemorySegment __sx, MemorySegment __incx) {
        var mh$ = csrscl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csrscl_", __n, __sa, __sx, __incx);
            }
            return (int)mh$.invokeExact(__n, __sa, __sx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cstedc_$descriptor() {
        return cstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cstedc_$handle() {
        return cstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cstedc_$address() {
        return cstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int cstedc_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __lrwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = cstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstedc_", __compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __rwork, __lrwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cstegr_$descriptor() {
        return cstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cstegr_$handle() {
        return cstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cstegr_$address() {
        return cstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int cstegr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = cstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstegr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cstein_$descriptor() {
        return cstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cstein_$handle() {
        return cstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cstein_$address() {
        return cstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int cstein_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __m, MemorySegment __w, MemorySegment __iblock, MemorySegment __isplit, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = cstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstein_", __n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cstemr_$descriptor() {
        return cstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cstemr_$handle() {
        return cstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cstemr_$address() {
        return cstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int cstemr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __nzc, MemorySegment __isuppz, MemorySegment __tryrac, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = cstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstemr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csteqr_$descriptor() {
        return csteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csteqr_$handle() {
        return csteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csteqr_$address() {
        return csteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int csteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = csteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csycon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csycon_$descriptor() {
        return csycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csycon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csycon_$handle() {
        return csycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csycon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csycon_$address() {
        return csycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csycon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int csycon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = csycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csycon_", __uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csyequb_$descriptor() {
        return csyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csyequb_$handle() {
        return csyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csyequb_$address() {
        return csyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int csyequb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __work, MemorySegment __info) {
        var mh$ = csyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyequb_", __uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csymv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csymv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csymv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static FunctionDescriptor csymv_$descriptor() {
        return csymv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csymv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MethodHandle csymv_$handle() {
        return csymv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csymv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static MemorySegment csymv_$address() {
        return csymv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csymv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y, __CLPK_integer *__incy)
     * }
     */
    public static int csymv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __a, MemorySegment __lda, MemorySegment __x, MemorySegment __incx, MemorySegment __beta, MemorySegment __y, MemorySegment __incy) {
        var mh$ = csymv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csymv_", __uplo, __n, __alpha, __a, __lda, __x, __incx, __beta, __y, __incy);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __a, __lda, __x, __incx, __beta, __y, __incy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csyr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor csyr_$descriptor() {
        return csyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csyr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle csyr_$handle() {
        return csyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csyr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment csyr_$address() {
        return csyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csyr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int csyr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __a, MemorySegment __lda) {
        var mh$ = csyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyr_", __uplo, __n, __alpha, __x, __incx, __a, __lda);
            }
            return (int)mh$.invokeExact(__uplo, __n, __alpha, __x, __incx, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csyrfs_$descriptor() {
        return csyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csyrfs_$handle() {
        return csyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csyrfs_$address() {
        return csyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int csyrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = csyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyrfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csysv_$descriptor() {
        return csysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csysv_$handle() {
        return csysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csysv_$address() {
        return csysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int csysv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = csysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csysvx_$descriptor() {
        return csysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csysvx_$handle() {
        return csysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csysvx_$address() {
        return csysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int csysvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __lwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = csysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csytf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csytf2_$descriptor() {
        return csytf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csytf2_$handle() {
        return csytf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csytf2_$address() {
        return csytf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int csytf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = csytf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytf2_", __uplo, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csytrf_$descriptor() {
        return csytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csytrf_$handle() {
        return csytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csytrf_$address() {
        return csytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int csytrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = csytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_", __uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csytri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csytri_$descriptor() {
        return csytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csytri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csytri_$handle() {
        return csytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csytri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csytri_$address() {
        return csytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csytri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int csytri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = csytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri_", __uplo, __n, __a, __lda, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("csytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int csytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor csytrs_$descriptor() {
        return csytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int csytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle csytrs_$handle() {
        return csytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int csytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment csytrs_$address() {
        return csytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int csytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int csytrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = csytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctbcon_$descriptor() {
        return ctbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctbcon_$handle() {
        return ctbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctbcon_$address() {
        return ctbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctbcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbcon_", __norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctbrfs_$descriptor() {
        return ctbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctbrfs_$handle() {
        return ctbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctbrfs_$address() {
        return ctbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctbrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbrfs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctbtrs_$descriptor() {
        return ctbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctbtrs_$handle() {
        return ctbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctbtrs_$address() {
        return ctbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ctbtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ctbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbtrs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor ctfsm_$descriptor() {
        return ctfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle ctfsm_$handle() {
        return ctfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment ctfsm_$address() {
        return ctfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_complex *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int ctfsm_(MemorySegment __transr, MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __a, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = ctfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfsm_", __transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
            }
            return (int)mh$.invokeExact(__transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctftri_$descriptor() {
        return ctftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctftri_$handle() {
        return ctftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctftri_$address() {
        return ctftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__info)
     * }
     */
    public static int ctftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = ctftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctftri_", __transr, __uplo, __diag, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __diag, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctfttp_$descriptor() {
        return ctfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctfttp_$handle() {
        return ctfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctfttp_$address() {
        return ctfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int ctfttp_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __ap, MemorySegment __info) {
        var mh$ = ctfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfttp_", __transr, __uplo, __n, __arf, __ap, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctfttr_$descriptor() {
        return ctfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctfttr_$handle() {
        return ctfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctfttr_$address() {
        return ctfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__arf, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ctfttr_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ctfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfttr_", __transr, __uplo, __n, __arf, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__s, __CLPK_integer *__lds, __CLPK_complex *__p, __CLPK_integer *__ldp, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgevc_$descriptor() {
        return ctgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__s, __CLPK_integer *__lds, __CLPK_complex *__p, __CLPK_integer *__ldp, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgevc_$handle() {
        return ctgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__s, __CLPK_integer *__lds, __CLPK_complex *__p, __CLPK_integer *__ldp, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgevc_$address() {
        return ctgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__s, __CLPK_integer *__lds, __CLPK_complex *__p, __CLPK_integer *__ldp, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctgevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __s, MemorySegment __lds, MemorySegment __p, MemorySegment __ldp, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgevc_", __side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgex2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgex2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgex2_$descriptor() {
        return ctgex2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgex2_$handle() {
        return ctgex2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgex2_$address() {
        return ctgex2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__info)
     * }
     */
    public static int ctgex2_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __j1, MemorySegment __info) {
        var mh$ = ctgex2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgex2_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgexc_$descriptor() {
        return ctgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgexc_$handle() {
        return ctgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgexc_$address() {
        return ctgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static int ctgexc_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __info) {
        var mh$ = ctgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgexc_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgsen_$descriptor() {
        return ctgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgsen_$handle() {
        return ctgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgsen_$address() {
        return ctgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl, __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int ctgsen_(MemorySegment __ijob, MemorySegment __wantq, MemorySegment __wantz, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __m, MemorySegment __pl, MemorySegment __pr, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = ctgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsen_", __ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alpha, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alpha, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgsja_$descriptor() {
        return ctgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgsja_$handle() {
        return ctgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgsja_$address() {
        return ctgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static int ctgsja_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __ncycle, MemorySegment __info) {
        var mh$ = ctgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsja_", __jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgsna_$descriptor() {
        return ctgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgsna_$handle() {
        return ctgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgsna_$address() {
        return ctgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ctgsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __dif, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ctgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsna_", __job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgsy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgsy2_$descriptor() {
        return ctgsy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgsy2_$handle() {
        return ctgsy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgsy2_$address() {
        return ctgsy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__info)
     * }
     */
    public static int ctgsy2_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __info) {
        var mh$ = ctgsy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsy2_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctgsyl_$descriptor() {
        return ctgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctgsyl_$handle() {
        return ctgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctgsyl_$address() {
        return ctgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd, __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f, __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int ctgsyl_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = ctgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsyl_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctpcon_$descriptor() {
        return ctpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctpcon_$handle() {
        return ctpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctpcon_$address() {
        return ctpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctpcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpcon_", __norm, __uplo, __diag, __n, __ap, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctprfs_$descriptor() {
        return ctprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctprfs_$handle() {
        return ctprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctprfs_$address() {
        return ctprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctprfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctprfs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctptri_$descriptor() {
        return ctptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctptri_$handle() {
        return ctptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctptri_$address() {
        return ctptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int ctptri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = ctptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctptri_", __uplo, __diag, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctptrs_$descriptor() {
        return ctptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctptrs_$handle() {
        return ctptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctptrs_$address() {
        return ctptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ctptrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ctptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctptrs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctpttf_$descriptor() {
        return ctpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctpttf_$handle() {
        return ctpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctpttf_$address() {
        return ctpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static int ctpttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __arf, MemorySegment __info) {
        var mh$ = ctpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpttf_", __transr, __uplo, __n, __ap, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __ap, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctpttr_$descriptor() {
        return ctpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctpttr_$handle() {
        return ctpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctpttr_$address() {
        return ctpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ctpttr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ctpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpttr_", __uplo, __n, __ap, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrcon_$descriptor() {
        return ctrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrcon_$handle() {
        return ctrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrcon_$address() {
        return ctrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctrcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rcond, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrcon_", __norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrevc_$descriptor() {
        return ctrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrevc_$handle() {
        return ctrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrevc_$address() {
        return ctrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctrevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrevc_", __side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrexc_(char *__compq, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrexc_$descriptor() {
        return ctrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrexc_(char *__compq, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrexc_$handle() {
        return ctrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrexc_(char *__compq, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrexc_$address() {
        return ctrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrexc_(char *__compq, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_integer *__info)
     * }
     */
    public static int ctrexc_(MemorySegment __compq, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __info) {
        var mh$ = ctrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrexc_", __compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __info);
            }
            return (int)mh$.invokeExact(__compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrrfs_$descriptor() {
        return ctrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrrfs_$handle() {
        return ctrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrrfs_$address() {
        return ctrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctrrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrrfs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__w, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrsen_$descriptor() {
        return ctrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__w, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrsen_$handle() {
        return ctrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__w, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrsen_$address() {
        return ctrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__w, __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ctrsen_(MemorySegment __job, MemorySegment __compq, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __w, MemorySegment __m, MemorySegment __s, MemorySegment __sep, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ctrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsen_", __job, __compq, __select, __n, __t, __ldt, __q, __ldq, __w, __m, __s, __sep, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __select, __n, __t, __ldt, __q, __ldq, __w, __m, __s, __sep, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__ldwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrsna_$descriptor() {
        return ctrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__ldwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrsna_$handle() {
        return ctrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__ldwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrsna_$address() {
        return ctrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__ldwork, __CLPK_real *__rwork, __CLPK_integer *__info)
     * }
     */
    public static int ctrsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __sep, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __ldwork, MemorySegment __rwork, MemorySegment __info) {
        var mh$ = ctrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsna_", __job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __rwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __rwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrsyl_$descriptor() {
        return ctrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrsyl_$handle() {
        return ctrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrsyl_$address() {
        return ctrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static int ctrsyl_(MemorySegment __trana, MemorySegment __tranb, MemorySegment __isgn, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __scale, MemorySegment __info) {
        var mh$ = ctrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsyl_", __trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
            }
            return (int)mh$.invokeExact(__trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrti2_$descriptor() {
        return ctrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrti2_$handle() {
        return ctrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrti2_$address() {
        return ctrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ctrti2_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ctrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrti2_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrtri_$descriptor() {
        return ctrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrtri_$handle() {
        return ctrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrtri_$address() {
        return ctrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int ctrtri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = ctrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtri_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrtrs_$descriptor() {
        return ctrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrtrs_$handle() {
        return ctrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrtrs_$address() {
        return ctrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int ctrtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = ctrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtrs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrttf_$descriptor() {
        return ctrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrttf_$handle() {
        return ctrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrttf_$address() {
        return ctrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__arf, __CLPK_integer *__info)
     * }
     */
    public static int ctrttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __arf, MemorySegment __info) {
        var mh$ = ctrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrttf_", __transr, __uplo, __n, __a, __lda, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __lda, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctrttp_$descriptor() {
        return ctrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctrttp_$handle() {
        return ctrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctrttp_$address() {
        return ctrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__ap, __CLPK_integer *__info)
     * }
     */
    public static int ctrttp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ap, MemorySegment __info) {
        var mh$ = ctrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrttp_", __uplo, __n, __a, __lda, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctzrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctzrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctzrqf_$descriptor() {
        return ctzrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctzrqf_$handle() {
        return ctzrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctzrqf_$address() {
        return ctzrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_integer *__info)
     * }
     */
    public static int ctzrqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __info) {
        var mh$ = ctzrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctzrqf_", __m, __n, __a, __lda, __tau, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ctzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ctzrzf_$descriptor() {
        return ctzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ctzrzf_$handle() {
        return ctzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ctzrzf_$address() {
        return ctzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int ctzrzf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = ctzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctzrzf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cung2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cung2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cung2l_$descriptor() {
        return cung2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cung2l_$handle() {
        return cung2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cung2l_$address() {
        return cung2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cung2l_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cung2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cung2l_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cung2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cung2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cung2r_$descriptor() {
        return cung2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cung2r_$handle() {
        return cung2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cung2r_$address() {
        return cung2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cung2r_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cung2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cung2r_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungbr_$descriptor() {
        return cungbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungbr_$handle() {
        return cungbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungbr_$address() {
        return cungbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cungbr_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cungbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungbr_", __vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunghr_$descriptor() {
        return cunghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunghr_$handle() {
        return cunghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunghr_$address() {
        return cunghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunghr_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunghr_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungl2_$descriptor() {
        return cungl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungl2_$handle() {
        return cungl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungl2_$address() {
        return cungl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cungl2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cungl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungl2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunglq_$descriptor() {
        return cunglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunglq_$handle() {
        return cunglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunglq_$address() {
        return cunglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunglq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunglq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungql_$descriptor() {
        return cungql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungql_$handle() {
        return cungql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungql_$address() {
        return cungql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cungql_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cungql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungql_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungqr_$descriptor() {
        return cungqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungqr_$handle() {
        return cungqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungqr_$address() {
        return cungqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cungqr_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cungqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungqr_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungr2_$descriptor() {
        return cungr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungr2_$handle() {
        return cungr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungr2_$address() {
        return cungr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cungr2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = cungr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungr2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungrq_$descriptor() {
        return cungrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungrq_$handle() {
        return cungrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungrq_$address() {
        return cungrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cungrq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cungrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungrq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cungtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cungtr_$descriptor() {
        return cungtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cungtr_$handle() {
        return cungtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cungtr_$address() {
        return cungtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cungtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cungtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungtr_", __uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunm2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunm2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunm2l_$descriptor() {
        return cunm2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunm2l_$handle() {
        return cunm2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunm2l_$address() {
        return cunm2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cunm2l_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = cunm2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunm2l_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunm2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunm2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunm2r_$descriptor() {
        return cunm2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunm2r_$handle() {
        return cunm2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunm2r_$address() {
        return cunm2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cunm2r_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = cunm2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunm2r_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmbr_$descriptor() {
        return cunmbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmbr_$handle() {
        return cunmbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmbr_$address() {
        return cunmbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmbr_(MemorySegment __vect, MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmbr_", __vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmhr_$descriptor() {
        return cunmhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmhr_$handle() {
        return cunmhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmhr_$address() {
        return cunmhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmhr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmhr_", __side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunml2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunml2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunml2_$descriptor() {
        return cunml2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunml2_$handle() {
        return cunml2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunml2_$address() {
        return cunml2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cunml2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = cunml2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunml2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmlq_$descriptor() {
        return cunmlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmlq_$handle() {
        return cunmlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmlq_$address() {
        return cunmlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmlq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmlq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmql_$descriptor() {
        return cunmql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmql_$handle() {
        return cunmql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmql_$address() {
        return cunmql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmql_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmql_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmqr_$descriptor() {
        return cunmqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmqr_$handle() {
        return cunmqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmqr_$address() {
        return cunmqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmqr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmqr_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmr2_$descriptor() {
        return cunmr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmr2_$handle() {
        return cunmr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmr2_$address() {
        return cunmr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cunmr2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = cunmr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmr2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmr3_$descriptor() {
        return cunmr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmr3_$handle() {
        return cunmr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmr3_$address() {
        return cunmr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cunmr3_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = cunmr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmr3_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmrq_$descriptor() {
        return cunmrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmrq_$handle() {
        return cunmrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmrq_$address() {
        return cunmrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmrq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmrq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmrz_$descriptor() {
        return cunmrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmrz_$handle() {
        return cunmrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmrz_$address() {
        return cunmrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmrz_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmrz_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cunmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cunmtr_$descriptor() {
        return cunmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cunmtr_$handle() {
        return cunmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cunmtr_$address() {
        return cunmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int cunmtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = cunmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmtr_", __side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cupgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cupgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cupgtr_$descriptor() {
        return cupgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cupgtr_$handle() {
        return cupgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cupgtr_$address() {
        return cupgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cupgtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = cupgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cupgtr_", __uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cupmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("cupmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor cupmtr_$descriptor() {
        return cupmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle cupmtr_$handle() {
        return cupmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment cupmtr_$address() {
        return cupmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__info)
     * }
     */
    public static int cupmtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = cupmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cupmtr_", __side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsdc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dbdsdc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__q, __CLPK_integer *__iq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dbdsdc_$descriptor() {
        return dbdsdc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__q, __CLPK_integer *__iq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dbdsdc_$handle() {
        return dbdsdc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__q, __CLPK_integer *__iq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dbdsdc_$address() {
        return dbdsdc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__q, __CLPK_integer *__iq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dbdsdc_(MemorySegment __uplo, MemorySegment __compq, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __q, MemorySegment __iq, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dbdsdc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsdc_", __uplo, __compq, __n, __d__, __e, __u, __ldu, __vt, __ldvt, __q, __iq, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __compq, __n, __d__, __e, __u, __ldu, __vt, __ldvt, __q, __iq, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dbdsqr_$descriptor() {
        return dbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dbdsqr_$handle() {
        return dbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dbdsqr_$address() {
        return dbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dbdsqr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ncvt, MemorySegment __nru, MemorySegment __ncc, MemorySegment __d__, MemorySegment __e, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __u, MemorySegment __ldu, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsqr_", __uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ddisna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ddisna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ddisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__sep, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor ddisna_$descriptor() {
        return ddisna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ddisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__sep, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle ddisna_$handle() {
        return ddisna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ddisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__sep, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment ddisna_$address() {
        return ddisna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ddisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__sep, __CLPK_integer *__info)
     * }
     */
    public static int ddisna_(MemorySegment __job, MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __sep, MemorySegment __info) {
        var mh$ = ddisna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ddisna_", __job, __m, __n, __d__, __sep, __info);
            }
            return (int)mh$.invokeExact(__job, __m, __n, __d__, __sep, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__pt, __CLPK_integer *__ldpt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbbrd_$descriptor() {
        return dgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__pt, __CLPK_integer *__ldpt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbbrd_$handle() {
        return dgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__pt, __CLPK_integer *__ldpt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbbrd_$address() {
        return dgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__pt, __CLPK_integer *__ldpt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgbbrd_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __ncc, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __pt, MemorySegment __ldpt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbbrd_", __vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbcon_$descriptor() {
        return dgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbcon_$handle() {
        return dgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbcon_$address() {
        return dgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgbcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbcon_", __norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbequ_$descriptor() {
        return dgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbequ_$handle() {
        return dgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbequ_$address() {
        return dgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dgbequ_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbequ_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbequb_$descriptor() {
        return dgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbequb_$handle() {
        return dgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbequb_$address() {
        return dgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dgbequb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbequb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbrfs_$descriptor() {
        return dgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbrfs_$handle() {
        return dgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbrfs_$address() {
        return dgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgbrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbrfs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbsv_$descriptor() {
        return dgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbsv_$handle() {
        return dgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbsv_$address() {
        return dgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dgbsv_(MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsv_", __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbsvx_$descriptor() {
        return dgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbsvx_$handle() {
        return dgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbsvx_$address() {
        return dgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgbsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsvx_", __fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbtf2_$descriptor() {
        return dgbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbtf2_$handle() {
        return dgbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbtf2_$address() {
        return dgbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dgbtf2_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dgbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtf2_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbtrf_$descriptor() {
        return dgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbtrf_$handle() {
        return dgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbtrf_$address() {
        return dgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dgbtrf_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtrf_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgbtrs_$descriptor() {
        return dgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgbtrs_$handle() {
        return dgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgbtrs_$address() {
        return dgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dgbtrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtrs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgebak_$descriptor() {
        return dgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgebak_$handle() {
        return dgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgebak_$address() {
        return dgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int dgebak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = dgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebak_", __job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgebal_$descriptor() {
        return dgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgebal_$handle() {
        return dgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgebal_$address() {
        return dgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static int dgebal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __info) {
        var mh$ = dgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebal_", __job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgebd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgebd2_$descriptor() {
        return dgebd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgebd2_$handle() {
        return dgebd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgebd2_$address() {
        return dgebd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgebd2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgebd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebd2_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgebrd_$descriptor() {
        return dgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgebrd_$handle() {
        return dgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgebrd_$address() {
        return dgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgebrd_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebrd_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgecon_$descriptor() {
        return dgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgecon_$handle() {
        return dgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgecon_$address() {
        return dgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgecon_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgecon_", __norm, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeequ_$descriptor() {
        return dgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeequ_$handle() {
        return dgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeequ_$address() {
        return dgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dgeequ_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeequ_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeequb_$descriptor() {
        return dgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeequb_$handle() {
        return dgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeequb_$address() {
        return dgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dgeequb_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeequb_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgees_$descriptor() {
        return dgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgees_$handle() {
        return dgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgees_$address() {
        return dgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int dgees_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __wr, MemorySegment __wi, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __work, MemorySegment __lwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = dgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgees_", __jobvs, __sort, __select, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __work, __lwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __work, __lwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeesx_$descriptor() {
        return dgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeesx_$handle() {
        return dgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeesx_$address() {
        return dgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vs, __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int dgeesx_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __wr, MemorySegment __wi, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = dgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeesx_", __jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeev_$descriptor() {
        return dgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeev_$handle() {
        return dgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeev_$address() {
        return dgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgeev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __wr, MemorySegment __wi, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeev_", __jobvl, __jobvr, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeevx_$descriptor() {
        return dgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeevx_$handle() {
        return dgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeevx_$address() {
        return dgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__scale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgeevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __wr, MemorySegment __wi, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __abnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgegs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgegs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgegs_$descriptor() {
        return dgegs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgegs_$handle() {
        return dgegs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgegs_$address() {
        return dgegs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgegs_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgegs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgegs_", __jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgegv_$descriptor() {
        return dgegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgegv_$handle() {
        return dgegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgegv_$address() {
        return dgegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgegv_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgegv_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgehd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgehd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgehd2_$descriptor() {
        return dgehd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgehd2_$handle() {
        return dgehd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgehd2_$address() {
        return dgehd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgehd2_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgehd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgehd2_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgehrd_$descriptor() {
        return dgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgehrd_$handle() {
        return dgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgehrd_$address() {
        return dgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgehrd_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgehrd_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgejsv_$descriptor() {
        return dgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgejsv_$handle() {
        return dgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgejsv_$address() {
        return dgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgejsv_(MemorySegment __joba, MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobr, MemorySegment __jobt, MemorySegment __jobp, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sva, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgejsv_", __joba, __jobu, __jobv, __jobr, __jobt, __jobp, __m, __n, __a, __lda, __sva, __u, __ldu, __v, __ldv, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__joba, __jobu, __jobv, __jobr, __jobt, __jobp, __m, __n, __a, __lda, __sva, __u, __ldu, __v, __ldv, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgelq2_$descriptor() {
        return dgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgelq2_$handle() {
        return dgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgelq2_$address() {
        return dgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgelq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgelqf_$descriptor() {
        return dgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgelqf_$handle() {
        return dgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgelqf_$address() {
        return dgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgelqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgels_$descriptor() {
        return dgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgels_$handle() {
        return dgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgels_$address() {
        return dgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgels_(MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgels_", __trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgelsd_$descriptor() {
        return dgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgelsd_$handle() {
        return dgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgelsd_$address() {
        return dgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgelsd_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsd_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgelss_$descriptor() {
        return dgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgelss_$handle() {
        return dgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgelss_$address() {
        return dgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__s, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgelss_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelss_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgelsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgelsx_$descriptor() {
        return dgelsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgelsx_$handle() {
        return dgelsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgelsx_$address() {
        return dgelsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgelsx_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgelsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsx_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgelsy_$descriptor() {
        return dgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgelsy_$handle() {
        return dgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgelsy_$address() {
        return dgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgelsy_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsy_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeql2_$descriptor() {
        return dgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeql2_$handle() {
        return dgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeql2_$address() {
        return dgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgeql2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeql2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeqlf_$descriptor() {
        return dgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeqlf_$handle() {
        return dgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeqlf_$address() {
        return dgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgeqlf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqlf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeqp3_$descriptor() {
        return dgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeqp3_$handle() {
        return dgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeqp3_$address() {
        return dgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgeqp3_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqp3_", __m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeqpf_$descriptor() {
        return dgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeqpf_$handle() {
        return dgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeqpf_$address() {
        return dgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgeqpf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqpf_", __m, __n, __a, __lda, __jpvt, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeqr2_$descriptor() {
        return dgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeqr2_$handle() {
        return dgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeqr2_$address() {
        return dgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgeqr2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqr2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgeqrf_$descriptor() {
        return dgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgeqrf_$handle() {
        return dgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgeqrf_$address() {
        return dgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgeqrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgerfs_$descriptor() {
        return dgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgerfs_$handle() {
        return dgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgerfs_$address() {
        return dgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgerfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerfs_", __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgerq2_$descriptor() {
        return dgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgerq2_$handle() {
        return dgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgerq2_$address() {
        return dgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dgerq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgerqf_$descriptor() {
        return dgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgerqf_$handle() {
        return dgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgerqf_$address() {
        return dgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgerqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgesc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static FunctionDescriptor dgesc2_$descriptor() {
        return dgesc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static MethodHandle dgesc2_$handle() {
        return dgesc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static MemorySegment dgesc2_$address() {
        return dgesc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_doublereal *__scale)
     * }
     */
    public static int dgesc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rhs, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __scale) {
        var mh$ = dgesc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesc2_", __n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgesdd_$descriptor() {
        return dgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgesdd_$handle() {
        return dgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgesdd_$address() {
        return dgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgesdd_(MemorySegment __jobz, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesdd_", __jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgesv_$descriptor() {
        return dgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgesv_$handle() {
        return dgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgesv_$address() {
        return dgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dgesv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesv_", __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgesvd_$descriptor() {
        return dgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgesvd_$handle() {
        return dgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgesvd_$address() {
        return dgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgesvd_(MemorySegment __jobu, MemorySegment __jobvt, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvd_", __jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgesvj_$descriptor() {
        return dgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgesvj_$handle() {
        return dgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgesvj_$address() {
        return dgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgesvj_(MemorySegment __joba, MemorySegment __jobu, MemorySegment __jobv, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sva, MemorySegment __mv, MemorySegment __v, MemorySegment __ldv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvj_", __joba, __jobu, __jobv, __m, __n, __a, __lda, __sva, __mv, __v, __ldv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__joba, __jobu, __jobv, __m, __n, __a, __lda, __sva, __mv, __v, __ldv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgesvx_$descriptor() {
        return dgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgesvx_$handle() {
        return dgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgesvx_$address() {
        return dgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgesvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvx_", __fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgetc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgetc2_$descriptor() {
        return dgetc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgetc2_$handle() {
        return dgetc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgetc2_$address() {
        return dgetc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static int dgetc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __info) {
        var mh$ = dgetc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetc2_", __n, __a, __lda, __ipiv, __jpiv, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __jpiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgetf2_$descriptor() {
        return dgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgetf2_$handle() {
        return dgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgetf2_$address() {
        return dgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dgetf2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetf2_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgetrf_$descriptor() {
        return dgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgetrf_$handle() {
        return dgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgetrf_$address() {
        return dgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dgetrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrf_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgetri_$descriptor() {
        return dgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgetri_$handle() {
        return dgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgetri_$address() {
        return dgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgetri_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetri_", __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgetrs_$descriptor() {
        return dgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgetrs_$handle() {
        return dgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgetrs_$address() {
        return dgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dgetrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrs_", __trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggbak_$descriptor() {
        return dggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggbak_$handle() {
        return dggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggbak_$address() {
        return dggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int dggbak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = dggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggbak_", __job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggbal_$descriptor() {
        return dggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggbal_$handle() {
        return dggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggbal_$address() {
        return dggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dggbal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __work, MemorySegment __info) {
        var mh$ = dggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggbal_", __job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgges_$descriptor() {
        return dgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgges_$handle() {
        return dgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgges_$address() {
        return dgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int dgges_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = dgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgges_", __jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggesx_$descriptor() {
        return dggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggesx_$handle() {
        return dggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggesx_$address() {
        return dggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int dggesx_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = dggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggesx_", __jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggev_$descriptor() {
        return dggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggev_$handle() {
        return dggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggev_$address() {
        return dggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dggev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggev_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggevx_$descriptor() {
        return dggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggevx_$handle() {
        return dggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggevx_$address() {
        return dggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale, __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm, __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int dggevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __abnrm, MemorySegment __bbnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = dggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __iwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __iwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggglm_$descriptor() {
        return dggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggglm_$handle() {
        return dggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggglm_$address() {
        return dggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dggglm_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __d__, MemorySegment __x, MemorySegment __y, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggglm_", __n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgghrd_$descriptor() {
        return dgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgghrd_$handle() {
        return dgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgghrd_$address() {
        return dgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int dgghrd_(MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = dgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgghrd_", __compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgglse_$descriptor() {
        return dgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgglse_$handle() {
        return dgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgglse_$address() {
        return dgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgglse_(MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __d__, MemorySegment __x, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgglse_", __m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggqrf_$descriptor() {
        return dggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggqrf_$handle() {
        return dggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggqrf_$address() {
        return dggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dggqrf_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggqrf_", __n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggrqf_$descriptor() {
        return dggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggrqf_$handle() {
        return dggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggrqf_$address() {
        return dggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__taua, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__taub, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dggrqf_(MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggrqf_", __m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggsvd_$descriptor() {
        return dggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggsvd_$handle() {
        return dggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggsvd_$address() {
        return dggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dggsvd_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvd_", __jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dggsvp_$descriptor() {
        return dggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dggsvp_$handle() {
        return dggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dggsvp_$address() {
        return dggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dggsvp_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __k, MemorySegment __l, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __iwork, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvp_", __jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgsvj0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgsvj0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgsvj0_$descriptor() {
        return dgsvj0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgsvj0_$handle() {
        return dgsvj0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgsvj0_$address() {
        return dgsvj0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgsvj0_(MemorySegment __jobv, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __sva, MemorySegment __mv, MemorySegment __v, MemorySegment __ldv, MemorySegment __eps, MemorySegment __sfmin, MemorySegment __tol, MemorySegment __nsweep, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgsvj0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgsvj0_", __jobv, __m, __n, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobv, __m, __n, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgsvj1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgsvj1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgsvj1_$descriptor() {
        return dgsvj1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgsvj1_$handle() {
        return dgsvj1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgsvj1_$address() {
        return dgsvj1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol, __CLPK_integer *__nsweep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dgsvj1_(MemorySegment __jobv, MemorySegment __m, MemorySegment __n, MemorySegment __n1, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __sva, MemorySegment __mv, MemorySegment __v, MemorySegment __ldv, MemorySegment __eps, MemorySegment __sfmin, MemorySegment __tol, MemorySegment __nsweep, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dgsvj1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgsvj1_", __jobv, __m, __n, __n1, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobv, __m, __n, __n1, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgtcon_$descriptor() {
        return dgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgtcon_$handle() {
        return dgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgtcon_$address() {
        return dgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgtcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtcon_", __norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgtrfs_$descriptor() {
        return dgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgtrfs_$handle() {
        return dgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgtrfs_$address() {
        return dgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgtrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtrfs_", __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgtsv_$descriptor() {
        return dgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgtsv_$handle() {
        return dgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgtsv_$address() {
        return dgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dgtsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtsv_", __n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgtsvx_$descriptor() {
        return dgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgtsvx_$handle() {
        return dgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgtsvx_$address() {
        return dgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__dlf, __CLPK_doublereal *__df, __CLPK_doublereal *__duf, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dgtsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtsvx_", __fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgttrf_(__CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgttrf_$descriptor() {
        return dgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgttrf_(__CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgttrf_$handle() {
        return dgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgttrf_(__CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgttrf_$address() {
        return dgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgttrf_(__CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dgttrf_(MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgttrf_", __n, __dl, __d__, __du, __du2, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__n, __dl, __d__, __du, __du2, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dgttrs_$descriptor() {
        return dgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dgttrs_$handle() {
        return dgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dgttrs_$address() {
        return dgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dgttrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgttrs_", __trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dgtts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor dgtts2_$descriptor() {
        return dgtts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle dgtts2_$handle() {
        return dgtts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment dgtts2_$address() {
        return dgtts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__du2, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int dgtts2_(MemorySegment __itrans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = dgtts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtts2_", __itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
            }
            return (int)mh$.invokeExact(__itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dhgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dhgeqz_$descriptor() {
        return dhgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dhgeqz_$handle() {
        return dhgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dhgeqz_$address() {
        return dhgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dhgeqz_(MemorySegment __job, MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __t, MemorySegment __ldt, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dhgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhgeqz_", __job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dhsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dhsein_$descriptor() {
        return dhsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dhsein_$handle() {
        return dhsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dhsein_$address() {
        return dhsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dhsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static int dhsein_(MemorySegment __side, MemorySegment __eigsrc, MemorySegment __initv, MemorySegment __select, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __ifaill, MemorySegment __ifailr, MemorySegment __info) {
        var mh$ = dhsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhsein_", __side, __eigsrc, __initv, __select, __n, __h__, __ldh, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __ifaill, __ifailr, __info);
            }
            return (int)mh$.invokeExact(__side, __eigsrc, __initv, __select, __n, __h__, __ldh, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __ifaill, __ifailr, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dhseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dhseqr_$descriptor() {
        return dhseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dhseqr_$handle() {
        return dhseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dhseqr_$address() {
        return dhseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dhseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dhseqr_(MemorySegment __job, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dhseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhseqr_", __job, __compz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class disnan_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("disnan_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_logical disnan_(__CLPK_doublereal *__din)
     * }
     */
    public static FunctionDescriptor disnan_$descriptor() {
        return disnan_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_logical disnan_(__CLPK_doublereal *__din)
     * }
     */
    public static MethodHandle disnan_$handle() {
        return disnan_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_logical disnan_(__CLPK_doublereal *__din)
     * }
     */
    public static MemorySegment disnan_$address() {
        return disnan_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_logical disnan_(__CLPK_doublereal *__din)
     * }
     */
    public static int disnan_(MemorySegment __din) {
        var mh$ = disnan_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("disnan_", __din);
            }
            return (int)mh$.invokeExact(__din);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlabad_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlabad_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlabad_(__CLPK_doublereal *__small, __CLPK_doublereal *__large)
     * }
     */
    public static FunctionDescriptor dlabad_$descriptor() {
        return dlabad_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlabad_(__CLPK_doublereal *__small, __CLPK_doublereal *__large)
     * }
     */
    public static MethodHandle dlabad_$handle() {
        return dlabad_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlabad_(__CLPK_doublereal *__small, __CLPK_doublereal *__large)
     * }
     */
    public static MemorySegment dlabad_$address() {
        return dlabad_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlabad_(__CLPK_doublereal *__small, __CLPK_doublereal *__large)
     * }
     */
    public static int dlabad_(MemorySegment __small, MemorySegment __large) {
        var mh$ = dlabad_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlabad_", __small, __large);
            }
            return (int)mh$.invokeExact(__small, __large);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlabrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlabrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor dlabrd_$descriptor() {
        return dlabrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle dlabrd_$handle() {
        return dlabrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment dlabrd_$address() {
        return dlabrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int dlabrd_(MemorySegment __m, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __x, MemorySegment __ldx, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = dlabrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlabrd_", __m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
            }
            return (int)mh$.invokeExact(__m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlacn2_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static FunctionDescriptor dlacn2_$descriptor() {
        return dlacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlacn2_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MethodHandle dlacn2_$handle() {
        return dlacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlacn2_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MemorySegment dlacn2_$address() {
        return dlacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlacn2_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static int dlacn2_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __isgn, MemorySegment __est, MemorySegment __kase, MemorySegment __isave) {
        var mh$ = dlacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacn2_", __n, __v, __x, __isgn, __est, __kase, __isave);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __isgn, __est, __kase, __isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlacon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlacon_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static FunctionDescriptor dlacon_$descriptor() {
        return dlacon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlacon_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static MethodHandle dlacon_$handle() {
        return dlacon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlacon_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static MemorySegment dlacon_$address() {
        return dlacon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlacon_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x, __CLPK_integer *__isgn, __CLPK_doublereal *__est, __CLPK_integer *__kase)
     * }
     */
    public static int dlacon_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __isgn, MemorySegment __est, MemorySegment __kase) {
        var mh$ = dlacon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacon_", __n, __v, __x, __isgn, __est, __kase);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __isgn, __est, __kase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor dlacpy_$descriptor() {
        return dlacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle dlacpy_$handle() {
        return dlacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment dlacpy_$address() {
        return dlacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int dlacpy_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = dlacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacpy_", __uplo, __m, __n, __a, __lda, __b, __ldb);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __a, __lda, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dladiv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dladiv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dladiv_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__p, __CLPK_doublereal *__q)
     * }
     */
    public static FunctionDescriptor dladiv_$descriptor() {
        return dladiv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dladiv_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__p, __CLPK_doublereal *__q)
     * }
     */
    public static MethodHandle dladiv_$handle() {
        return dladiv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dladiv_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__p, __CLPK_doublereal *__q)
     * }
     */
    public static MemorySegment dladiv_$address() {
        return dladiv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dladiv_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__p, __CLPK_doublereal *__q)
     * }
     */
    public static int dladiv_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __d__, MemorySegment __p, MemorySegment __q) {
        var mh$ = dladiv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dladiv_", __a, __b, __c__, __d__, __p, __q);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __d__, __p, __q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlae2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlae2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlae2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2)
     * }
     */
    public static FunctionDescriptor dlae2_$descriptor() {
        return dlae2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlae2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2)
     * }
     */
    public static MethodHandle dlae2_$handle() {
        return dlae2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlae2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2)
     * }
     */
    public static MemorySegment dlae2_$address() {
        return dlae2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlae2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2)
     * }
     */
    public static int dlae2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2) {
        var mh$ = dlae2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlae2_", __a, __b, __c__, __rt1, __rt2);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_doublereal *__abstol, __CLPK_doublereal *__reltol, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_integer *__nval, __CLPK_doublereal *__ab, __CLPK_doublereal *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaebz_$descriptor() {
        return dlaebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_doublereal *__abstol, __CLPK_doublereal *__reltol, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_integer *__nval, __CLPK_doublereal *__ab, __CLPK_doublereal *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaebz_$handle() {
        return dlaebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_doublereal *__abstol, __CLPK_doublereal *__reltol, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_integer *__nval, __CLPK_doublereal *__ab, __CLPK_doublereal *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaebz_$address() {
        return dlaebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_doublereal *__abstol, __CLPK_doublereal *__reltol, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_integer *__nval, __CLPK_doublereal *__ab, __CLPK_doublereal *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlaebz_(MemorySegment __ijob, MemorySegment __nitmax, MemorySegment __n, MemorySegment __mmax, MemorySegment __minp, MemorySegment __nbmin, MemorySegment __abstol, MemorySegment __reltol, MemorySegment __pivmin, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __nval, MemorySegment __ab, MemorySegment __c__, MemorySegment __mout, MemorySegment __nab, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlaebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaebz_", __ijob, __nitmax, __n, __mmax, __minp, __nbmin, __abstol, __reltol, __pivmin, __d__, __e, __e2, __nval, __ab, __c__, __mout, __nab, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__ijob, __nitmax, __n, __mmax, __minp, __nbmin, __abstol, __reltol, __pivmin, __d__, __e, __e2, __nval, __ab, __c__, __mout, __nab, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed0_$descriptor() {
        return dlaed0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed0_$handle() {
        return dlaed0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed0_$address() {
        return dlaed0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__qstore, __CLPK_integer *__ldqs, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlaed0_(MemorySegment __icompq, MemorySegment __qsiz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __qstore, MemorySegment __ldqs, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlaed0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed0_", __icompq, __qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed1_$descriptor() {
        return dlaed1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed1_$handle() {
        return dlaed1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed1_$address() {
        return dlaed1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlaed1_(MemorySegment __n, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlaed1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed1_", __n, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed2_$descriptor() {
        return dlaed2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed2_$handle() {
        return dlaed2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed2_$address() {
        return dlaed2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static int dlaed2_(MemorySegment __k, MemorySegment __n, MemorySegment __n1, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __z__, MemorySegment __dlamda, MemorySegment __w, MemorySegment __q2, MemorySegment __indx, MemorySegment __indxc, MemorySegment __indxp, MemorySegment __coltyp, MemorySegment __info) {
        var mh$ = dlaed2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed2_", __k, __n, __n1, __d__, __q, __ldq, __indxq, __rho, __z__, __dlamda, __w, __q2, __indx, __indxc, __indxp, __coltyp, __info);
            }
            return (int)mh$.invokeExact(__k, __n, __n1, __d__, __q, __ldq, __indxq, __rho, __z__, __dlamda, __w, __q2, __indx, __indxc, __indxp, __coltyp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed3_$descriptor() {
        return dlaed3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed3_$handle() {
        return dlaed3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed3_$address() {
        return dlaed3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static int dlaed3_(MemorySegment __k, MemorySegment __n, MemorySegment __n1, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __rho, MemorySegment __dlamda, MemorySegment __q2, MemorySegment __indx, MemorySegment __ctot, MemorySegment __w, MemorySegment __s, MemorySegment __info) {
        var mh$ = dlaed3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed3_", __k, __n, __n1, __d__, __q, __ldq, __rho, __dlamda, __q2, __indx, __ctot, __w, __s, __info);
            }
            return (int)mh$.invokeExact(__k, __n, __n1, __d__, __q, __ldq, __rho, __dlamda, __q2, __indx, __ctot, __w, __s, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed4_$descriptor() {
        return dlaed4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed4_$handle() {
        return dlaed4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed4_$address() {
        return dlaed4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam, __CLPK_integer *__info)
     * }
     */
    public static int dlaed4_(MemorySegment __n, MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __dlam, MemorySegment __info) {
        var mh$ = dlaed4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed4_", __n, __i__, __d__, __z__, __delta, __rho, __dlam, __info);
            }
            return (int)mh$.invokeExact(__n, __i__, __d__, __z__, __delta, __rho, __dlam, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam)
     * }
     */
    public static FunctionDescriptor dlaed5_$descriptor() {
        return dlaed5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam)
     * }
     */
    public static MethodHandle dlaed5_$handle() {
        return dlaed5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam)
     * }
     */
    public static MemorySegment dlaed5_$address() {
        return dlaed5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlam)
     * }
     */
    public static int dlaed5_(MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __dlam) {
        var mh$ = dlaed5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed5_", __i__, __d__, __z__, __delta, __rho, __dlam);
            }
            return (int)mh$.invokeExact(__i__, __d__, __z__, __delta, __rho, __dlam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed6_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed6_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_doublereal *__rho, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__finit, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed6_$descriptor() {
        return dlaed6_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_doublereal *__rho, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__finit, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed6_$handle() {
        return dlaed6_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_doublereal *__rho, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__finit, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed6_$address() {
        return dlaed6_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_doublereal *__rho, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__finit, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static int dlaed6_(MemorySegment __kniter, MemorySegment __orgati, MemorySegment __rho, MemorySegment __d__, MemorySegment __z__, MemorySegment __finit, MemorySegment __tau, MemorySegment __info) {
        var mh$ = dlaed6_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed6_", __kniter, __orgati, __rho, __d__, __z__, __finit, __tau, __info);
            }
            return (int)mh$.invokeExact(__kniter, __orgati, __rho, __d__, __z__, __finit, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed7_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed7_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed7_$descriptor() {
        return dlaed7_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed7_$handle() {
        return dlaed7_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed7_$address() {
        return dlaed7_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlaed7_(MemorySegment __icompq, MemorySegment __n, MemorySegment __qsiz, MemorySegment __tlvls, MemorySegment __curlvl, MemorySegment __curpbm, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __qstore, MemorySegment __qptr, MemorySegment __prmptr, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlaed7_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed7_", __icompq, __n, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __n, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed8_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed8_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed8_$descriptor() {
        return dlaed8_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed8_$handle() {
        return dlaed8_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed8_$address() {
        return dlaed8_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt, __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static int dlaed8_(MemorySegment __icompq, MemorySegment __k, MemorySegment __n, MemorySegment __qsiz, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __z__, MemorySegment __dlamda, MemorySegment __q2, MemorySegment __ldq2, MemorySegment __w, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __indxp, MemorySegment __indx, MemorySegment __info) {
        var mh$ = dlaed8_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed8_", __icompq, __k, __n, __qsiz, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __perm, __givptr, __givcol, __givnum, __indxp, __indx, __info);
            }
            return (int)mh$.invokeExact(__icompq, __k, __n, __qsiz, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __perm, __givptr, __givcol, __givnum, __indxp, __indx, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaed9_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaed9_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaed9_$descriptor() {
        return dlaed9_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaed9_$handle() {
        return dlaed9_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaed9_$address() {
        return dlaed9_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static int dlaed9_(MemorySegment __k, MemorySegment __kstart, MemorySegment __kstop, MemorySegment __n, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __rho, MemorySegment __dlamda, MemorySegment __w, MemorySegment __s, MemorySegment __lds, MemorySegment __info) {
        var mh$ = dlaed9_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaed9_", __k, __kstart, __kstop, __n, __d__, __q, __ldq, __rho, __dlamda, __w, __s, __lds, __info);
            }
            return (int)mh$.invokeExact(__k, __kstart, __kstop, __n, __d__, __q, __ldq, __rho, __dlamda, __w, __s, __lds, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaeda_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaeda_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__q, __CLPK_integer *__qptr, __CLPK_doublereal *__z__, __CLPK_doublereal *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaeda_$descriptor() {
        return dlaeda_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__q, __CLPK_integer *__qptr, __CLPK_doublereal *__z__, __CLPK_doublereal *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaeda_$handle() {
        return dlaeda_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__q, __CLPK_integer *__qptr, __CLPK_doublereal *__z__, __CLPK_doublereal *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaeda_$address() {
        return dlaeda_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_doublereal *__givnum, __CLPK_doublereal *__q, __CLPK_integer *__qptr, __CLPK_doublereal *__z__, __CLPK_doublereal *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static int dlaeda_(MemorySegment __n, MemorySegment __tlvls, MemorySegment __curlvl, MemorySegment __curpbm, MemorySegment __prmptr, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __q, MemorySegment __qptr, MemorySegment __z__, MemorySegment __ztemp, MemorySegment __info) {
        var mh$ = dlaeda_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaeda_", __n, __tlvls, __curlvl, __curpbm, __prmptr, __perm, __givptr, __givcol, __givnum, __q, __qptr, __z__, __ztemp, __info);
            }
            return (int)mh$.invokeExact(__n, __tlvls, __curlvl, __curpbm, __prmptr, __perm, __givptr, __givcol, __givnum, __q, __qptr, __z__, __ztemp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vr, __CLPK_doublereal *__vi, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_doublereal *__bignum, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaein_$descriptor() {
        return dlaein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vr, __CLPK_doublereal *__vi, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_doublereal *__bignum, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaein_$handle() {
        return dlaein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vr, __CLPK_doublereal *__vi, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_doublereal *__bignum, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaein_$address() {
        return dlaein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__vr, __CLPK_doublereal *__vi, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_doublereal *__eps3, __CLPK_doublereal *__smlnum, __CLPK_doublereal *__bignum, __CLPK_integer *__info)
     * }
     */
    public static int dlaein_(MemorySegment __rightv, MemorySegment __noinit, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __vr, MemorySegment __vi, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __eps3, MemorySegment __smlnum, MemorySegment __bignum, MemorySegment __info) {
        var mh$ = dlaein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaein_", __rightv, __noinit, __n, __h__, __ldh, __wr, __wi, __vr, __vi, __b, __ldb, __work, __eps3, __smlnum, __bignum, __info);
            }
            return (int)mh$.invokeExact(__rightv, __noinit, __n, __h__, __ldh, __wr, __wi, __vr, __vi, __b, __ldb, __work, __eps3, __smlnum, __bignum, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaev2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaev2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaev2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublereal *__sn1)
     * }
     */
    public static FunctionDescriptor dlaev2_$descriptor() {
        return dlaev2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaev2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublereal *__sn1)
     * }
     */
    public static MethodHandle dlaev2_$handle() {
        return dlaev2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaev2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublereal *__sn1)
     * }
     */
    public static MemorySegment dlaev2_$address() {
        return dlaev2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaev2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1, __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1, __CLPK_doublereal *__sn1)
     * }
     */
    public static int dlaev2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2, MemorySegment __cs1, MemorySegment __sn1) {
        var mh$ = dlaev2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaev2_", __a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaexc_$descriptor() {
        return dlaexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaexc_$handle() {
        return dlaexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaexc_$address() {
        return dlaexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlaexc_(MemorySegment __wantq, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __j1, MemorySegment __n1, MemorySegment __n2, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlaexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaexc_", __wantq, __n, __t, __ldt, __q, __ldq, __j1, __n1, __n2, __work, __info);
            }
            return (int)mh$.invokeExact(__wantq, __n, __t, __ldt, __q, __ldq, __j1, __n1, __n2, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlag2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlag2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlag2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__safmin, __CLPK_doublereal *__scale1, __CLPK_doublereal *__scale2, __CLPK_doublereal *__wr1, __CLPK_doublereal *__wr2, __CLPK_doublereal *__wi)
     * }
     */
    public static FunctionDescriptor dlag2_$descriptor() {
        return dlag2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlag2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__safmin, __CLPK_doublereal *__scale1, __CLPK_doublereal *__scale2, __CLPK_doublereal *__wr1, __CLPK_doublereal *__wr2, __CLPK_doublereal *__wi)
     * }
     */
    public static MethodHandle dlag2_$handle() {
        return dlag2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlag2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__safmin, __CLPK_doublereal *__scale1, __CLPK_doublereal *__scale2, __CLPK_doublereal *__wr1, __CLPK_doublereal *__wr2, __CLPK_doublereal *__wi)
     * }
     */
    public static MemorySegment dlag2_$address() {
        return dlag2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlag2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__safmin, __CLPK_doublereal *__scale1, __CLPK_doublereal *__scale2, __CLPK_doublereal *__wr1, __CLPK_doublereal *__wr2, __CLPK_doublereal *__wi)
     * }
     */
    public static int dlag2_(MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __safmin, MemorySegment __scale1, MemorySegment __scale2, MemorySegment __wr1, MemorySegment __wr2, MemorySegment __wi) {
        var mh$ = dlag2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlag2_", __a, __lda, __b, __ldb, __safmin, __scale1, __scale2, __wr1, __wr2, __wi);
            }
            return (int)mh$.invokeExact(__a, __lda, __b, __ldb, __safmin, __scale1, __scale2, __wr1, __wr2, __wi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlag2s_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlag2s_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlag2s_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlag2s_$descriptor() {
        return dlag2s_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlag2s_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlag2s_$handle() {
        return dlag2s_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlag2s_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlag2s_$address() {
        return dlag2s_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlag2s_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static int dlag2s_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sa, MemorySegment __ldsa, MemorySegment __info) {
        var mh$ = dlag2s_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlag2s_", __m, __n, __a, __lda, __sa, __ldsa, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __sa, __ldsa, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlags2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlags2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublereal *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublereal *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublereal *__snu, __CLPK_doublereal *__csv, __CLPK_doublereal *__snv, __CLPK_doublereal *__csq, __CLPK_doublereal *__snq)
     * }
     */
    public static FunctionDescriptor dlags2_$descriptor() {
        return dlags2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublereal *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublereal *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublereal *__snu, __CLPK_doublereal *__csv, __CLPK_doublereal *__snv, __CLPK_doublereal *__csq, __CLPK_doublereal *__snq)
     * }
     */
    public static MethodHandle dlags2_$handle() {
        return dlags2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublereal *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublereal *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublereal *__snu, __CLPK_doublereal *__csv, __CLPK_doublereal *__snv, __CLPK_doublereal *__csq, __CLPK_doublereal *__snq)
     * }
     */
    public static MemorySegment dlags2_$address() {
        return dlags2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1, __CLPK_doublereal *__a2, __CLPK_doublereal *__a3, __CLPK_doublereal *__b1, __CLPK_doublereal *__b2, __CLPK_doublereal *__b3, __CLPK_doublereal *__csu, __CLPK_doublereal *__snu, __CLPK_doublereal *__csv, __CLPK_doublereal *__snv, __CLPK_doublereal *__csq, __CLPK_doublereal *__snq)
     * }
     */
    public static int dlags2_(MemorySegment __upper, MemorySegment __a1, MemorySegment __a2, MemorySegment __a3, MemorySegment __b1, MemorySegment __b2, MemorySegment __b3, MemorySegment __csu, MemorySegment __snu, MemorySegment __csv, MemorySegment __snv, MemorySegment __csq, MemorySegment __snq) {
        var mh$ = dlags2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlags2_", __upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
            }
            return (int)mh$.invokeExact(__upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagtf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlagtf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlagtf_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__lambda, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__tol, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlagtf_$descriptor() {
        return dlagtf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlagtf_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__lambda, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__tol, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlagtf_$handle() {
        return dlagtf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlagtf_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__lambda, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__tol, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlagtf_$address() {
        return dlagtf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlagtf_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__lambda, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__tol, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static int dlagtf_(MemorySegment __n, MemorySegment __a, MemorySegment __lambda, MemorySegment __b, MemorySegment __c__, MemorySegment __tol, MemorySegment __d__, MemorySegment __in, MemorySegment __info) {
        var mh$ = dlagtf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagtf_", __n, __a, __lambda, __b, __c__, __tol, __d__, __in, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lambda, __b, __c__, __tol, __d__, __in, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagtm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlagtm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor dlagtm_$descriptor() {
        return dlagtm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle dlagtm_$handle() {
        return dlagtm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment dlagtm_$address() {
        return dlagtm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__alpha, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__beta, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int dlagtm_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __alpha, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __x, MemorySegment __ldx, MemorySegment __beta, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = dlagtm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagtm_", __trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagts_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlagts_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_doublereal *__y, __CLPK_doublereal *__tol, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlagts_$descriptor() {
        return dlagts_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_doublereal *__y, __CLPK_doublereal *__tol, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlagts_$handle() {
        return dlagts_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_doublereal *__y, __CLPK_doublereal *__tol, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlagts_$address() {
        return dlagts_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_doublereal *__y, __CLPK_doublereal *__tol, __CLPK_integer *__info)
     * }
     */
    public static int dlagts_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __d__, MemorySegment __in, MemorySegment __y, MemorySegment __tol, MemorySegment __info) {
        var mh$ = dlagts_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagts_", __job, __n, __a, __b, __c__, __d__, __in, __y, __tol, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __b, __c__, __d__, __in, __y, __tol, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagv2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlagv2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlagv2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__csl, __CLPK_doublereal *__snl, __CLPK_doublereal *__csr, __CLPK_doublereal *__snr)
     * }
     */
    public static FunctionDescriptor dlagv2_$descriptor() {
        return dlagv2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlagv2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__csl, __CLPK_doublereal *__snl, __CLPK_doublereal *__csr, __CLPK_doublereal *__snr)
     * }
     */
    public static MethodHandle dlagv2_$handle() {
        return dlagv2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlagv2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__csl, __CLPK_doublereal *__snl, __CLPK_doublereal *__csr, __CLPK_doublereal *__snr)
     * }
     */
    public static MemorySegment dlagv2_$address() {
        return dlagv2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlagv2_(__CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__csl, __CLPK_doublereal *__snl, __CLPK_doublereal *__csr, __CLPK_doublereal *__snr)
     * }
     */
    public static int dlagv2_(MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __csl, MemorySegment __snl, MemorySegment __csr, MemorySegment __snr) {
        var mh$ = dlagv2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagv2_", __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __csl, __snl, __csr, __snr);
            }
            return (int)mh$.invokeExact(__a, __lda, __b, __ldb, __alphar, __alphai, __beta, __csl, __snl, __csr, __snr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlahqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlahqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlahqr_$descriptor() {
        return dlahqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlahqr_$handle() {
        return dlahqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlahqr_$address() {
        return dlahqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int dlahqr_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = dlahqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlahqr_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlahr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlahr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor dlahr2_$descriptor() {
        return dlahr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle dlahr2_$handle() {
        return dlahr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment dlahr2_$address() {
        return dlahr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int dlahr2_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = dlahr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlahr2_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlahrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlahrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor dlahrd_$descriptor() {
        return dlahrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle dlahrd_$handle() {
        return dlahrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment dlahrd_$address() {
        return dlahrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int dlahrd_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = dlahrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlahrd_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaic1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaic1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublereal *__x, __CLPK_doublereal *__sest, __CLPK_doublereal *__w, __CLPK_doublereal *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublereal *__s, __CLPK_doublereal *__c__)
     * }
     */
    public static FunctionDescriptor dlaic1_$descriptor() {
        return dlaic1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublereal *__x, __CLPK_doublereal *__sest, __CLPK_doublereal *__w, __CLPK_doublereal *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublereal *__s, __CLPK_doublereal *__c__)
     * }
     */
    public static MethodHandle dlaic1_$handle() {
        return dlaic1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublereal *__x, __CLPK_doublereal *__sest, __CLPK_doublereal *__w, __CLPK_doublereal *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublereal *__s, __CLPK_doublereal *__c__)
     * }
     */
    public static MemorySegment dlaic1_$address() {
        return dlaic1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublereal *__x, __CLPK_doublereal *__sest, __CLPK_doublereal *__w, __CLPK_doublereal *__gamma, __CLPK_doublereal *__sestpr, __CLPK_doublereal *__s, __CLPK_doublereal *__c__)
     * }
     */
    public static int dlaic1_(MemorySegment __job, MemorySegment __j, MemorySegment __x, MemorySegment __sest, MemorySegment __w, MemorySegment __gamma, MemorySegment __sestpr, MemorySegment __s, MemorySegment __c__) {
        var mh$ = dlaic1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaic1_", __job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
            }
            return (int)mh$.invokeExact(__job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaisnan_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaisnan_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_logical dlaisnan_(__CLPK_doublereal *__din1, __CLPK_doublereal *__din2)
     * }
     */
    public static FunctionDescriptor dlaisnan_$descriptor() {
        return dlaisnan_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_logical dlaisnan_(__CLPK_doublereal *__din1, __CLPK_doublereal *__din2)
     * }
     */
    public static MethodHandle dlaisnan_$handle() {
        return dlaisnan_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_logical dlaisnan_(__CLPK_doublereal *__din1, __CLPK_doublereal *__din2)
     * }
     */
    public static MemorySegment dlaisnan_$address() {
        return dlaisnan_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_logical dlaisnan_(__CLPK_doublereal *__din1, __CLPK_doublereal *__din2)
     * }
     */
    public static int dlaisnan_(MemorySegment __din1, MemorySegment __din2) {
        var mh$ = dlaisnan_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaisnan_", __din1, __din2);
            }
            return (int)mh$.invokeExact(__din1, __din2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaln2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaln2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_doublereal *__smin, __CLPK_doublereal *__ca, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d1, __CLPK_doublereal *__d2, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__scale, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaln2_$descriptor() {
        return dlaln2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_doublereal *__smin, __CLPK_doublereal *__ca, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d1, __CLPK_doublereal *__d2, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__scale, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaln2_$handle() {
        return dlaln2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_doublereal *__smin, __CLPK_doublereal *__ca, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d1, __CLPK_doublereal *__d2, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__scale, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaln2_$address() {
        return dlaln2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_doublereal *__smin, __CLPK_doublereal *__ca, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d1, __CLPK_doublereal *__d2, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__scale, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static int dlaln2_(MemorySegment __ltrans, MemorySegment __na, MemorySegment __nw, MemorySegment __smin, MemorySegment __ca, MemorySegment __a, MemorySegment __lda, MemorySegment __d1, MemorySegment __d2, MemorySegment __b, MemorySegment __ldb, MemorySegment __wr, MemorySegment __wi, MemorySegment __x, MemorySegment __ldx, MemorySegment __scale, MemorySegment __xnorm, MemorySegment __info) {
        var mh$ = dlaln2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaln2_", __ltrans, __na, __nw, __smin, __ca, __a, __lda, __d1, __d2, __b, __ldb, __wr, __wi, __x, __ldx, __scale, __xnorm, __info);
            }
            return (int)mh$.invokeExact(__ltrans, __na, __nw, __smin, __ca, __a, __lda, __d1, __d2, __b, __ldb, __wr, __wi, __x, __ldx, __scale, __xnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlals0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlals0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlals0_$descriptor() {
        return dlals0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlals0_$handle() {
        return dlals0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlals0_$address() {
        return dlals0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlals0_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __poles, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __k, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlals0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlals0_", __icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlalsa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlalsa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlalsa_$descriptor() {
        return dlalsa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlalsa_$handle() {
        return dlalsa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlalsa_$address() {
        return dlalsa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlalsa_(MemorySegment __icompq, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __k, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __poles, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __perm, MemorySegment __givnum, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlalsa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlalsa_", __icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlalsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlalsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlalsd_$descriptor() {
        return dlalsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlalsd_$handle() {
        return dlalsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlalsd_$address() {
        return dlalsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__rcond, __CLPK_integer *__rank, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlalsd_(MemorySegment __uplo, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlalsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlalsd_", __uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamrg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlamrg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__a, __CLPK_integer *__dtrd1, __CLPK_integer *__dtrd2, __CLPK_integer *__index)
     * }
     */
    public static FunctionDescriptor dlamrg_$descriptor() {
        return dlamrg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__a, __CLPK_integer *__dtrd1, __CLPK_integer *__dtrd2, __CLPK_integer *__index)
     * }
     */
    public static MethodHandle dlamrg_$handle() {
        return dlamrg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__a, __CLPK_integer *__dtrd1, __CLPK_integer *__dtrd2, __CLPK_integer *__index)
     * }
     */
    public static MemorySegment dlamrg_$address() {
        return dlamrg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__a, __CLPK_integer *__dtrd1, __CLPK_integer *__dtrd2, __CLPK_integer *__index)
     * }
     */
    public static int dlamrg_(MemorySegment __n1, MemorySegment __n2, MemorySegment __a, MemorySegment __dtrd1, MemorySegment __dtrd2, MemorySegment __index) {
        var mh$ = dlamrg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamrg_", __n1, __n2, __a, __dtrd1, __dtrd2, __index);
            }
            return (int)mh$.invokeExact(__n1, __n2, __a, __dtrd1, __dtrd2, __index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaneg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaneg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer dlaneg_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_doublereal *__sigma, __CLPK_doublereal *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static FunctionDescriptor dlaneg_$descriptor() {
        return dlaneg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer dlaneg_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_doublereal *__sigma, __CLPK_doublereal *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static MethodHandle dlaneg_$handle() {
        return dlaneg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer dlaneg_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_doublereal *__sigma, __CLPK_doublereal *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static MemorySegment dlaneg_$address() {
        return dlaneg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer dlaneg_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_doublereal *__sigma, __CLPK_doublereal *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static int dlaneg_(MemorySegment __n, MemorySegment __d__, MemorySegment __lld, MemorySegment __sigma, MemorySegment __pivmin, MemorySegment __r__) {
        var mh$ = dlaneg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaneg_", __n, __d__, __lld, __sigma, __pivmin, __r__);
            }
            return (int)mh$.invokeExact(__n, __d__, __lld, __sigma, __pivmin, __r__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlangb_$descriptor() {
        return dlangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlangb_$handle() {
        return dlangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlangb_$address() {
        return dlangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double dlangb_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = dlangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlangb_", __norm, __n, __kl, __ku, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlange_$descriptor() {
        return dlange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlange_$handle() {
        return dlange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlange_$address() {
        return dlange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double dlange_(MemorySegment __norm, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = dlange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlange_", __norm, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du)
     * }
     */
    public static FunctionDescriptor dlangt_$descriptor() {
        return dlangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du)
     * }
     */
    public static MethodHandle dlangt_$handle() {
        return dlangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du)
     * }
     */
    public static MemorySegment dlangt_$address() {
        return dlangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlangt_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl, __CLPK_doublereal *__d__, __CLPK_doublereal *__du)
     * }
     */
    public static double dlangt_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du) {
        var mh$ = dlangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlangt_", __norm, __n, __dl, __d__, __du);
            }
            return (double)mh$.invokeExact(__norm, __n, __dl, __d__, __du);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlanhs_$descriptor() {
        return dlanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlanhs_$handle() {
        return dlanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlanhs_$address() {
        return dlanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlanhs_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double dlanhs_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = dlanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanhs_", __norm, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlansb_$descriptor() {
        return dlansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlansb_$handle() {
        return dlansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlansb_$address() {
        return dlansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double dlansb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = dlansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansb_", __norm, __uplo, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlansf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlansf_$descriptor() {
        return dlansf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlansf_$handle() {
        return dlansf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlansf_$address() {
        return dlansf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_doublereal *__work)
     * }
     */
    public static double dlansf_(MemorySegment __norm, MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __work) {
        var mh$ = dlansf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansf_", __norm, __transr, __uplo, __n, __a, __work);
            }
            return (double)mh$.invokeExact(__norm, __transr, __uplo, __n, __a, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlansp_$descriptor() {
        return dlansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlansp_$handle() {
        return dlansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlansp_$address() {
        return dlansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static double dlansp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = dlansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansp_", __norm, __uplo, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlanst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlanst_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e)
     * }
     */
    public static FunctionDescriptor dlanst_$descriptor() {
        return dlanst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlanst_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e)
     * }
     */
    public static MethodHandle dlanst_$handle() {
        return dlanst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlanst_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e)
     * }
     */
    public static MemorySegment dlanst_$address() {
        return dlanst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlanst_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e)
     * }
     */
    public static double dlanst_(MemorySegment __norm, MemorySegment __n, MemorySegment __d__, MemorySegment __e) {
        var mh$ = dlanst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanst_", __norm, __n, __d__, __e);
            }
            return (double)mh$.invokeExact(__norm, __n, __d__, __e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlansy_$descriptor() {
        return dlansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlansy_$handle() {
        return dlansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlansy_$address() {
        return dlansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double dlansy_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = dlansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansy_", __norm, __uplo, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlantb_$descriptor() {
        return dlantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlantb_$handle() {
        return dlantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlantb_$address() {
        return dlantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__work)
     * }
     */
    public static double dlantb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = dlantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantb_", __norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlantp_$descriptor() {
        return dlantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlantp_$handle() {
        return dlantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlantp_$address() {
        return dlantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__work)
     * }
     */
    public static double dlantp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = dlantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantp_", __norm, __uplo, __diag, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlantr_$descriptor() {
        return dlantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlantr_$handle() {
        return dlantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlantr_$address() {
        return dlantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__work)
     * }
     */
    public static double dlantr_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = dlantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantr_", __norm, __uplo, __diag, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanv2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlanv2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlanv2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__rt1r, __CLPK_doublereal *__rt1i, __CLPK_doublereal *__rt2r, __CLPK_doublereal *__rt2i, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn)
     * }
     */
    public static FunctionDescriptor dlanv2_$descriptor() {
        return dlanv2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlanv2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__rt1r, __CLPK_doublereal *__rt1i, __CLPK_doublereal *__rt2r, __CLPK_doublereal *__rt2i, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn)
     * }
     */
    public static MethodHandle dlanv2_$handle() {
        return dlanv2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlanv2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__rt1r, __CLPK_doublereal *__rt1i, __CLPK_doublereal *__rt2r, __CLPK_doublereal *__rt2i, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn)
     * }
     */
    public static MemorySegment dlanv2_$address() {
        return dlanv2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlanv2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_doublereal *__c__, __CLPK_doublereal *__d__, __CLPK_doublereal *__rt1r, __CLPK_doublereal *__rt1i, __CLPK_doublereal *__rt2r, __CLPK_doublereal *__rt2i, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn)
     * }
     */
    public static int dlanv2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __d__, MemorySegment __rt1r, MemorySegment __rt1i, MemorySegment __rt2r, MemorySegment __rt2i, MemorySegment __cs, MemorySegment __sn) {
        var mh$ = dlanv2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanv2_", __a, __b, __c__, __d__, __rt1r, __rt1i, __rt2r, __rt2i, __cs, __sn);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __d__, __rt1r, __rt1i, __rt2r, __rt2i, __cs, __sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapll_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlapll_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlapll_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static FunctionDescriptor dlapll_$descriptor() {
        return dlapll_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlapll_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static MethodHandle dlapll_$handle() {
        return dlapll_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlapll_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static MemorySegment dlapll_$address() {
        return dlapll_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlapll_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__ssmin)
     * }
     */
    public static int dlapll_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __ssmin) {
        var mh$ = dlapll_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapll_", __n, __x, __incx, __y, __incy, __ssmin);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __ssmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static FunctionDescriptor dlapmt_$descriptor() {
        return dlapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MethodHandle dlapmt_$handle() {
        return dlapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MemorySegment dlapmt_$address() {
        return dlapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static int dlapmt_(MemorySegment __forwrd, MemorySegment __m, MemorySegment __n, MemorySegment __x, MemorySegment __ldx, MemorySegment __k) {
        var mh$ = dlapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapmt_", __forwrd, __m, __n, __x, __ldx, __k);
            }
            return (int)mh$.invokeExact(__forwrd, __m, __n, __x, __ldx, __k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlapy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy2_(__CLPK_doublereal *__x, __CLPK_doublereal *__y)
     * }
     */
    public static FunctionDescriptor dlapy2_$descriptor() {
        return dlapy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy2_(__CLPK_doublereal *__x, __CLPK_doublereal *__y)
     * }
     */
    public static MethodHandle dlapy2_$handle() {
        return dlapy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy2_(__CLPK_doublereal *__x, __CLPK_doublereal *__y)
     * }
     */
    public static MemorySegment dlapy2_$address() {
        return dlapy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy2_(__CLPK_doublereal *__x, __CLPK_doublereal *__y)
     * }
     */
    public static double dlapy2_(MemorySegment __x, MemorySegment __y) {
        var mh$ = dlapy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapy2_", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapy3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlapy3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy3_(__CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__)
     * }
     */
    public static FunctionDescriptor dlapy3_$descriptor() {
        return dlapy3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy3_(__CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__)
     * }
     */
    public static MethodHandle dlapy3_$handle() {
        return dlapy3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy3_(__CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__)
     * }
     */
    public static MemorySegment dlapy3_$address() {
        return dlapy3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dlapy3_(__CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__)
     * }
     */
    public static double dlapy3_(MemorySegment __x, MemorySegment __y, MemorySegment __z__) {
        var mh$ = dlapy3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapy3_", __x, __y, __z__);
            }
            return (double)mh$.invokeExact(__x, __y, __z__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqgb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqgb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor dlaqgb_$descriptor() {
        return dlaqgb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle dlaqgb_$handle() {
        return dlaqgb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment dlaqgb_$address() {
        return dlaqgb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int dlaqgb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = dlaqgb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqgb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor dlaqge_$descriptor() {
        return dlaqge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle dlaqge_$handle() {
        return dlaqge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment dlaqge_$address() {
        return dlaqge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int dlaqge_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = dlaqge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqge_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlaqp2_$descriptor() {
        return dlaqp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlaqp2_$handle() {
        return dlaqp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlaqp2_$address() {
        return dlaqp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__work)
     * }
     */
    public static int dlaqp2_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __work) {
        var mh$ = dlaqp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqp2_", __m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__auxv, __CLPK_doublereal *__f, __CLPK_integer *__ldf)
     * }
     */
    public static FunctionDescriptor dlaqps_$descriptor() {
        return dlaqps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__auxv, __CLPK_doublereal *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MethodHandle dlaqps_$handle() {
        return dlaqps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__auxv, __CLPK_doublereal *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MemorySegment dlaqps_$address() {
        return dlaqps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2, __CLPK_doublereal *__auxv, __CLPK_doublereal *__f, __CLPK_integer *__ldf)
     * }
     */
    public static int dlaqps_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __auxv, MemorySegment __f, MemorySegment __ldf) {
        var mh$ = dlaqps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqps_", __m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqr0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqr0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaqr0_$descriptor() {
        return dlaqr0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaqr0_$handle() {
        return dlaqr0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaqr0_$address() {
        return dlaqr0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dlaqr0_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dlaqr0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqr0_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqr1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqr1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqr1_(__CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__sr1, __CLPK_doublereal *__si1, __CLPK_doublereal *__sr2, __CLPK_doublereal *__si2, __CLPK_doublereal *__v)
     * }
     */
    public static FunctionDescriptor dlaqr1_$descriptor() {
        return dlaqr1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqr1_(__CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__sr1, __CLPK_doublereal *__si1, __CLPK_doublereal *__sr2, __CLPK_doublereal *__si2, __CLPK_doublereal *__v)
     * }
     */
    public static MethodHandle dlaqr1_$handle() {
        return dlaqr1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqr1_(__CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__sr1, __CLPK_doublereal *__si1, __CLPK_doublereal *__sr2, __CLPK_doublereal *__si2, __CLPK_doublereal *__v)
     * }
     */
    public static MemorySegment dlaqr1_$address() {
        return dlaqr1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqr1_(__CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__sr1, __CLPK_doublereal *__si1, __CLPK_doublereal *__sr2, __CLPK_doublereal *__si2, __CLPK_doublereal *__v)
     * }
     */
    public static int dlaqr1_(MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __sr1, MemorySegment __si1, MemorySegment __sr2, MemorySegment __si2, MemorySegment __v) {
        var mh$ = dlaqr1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqr1_", __n, __h__, __ldh, __sr1, __si1, __sr2, __si2, __v);
            }
            return (int)mh$.invokeExact(__n, __h__, __ldh, __sr1, __si1, __sr2, __si2, __v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor dlaqr2_$descriptor() {
        return dlaqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle dlaqr2_$handle() {
        return dlaqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment dlaqr2_$address() {
        return dlaqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int dlaqr2_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sr, MemorySegment __si, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = dlaqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqr2_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor dlaqr3_$descriptor() {
        return dlaqr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle dlaqr3_$handle() {
        return dlaqr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment dlaqr3_$address() {
        return dlaqr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_doublereal *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int dlaqr3_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sr, MemorySegment __si, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = dlaqr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqr3_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqr4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqr4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaqr4_$descriptor() {
        return dlaqr4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaqr4_$handle() {
        return dlaqr4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaqr4_$address() {
        return dlaqr4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dlaqr4_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dlaqr4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqr4_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqr5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqr5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublereal *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static FunctionDescriptor dlaqr5_$descriptor() {
        return dlaqr5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublereal *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MethodHandle dlaqr5_$handle() {
        return dlaqr5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublereal *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MemorySegment dlaqr5_$address() {
        return dlaqr5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_doublereal *__sr, __CLPK_doublereal *__si, __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublereal *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublereal *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static int dlaqr5_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __kacc22, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nshfts, MemorySegment __sr, MemorySegment __si, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __v, MemorySegment __ldv, MemorySegment __u, MemorySegment __ldu, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __nh, MemorySegment __wh, MemorySegment __ldwh) {
        var mh$ = dlaqr5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqr5_", __wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __sr, __si, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __sr, __si, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqsb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqsb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor dlaqsb_$descriptor() {
        return dlaqsb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle dlaqsb_$handle() {
        return dlaqsb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment dlaqsb_$address() {
        return dlaqsb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int dlaqsb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = dlaqsb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqsb_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqsp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqsp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor dlaqsp_$descriptor() {
        return dlaqsp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle dlaqsp_$handle() {
        return dlaqsp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment dlaqsp_$address() {
        return dlaqsp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int dlaqsp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = dlaqsp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqsp_", __uplo, __n, __ap, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor dlaqsy_$descriptor() {
        return dlaqsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MethodHandle dlaqsy_$handle() {
        return dlaqsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static MemorySegment dlaqsy_$address() {
        return dlaqsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, char *__equed)
     * }
     */
    public static int dlaqsy_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = dlaqsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqsy_", __uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaqtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaqtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__b, __CLPK_doublereal *__w, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlaqtr_$descriptor() {
        return dlaqtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__b, __CLPK_doublereal *__w, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlaqtr_$handle() {
        return dlaqtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__b, __CLPK_doublereal *__w, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlaqtr_$address() {
        return dlaqtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__b, __CLPK_doublereal *__w, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlaqtr_(MemorySegment __ltran, MemorySegment __l__CLPK_real, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __b, MemorySegment __w, MemorySegment __scale, MemorySegment __x, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlaqtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaqtr_", __ltran, __l__CLPK_real, __n, __t, __ldt, __b, __w, __scale, __x, __work, __info);
            }
            return (int)mh$.invokeExact(__ltran, __l__CLPK_real, __n, __t, __ldt, __b, __w, __scale, __x, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlar1v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlar1v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublereal *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlar1v_$descriptor() {
        return dlar1v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublereal *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlar1v_$handle() {
        return dlar1v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublereal *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlar1v_$address() {
        return dlar1v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__gaptol, __CLPK_doublereal *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid, __CLPK_doublereal *__rqcorr, __CLPK_doublereal *__work)
     * }
     */
    public static int dlar1v_(MemorySegment __n, MemorySegment __b1, MemorySegment __bn, MemorySegment __lambda, MemorySegment __d__, MemorySegment __l, MemorySegment __ld, MemorySegment __lld, MemorySegment __pivmin, MemorySegment __gaptol, MemorySegment __z__, MemorySegment __wantnc, MemorySegment __negcnt, MemorySegment __ztz, MemorySegment __mingma, MemorySegment __r__, MemorySegment __isuppz, MemorySegment __nrminv, MemorySegment __resid, MemorySegment __rqcorr, MemorySegment __work) {
        var mh$ = dlar1v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlar1v_", __n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
            }
            return (int)mh$.invokeExact(__n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlar2v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlar2v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlar2v_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor dlar2v_$descriptor() {
        return dlar2v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlar2v_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle dlar2v_$handle() {
        return dlar2v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlar2v_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment dlar2v_$address() {
        return dlar2v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlar2v_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_doublereal *__y, __CLPK_doublereal *__z__, __CLPK_integer *__incx, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static int dlar2v_(MemorySegment __n, MemorySegment __x, MemorySegment __y, MemorySegment __z__, MemorySegment __incx, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = dlar2v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlar2v_", __n, __x, __y, __z__, __incx, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __y, __z__, __incx, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlarf_$descriptor() {
        return dlarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlarf_$handle() {
        return dlarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlarf_$address() {
        return dlarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static int dlarf_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = dlarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarf_", __side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor dlarfb_$descriptor() {
        return dlarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle dlarfb_$handle() {
        return dlarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment dlarfb_$address() {
        return dlarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int dlarfb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = dlarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfb_", __side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarfg_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static FunctionDescriptor dlarfg_$descriptor() {
        return dlarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarfg_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static MethodHandle dlarfg_$handle() {
        return dlarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarfg_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static MemorySegment dlarfg_$address() {
        return dlarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarfg_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static int dlarfg_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = dlarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfg_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarfp_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static FunctionDescriptor dlarfp_$descriptor() {
        return dlarfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarfp_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static MethodHandle dlarfp_$handle() {
        return dlarfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarfp_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static MemorySegment dlarfp_$address() {
        return dlarfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarfp_(__CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__tau)
     * }
     */
    public static int dlarfp_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = dlarfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfp_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor dlarft_$descriptor() {
        return dlarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle dlarft_$handle() {
        return dlarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment dlarft_$address() {
        return dlarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int dlarft_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = dlarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarft_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlarfx_$descriptor() {
        return dlarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlarfx_$handle() {
        return dlarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlarfx_$address() {
        return dlarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static int dlarfx_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = dlarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfx_", __side, __m, __n, __v, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlargv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlargv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlargv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor dlargv_$descriptor() {
        return dlargv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlargv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle dlargv_$handle() {
        return dlargv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlargv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment dlargv_$address() {
        return dlargv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlargv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_integer *__incc)
     * }
     */
    public static int dlargv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __incc) {
        var mh$ = dlargv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlargv_", __n, __x, __incx, __y, __incy, __c__, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static FunctionDescriptor dlarnv_$descriptor() {
        return dlarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static MethodHandle dlarnv_$handle() {
        return dlarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static MemorySegment dlarnv_$address() {
        return dlarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static int dlarnv_(MemorySegment __idist, MemorySegment __iseed, MemorySegment __n, MemorySegment __x) {
        var mh$ = dlarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarnv_", __idist, __iseed, __n, __x);
            }
            return (int)mh$.invokeExact(__idist, __iseed, __n, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarra_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarra_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarra_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__spltol, __CLPK_doublereal *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarra_$descriptor() {
        return dlarra_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarra_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__spltol, __CLPK_doublereal *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarra_$handle() {
        return dlarra_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarra_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__spltol, __CLPK_doublereal *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarra_$address() {
        return dlarra_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarra_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__spltol, __CLPK_doublereal *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static int dlarra_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __spltol, MemorySegment __tnrm, MemorySegment __nsplit, MemorySegment __isplit, MemorySegment __info) {
        var mh$ = dlarra_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarra_", __n, __d__, __e, __e2, __spltol, __tnrm, __nsplit, __isplit, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __e2, __spltol, __tnrm, __nsplit, __isplit, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrb_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrb_$descriptor() {
        return dlarrb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrb_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrb_$handle() {
        return dlarrb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrb_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrb_$address() {
        return dlarrb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrb_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static int dlarrb_(MemorySegment __n, MemorySegment __d__, MemorySegment __lld, MemorySegment __ifirst, MemorySegment __ilast, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __offset, MemorySegment __w, MemorySegment __wgap, MemorySegment __werr, MemorySegment __work, MemorySegment __iwork, MemorySegment __pivmin, MemorySegment __spdiam, MemorySegment __twist, MemorySegment __info) {
        var mh$ = dlarrb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrb_", __n, __d__, __lld, __ifirst, __ilast, __rtol1, __rtol2, __offset, __w, __wgap, __werr, __work, __iwork, __pivmin, __spdiam, __twist, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __lld, __ifirst, __ilast, __rtol1, __rtol2, __offset, __w, __wgap, __werr, __work, __iwork, __pivmin, __spdiam, __twist, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrc_$descriptor() {
        return dlarrc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrc_$handle() {
        return dlarrc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrc_$address() {
        return dlarrc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static int dlarrc_(MemorySegment __jobt, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __d__, MemorySegment __e, MemorySegment __pivmin, MemorySegment __eigcnt, MemorySegment __lcnt, MemorySegment __rcnt, MemorySegment __info) {
        var mh$ = dlarrc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrc_", __jobt, __n, __vl, __vu, __d__, __e, __pivmin, __eigcnt, __lcnt, __rcnt, __info);
            }
            return (int)mh$.invokeExact(__jobt, __n, __vl, __vu, __d__, __e, __pivmin, __eigcnt, __lcnt, __rcnt, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__gers, __CLPK_doublereal *__reltol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wl, __CLPK_doublereal *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrd_$descriptor() {
        return dlarrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__gers, __CLPK_doublereal *__reltol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wl, __CLPK_doublereal *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrd_$handle() {
        return dlarrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__gers, __CLPK_doublereal *__reltol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wl, __CLPK_doublereal *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrd_$address() {
        return dlarrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__gers, __CLPK_doublereal *__reltol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wl, __CLPK_doublereal *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlarrd_(MemorySegment __range, MemorySegment __order, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __gers, MemorySegment __reltol, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __pivmin, MemorySegment __nsplit, MemorySegment __isplit, MemorySegment __m, MemorySegment __w, MemorySegment __werr, MemorySegment __wl, MemorySegment __wu, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlarrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrd_", __range, __order, __n, __vl, __vu, __il, __iu, __gers, __reltol, __d__, __e, __e2, __pivmin, __nsplit, __isplit, __m, __w, __werr, __wl, __wu, __iblock, __indexw, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__range, __order, __n, __vl, __vu, __il, __iu, __gers, __reltol, __d__, __e, __e2, __pivmin, __nsplit, __isplit, __m, __w, __werr, __wl, __wu, __iblock, __indexw, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarre_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarre_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarre_(char *__range, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarre_$descriptor() {
        return dlarre_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarre_(char *__range, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarre_$handle() {
        return dlarre_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarre_(char *__range, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarre_$address() {
        return dlarre_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarre_(char *__range, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__e2, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlarre_(MemorySegment __range, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __spltol, MemorySegment __nsplit, MemorySegment __isplit, MemorySegment __m, MemorySegment __w, MemorySegment __werr, MemorySegment __wgap, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __gers, MemorySegment __pivmin, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlarre_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarre_", __range, __n, __vl, __vu, __il, __iu, __d__, __e, __e2, __rtol1, __rtol2, __spltol, __nsplit, __isplit, __m, __w, __werr, __wgap, __iblock, __indexw, __gers, __pivmin, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__range, __n, __vl, __vu, __il, __iu, __d__, __e, __e2, __rtol1, __rtol2, __spltol, __nsplit, __isplit, __m, __w, __werr, __wgap, __iblock, __indexw, __gers, __pivmin, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__spdiam, __CLPK_doublereal *__clgapl, __CLPK_doublereal *__clgapr, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__sigma, __CLPK_doublereal *__dplus, __CLPK_doublereal *__lplus, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrf_$descriptor() {
        return dlarrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__spdiam, __CLPK_doublereal *__clgapl, __CLPK_doublereal *__clgapr, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__sigma, __CLPK_doublereal *__dplus, __CLPK_doublereal *__lplus, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrf_$handle() {
        return dlarrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__spdiam, __CLPK_doublereal *__clgapl, __CLPK_doublereal *__clgapr, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__sigma, __CLPK_doublereal *__dplus, __CLPK_doublereal *__lplus, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrf_$address() {
        return dlarrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_doublereal *__w, __CLPK_doublereal *__wgap, __CLPK_doublereal *__werr, __CLPK_doublereal *__spdiam, __CLPK_doublereal *__clgapl, __CLPK_doublereal *__clgapr, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__sigma, __CLPK_doublereal *__dplus, __CLPK_doublereal *__lplus, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlarrf_(MemorySegment __n, MemorySegment __d__, MemorySegment __l, MemorySegment __ld, MemorySegment __clstrt, MemorySegment __clend, MemorySegment __w, MemorySegment __wgap, MemorySegment __werr, MemorySegment __spdiam, MemorySegment __clgapl, MemorySegment __clgapr, MemorySegment __pivmin, MemorySegment __sigma, MemorySegment __dplus, MemorySegment __lplus, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlarrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrf_", __n, __d__, __l, __ld, __clstrt, __clend, __w, __wgap, __werr, __spdiam, __clgapl, __clgapr, __pivmin, __sigma, __dplus, __lplus, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __l, __ld, __clstrt, __clend, __w, __wgap, __werr, __spdiam, __clgapl, __clgapr, __pivmin, __sigma, __dplus, __lplus, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrj_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrj_$descriptor() {
        return dlarrj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrj_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrj_$handle() {
        return dlarrj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrj_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrj_$address() {
        return dlarrj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrj_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_doublereal *__rtol, __CLPK_integer *__offset, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static int dlarrj_(MemorySegment __n, MemorySegment __d__, MemorySegment __e2, MemorySegment __ifirst, MemorySegment __ilast, MemorySegment __rtol, MemorySegment __offset, MemorySegment __w, MemorySegment __werr, MemorySegment __work, MemorySegment __iwork, MemorySegment __pivmin, MemorySegment __spdiam, MemorySegment __info) {
        var mh$ = dlarrj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrj_", __n, __d__, __e2, __ifirst, __ilast, __rtol, __offset, __w, __werr, __work, __iwork, __pivmin, __spdiam, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e2, __ifirst, __ilast, __rtol, __offset, __w, __werr, __work, __iwork, __pivmin, __spdiam, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_doublereal *__gl, __CLPK_doublereal *__gu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__reltol, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrk_$descriptor() {
        return dlarrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_doublereal *__gl, __CLPK_doublereal *__gu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__reltol, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrk_$handle() {
        return dlarrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_doublereal *__gl, __CLPK_doublereal *__gu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__reltol, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrk_$address() {
        return dlarrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_doublereal *__gl, __CLPK_doublereal *__gu, __CLPK_doublereal *__d__, __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin, __CLPK_doublereal *__reltol, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_integer *__info)
     * }
     */
    public static int dlarrk_(MemorySegment __n, MemorySegment __iw, MemorySegment __gl, MemorySegment __gu, MemorySegment __d__, MemorySegment __e2, MemorySegment __pivmin, MemorySegment __reltol, MemorySegment __w, MemorySegment __werr, MemorySegment __info) {
        var mh$ = dlarrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrk_", __n, __iw, __gl, __gu, __d__, __e2, __pivmin, __reltol, __w, __werr, __info);
            }
            return (int)mh$.invokeExact(__n, __iw, __gl, __gu, __d__, __e2, __pivmin, __reltol, __w, __werr, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrr_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrr_$descriptor() {
        return dlarrr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrr_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrr_$handle() {
        return dlarrr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrr_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrr_$address() {
        return dlarrr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrr_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static int dlarrr_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = dlarrr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrr_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarrv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarrv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlarrv_$descriptor() {
        return dlarrv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlarrv_$handle() {
        return dlarrv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlarrv_$address() {
        return dlarrv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_doublereal *__d__, __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_doublereal *__minrgp, __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2, __CLPK_doublereal *__w, __CLPK_doublereal *__werr, __CLPK_doublereal *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_doublereal *__gers, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlarrv_(MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __d__, MemorySegment __l, MemorySegment __pivmin, MemorySegment __isplit, MemorySegment __m, MemorySegment __dol, MemorySegment __dou, MemorySegment __minrgp, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __w, MemorySegment __werr, MemorySegment __wgap, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __gers, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlarrv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarrv_", __n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarscl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarscl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor dlarscl2_$descriptor() {
        return dlarscl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle dlarscl2_$handle() {
        return dlarscl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment dlarscl2_$address() {
        return dlarscl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int dlarscl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = dlarscl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarscl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlartg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlartg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlartg_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn, __CLPK_doublereal *__r__)
     * }
     */
    public static FunctionDescriptor dlartg_$descriptor() {
        return dlartg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlartg_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn, __CLPK_doublereal *__r__)
     * }
     */
    public static MethodHandle dlartg_$handle() {
        return dlartg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlartg_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn, __CLPK_doublereal *__r__)
     * }
     */
    public static MemorySegment dlartg_$address() {
        return dlartg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlartg_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__cs, __CLPK_doublereal *__sn, __CLPK_doublereal *__r__)
     * }
     */
    public static int dlartg_(MemorySegment __f, MemorySegment __g, MemorySegment __cs, MemorySegment __sn, MemorySegment __r__) {
        var mh$ = dlartg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlartg_", __f, __g, __cs, __sn, __r__);
            }
            return (int)mh$.invokeExact(__f, __g, __cs, __sn, __r__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlartv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlartv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlartv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor dlartv_$descriptor() {
        return dlartv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlartv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle dlartv_$handle() {
        return dlartv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlartv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment dlartv_$address() {
        return dlartv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlartv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__y, __CLPK_integer *__incy, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__incc)
     * }
     */
    public static int dlartv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = dlartv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlartv_", __n, __x, __incx, __y, __incy, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaruv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaruv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static FunctionDescriptor dlaruv_$descriptor() {
        return dlaruv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static MethodHandle dlaruv_$handle() {
        return dlaruv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static MemorySegment dlaruv_$address() {
        return dlaruv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_doublereal *__x)
     * }
     */
    public static int dlaruv_(MemorySegment __iseed, MemorySegment __n, MemorySegment __x) {
        var mh$ = dlaruv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaruv_", __iseed, __n, __x);
            }
            return (int)mh$.invokeExact(__iseed, __n, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlarz_$descriptor() {
        return dlarz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlarz_$handle() {
        return dlarz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlarz_$address() {
        return dlarz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static int dlarz_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = dlarz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarz_", __side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarzb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarzb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor dlarzb_$descriptor() {
        return dlarzb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle dlarzb_$handle() {
        return dlarzb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment dlarzb_$address() {
        return dlarzb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int dlarzb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = dlarzb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarzb_", __side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarzt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlarzt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor dlarzt_$descriptor() {
        return dlarzt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle dlarzt_$handle() {
        return dlarzt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment dlarzt_$address() {
        return dlarzt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__tau, __CLPK_doublereal *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int dlarzt_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = dlarzt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarzt_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlas2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlas2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlas2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax)
     * }
     */
    public static FunctionDescriptor dlas2_$descriptor() {
        return dlas2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlas2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax)
     * }
     */
    public static MethodHandle dlas2_$handle() {
        return dlas2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlas2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax)
     * }
     */
    public static MemorySegment dlas2_$address() {
        return dlas2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlas2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax)
     * }
     */
    public static int dlas2_(MemorySegment __f, MemorySegment __g, MemorySegment __h__, MemorySegment __ssmin, MemorySegment __ssmax) {
        var mh$ = dlas2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlas2_", __f, __g, __h__, __ssmin, __ssmax);
            }
            return (int)mh$.invokeExact(__f, __g, __h__, __ssmin, __ssmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlascl_$descriptor() {
        return dlascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlascl_$handle() {
        return dlascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlascl_$address() {
        return dlascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dlascl_(MemorySegment __type__, MemorySegment __kl, MemorySegment __ku, MemorySegment __cfrom, MemorySegment __cto, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dlascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlascl_", __type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlascl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlascl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor dlascl2_$descriptor() {
        return dlascl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle dlascl2_$handle() {
        return dlascl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment dlascl2_$address() {
        return dlascl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int dlascl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = dlascl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlascl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd0_$descriptor() {
        return dlasd0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd0_$handle() {
        return dlasd0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd0_$address() {
        return dlasd0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlasd0_(MemorySegment __n, MemorySegment __sqre, MemorySegment __d__, MemorySegment __e, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __smlsiz, MemorySegment __iwork, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlasd0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd0_", __n, __sqre, __d__, __e, __u, __ldu, __vt, __ldvt, __smlsiz, __iwork, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __sqre, __d__, __e, __u, __ldu, __vt, __ldvt, __smlsiz, __iwork, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd1_$descriptor() {
        return dlasd1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd1_$handle() {
        return dlasd1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd1_$address() {
        return dlasd1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlasd1_(MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __d__, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __idxq, MemorySegment __iwork, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlasd1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd1_", __nl, __nr, __sqre, __d__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __idxq, __iwork, __work, __info);
            }
            return (int)mh$.invokeExact(__nl, __nr, __sqre, __d__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __idxq, __iwork, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd2_$descriptor() {
        return dlasd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd2_$handle() {
        return dlasd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd2_$address() {
        return dlasd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static int dlasd2_(MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __k, MemorySegment __d__, MemorySegment __z__, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __dsigma, MemorySegment __u2, MemorySegment __ldu2, MemorySegment __vt2, MemorySegment __ldvt2, MemorySegment __idxp, MemorySegment __idx, MemorySegment __idxc, MemorySegment __idxq, MemorySegment __coltyp, MemorySegment __info) {
        var mh$ = dlasd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd2_", __nl, __nr, __sqre, __k, __d__, __z__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __dsigma, __u2, __ldu2, __vt2, __ldvt2, __idxp, __idx, __idxc, __idxq, __coltyp, __info);
            }
            return (int)mh$.invokeExact(__nl, __nr, __sqre, __k, __d__, __z__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __dsigma, __u2, __ldu2, __vt2, __ldvt2, __idxp, __idx, __idxc, __idxq, __coltyp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd3_$descriptor() {
        return dlasd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd3_$handle() {
        return dlasd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd3_$address() {
        return dlasd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__u2, __CLPK_integer *__ldu2, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static int dlasd3_(MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __k, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __dsigma, MemorySegment __u, MemorySegment __ldu, MemorySegment __u2, MemorySegment __ldu2, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __vt2, MemorySegment __ldvt2, MemorySegment __idxc, MemorySegment __ctot, MemorySegment __z__, MemorySegment __info) {
        var mh$ = dlasd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd3_", __nl, __nr, __sqre, __k, __d__, __q, __ldq, __dsigma, __u, __ldu, __u2, __ldu2, __vt, __ldvt, __vt2, __ldvt2, __idxc, __ctot, __z__, __info);
            }
            return (int)mh$.invokeExact(__nl, __nr, __sqre, __k, __d__, __q, __ldq, __dsigma, __u, __ldu, __u2, __ldu2, __vt, __ldvt, __vt2, __ldvt2, __idxc, __ctot, __z__, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__sigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd4_$descriptor() {
        return dlasd4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__sigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd4_$handle() {
        return dlasd4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__sigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd4_$address() {
        return dlasd4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__sigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlasd4_(MemorySegment __n, MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __sigma, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlasd4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd4_", __n, __i__, __d__, __z__, __delta, __rho, __sigma, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __i__, __d__, __z__, __delta, __rho, __sigma, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlasd5_$descriptor() {
        return dlasd5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlasd5_$handle() {
        return dlasd5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlasd5_$address() {
        return dlasd5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__delta, __CLPK_doublereal *__rho, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work)
     * }
     */
    public static int dlasd5_(MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __dsigma, MemorySegment __work) {
        var mh$ = dlasd5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd5_", __i__, __d__, __z__, __delta, __rho, __dsigma, __work);
            }
            return (int)mh$.invokeExact(__i__, __d__, __z__, __delta, __rho, __dsigma, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd6_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd6_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd6_$descriptor() {
        return dlasd6_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd6_$handle() {
        return dlasd6_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd6_$address() {
        return dlasd6_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlasd6_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __d__, MemorySegment __vf, MemorySegment __vl, MemorySegment __alpha, MemorySegment __beta, MemorySegment __idxq, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __poles, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __k, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlasd6_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd6_", __icompq, __nl, __nr, __sqre, __d__, __vf, __vl, __alpha, __beta, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __d__, __vf, __vl, __alpha, __beta, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd7_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd7_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__zw, __CLPK_doublereal *__vf, __CLPK_doublereal *__vfw, __CLPK_doublereal *__vl, __CLPK_doublereal *__vlw, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd7_$descriptor() {
        return dlasd7_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__zw, __CLPK_doublereal *__vf, __CLPK_doublereal *__vfw, __CLPK_doublereal *__vl, __CLPK_doublereal *__vlw, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd7_$handle() {
        return dlasd7_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__zw, __CLPK_doublereal *__vf, __CLPK_doublereal *__vfw, __CLPK_doublereal *__vl, __CLPK_doublereal *__vlw, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd7_$address() {
        return dlasd7_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__zw, __CLPK_doublereal *__vf, __CLPK_doublereal *__vfw, __CLPK_doublereal *__vl, __CLPK_doublereal *__vlw, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_integer *__info)
     * }
     */
    public static int dlasd7_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __k, MemorySegment __d__, MemorySegment __z__, MemorySegment __zw, MemorySegment __vf, MemorySegment __vfw, MemorySegment __vl, MemorySegment __vlw, MemorySegment __alpha, MemorySegment __beta, MemorySegment __dsigma, MemorySegment __idx, MemorySegment __idxp, MemorySegment __idxq, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __c__, MemorySegment __s, MemorySegment __info) {
        var mh$ = dlasd7_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd7_", __icompq, __nl, __nr, __sqre, __k, __d__, __z__, __zw, __vf, __vfw, __vl, __vlw, __alpha, __beta, __dsigma, __idx, __idxp, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __c__, __s, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __k, __d__, __z__, __zw, __vf, __vfw, __vl, __vlw, __alpha, __beta, __dsigma, __idx, __idxp, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __c__, __s, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasd8_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasd8_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_integer *__lddifr, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasd8_$descriptor() {
        return dlasd8_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_integer *__lddifr, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasd8_$handle() {
        return dlasd8_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_integer *__lddifr, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasd8_$address() {
        return dlasd8_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__, __CLPK_doublereal *__vf, __CLPK_doublereal *__vl, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_integer *__lddifr, __CLPK_doublereal *__dsigma, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlasd8_(MemorySegment __icompq, MemorySegment __k, MemorySegment __d__, MemorySegment __z__, MemorySegment __vf, MemorySegment __vl, MemorySegment __difl, MemorySegment __difr, MemorySegment __lddifr, MemorySegment __dsigma, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlasd8_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasd8_", __icompq, __k, __d__, __z__, __vf, __vl, __difl, __difr, __lddifr, __dsigma, __work, __info);
            }
            return (int)mh$.invokeExact(__icompq, __k, __d__, __z__, __vf, __vl, __difl, __difr, __lddifr, __dsigma, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasda_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasda_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasda_$descriptor() {
        return dlasda_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasda_$handle() {
        return dlasda_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasda_$address() {
        return dlasda_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl, __CLPK_doublereal *__difr, __CLPK_doublereal *__z__, __CLPK_doublereal *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_doublereal *__givnum, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dlasda_(MemorySegment __icompq, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __sqre, MemorySegment __d__, MemorySegment __e, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __k, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __poles, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __perm, MemorySegment __givnum, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dlasda_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasda_", __icompq, __smlsiz, __n, __sqre, __d__, __e, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __smlsiz, __n, __sqre, __d__, __e, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasdq_$descriptor() {
        return dlasdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasdq_$handle() {
        return dlasdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasdq_$address() {
        return dlasdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlasdq_(MemorySegment __uplo, MemorySegment __sqre, MemorySegment __n, MemorySegment __ncvt, MemorySegment __nru, MemorySegment __ncc, MemorySegment __d__, MemorySegment __e, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __u, MemorySegment __ldu, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlasdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasdq_", __uplo, __sqre, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __sqre, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasdt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasdt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static FunctionDescriptor dlasdt_$descriptor() {
        return dlasdt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static MethodHandle dlasdt_$handle() {
        return dlasdt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static MemorySegment dlasdt_$address() {
        return dlasdt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static int dlasdt_(MemorySegment __n, MemorySegment __lvl, MemorySegment __nd, MemorySegment __inode, MemorySegment __ndiml, MemorySegment __ndimr, MemorySegment __msub) {
        var mh$ = dlasdt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasdt_", __n, __lvl, __nd, __inode, __ndiml, __ndimr, __msub);
            }
            return (int)mh$.invokeExact(__n, __lvl, __nd, __inode, __ndiml, __ndimr, __msub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor dlaset_$descriptor() {
        return dlaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle dlaset_$handle() {
        return dlaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment dlaset_$address() {
        return dlaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static int dlaset_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __beta, MemorySegment __a, MemorySegment __lda) {
        var mh$ = dlaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaset_", __uplo, __m, __n, __alpha, __beta, __a, __lda);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __alpha, __beta, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasq1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasq1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasq1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasq1_$descriptor() {
        return dlasq1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasq1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasq1_$handle() {
        return dlasq1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasq1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasq1_$address() {
        return dlasq1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasq1_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dlasq1_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __work, MemorySegment __info) {
        var mh$ = dlasq1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasq1_", __n, __d__, __e, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasq2_(__CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasq2_$descriptor() {
        return dlasq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasq2_(__CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasq2_$handle() {
        return dlasq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasq2_(__CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasq2_$address() {
        return dlasq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasq2_(__CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__info)
     * }
     */
    public static int dlasq2_(MemorySegment __n, MemorySegment __z__, MemorySegment __info) {
        var mh$ = dlasq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasq2_", __n, __z__, __info);
            }
            return (int)mh$.invokeExact(__n, __z__, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasq3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasq3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__sigma, __CLPK_doublereal *__desig, __CLPK_doublereal *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__g, __CLPK_doublereal *__tau)
     * }
     */
    public static FunctionDescriptor dlasq3_$descriptor() {
        return dlasq3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__sigma, __CLPK_doublereal *__desig, __CLPK_doublereal *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__g, __CLPK_doublereal *__tau)
     * }
     */
    public static MethodHandle dlasq3_$handle() {
        return dlasq3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__sigma, __CLPK_doublereal *__desig, __CLPK_doublereal *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__g, __CLPK_doublereal *__tau)
     * }
     */
    public static MemorySegment dlasq3_$address() {
        return dlasq3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__sigma, __CLPK_doublereal *__desig, __CLPK_doublereal *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__g, __CLPK_doublereal *__tau)
     * }
     */
    public static int dlasq3_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __dmin__, MemorySegment __sigma, MemorySegment __desig, MemorySegment __qmax, MemorySegment __nfail, MemorySegment __iter, MemorySegment __ndiv, MemorySegment __ieee, MemorySegment __ttype, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dn1, MemorySegment __dn2, MemorySegment __g, MemorySegment __tau) {
        var mh$ = dlasq3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasq3_", __i0, __n0, __z__, __pp, __dmin__, __sigma, __desig, __qmax, __nfail, __iter, __ndiv, __ieee, __ttype, __dmin1, __dmin2, __dn, __dn1, __dn2, __g, __tau);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __dmin__, __sigma, __desig, __qmax, __nfail, __iter, __ndiv, __ieee, __ttype, __dmin1, __dmin2, __dn, __dn1, __dn2, __g, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasq4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasq4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__tau, __CLPK_integer *__ttype, __CLPK_doublereal *__g)
     * }
     */
    public static FunctionDescriptor dlasq4_$descriptor() {
        return dlasq4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__tau, __CLPK_integer *__ttype, __CLPK_doublereal *__g)
     * }
     */
    public static MethodHandle dlasq4_$handle() {
        return dlasq4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__tau, __CLPK_integer *__ttype, __CLPK_doublereal *__g)
     * }
     */
    public static MemorySegment dlasq4_$address() {
        return dlasq4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2, __CLPK_doublereal *__tau, __CLPK_integer *__ttype, __CLPK_doublereal *__g)
     * }
     */
    public static int dlasq4_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __n0in, MemorySegment __dmin__, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dn1, MemorySegment __dn2, MemorySegment __tau, MemorySegment __ttype, MemorySegment __g) {
        var mh$ = dlasq4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasq4_", __i0, __n0, __z__, __pp, __n0in, __dmin__, __dmin1, __dmin2, __dn, __dn1, __dn2, __tau, __ttype, __g);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __n0in, __dmin__, __dmin1, __dmin2, __dn, __dn1, __dn2, __tau, __ttype, __g);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasq5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasq5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__tau, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static FunctionDescriptor dlasq5_$descriptor() {
        return dlasq5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__tau, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static MethodHandle dlasq5_$handle() {
        return dlasq5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__tau, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static MemorySegment dlasq5_$address() {
        return dlasq5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__tau, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static int dlasq5_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __tau, MemorySegment __dmin__, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dnm1, MemorySegment __dnm2, MemorySegment __ieee) {
        var mh$ = dlasq5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasq5_", __i0, __n0, __z__, __pp, __tau, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2, __ieee);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __tau, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2, __ieee);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasq6_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasq6_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2)
     * }
     */
    public static FunctionDescriptor dlasq6_$descriptor() {
        return dlasq6_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2)
     * }
     */
    public static MethodHandle dlasq6_$handle() {
        return dlasq6_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2)
     * }
     */
    public static MemorySegment dlasq6_$address() {
        return dlasq6_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1, __CLPK_doublereal *__dnm2)
     * }
     */
    public static int dlasq6_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __dmin__, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dnm1, MemorySegment __dnm2) {
        var mh$ = dlasq6_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasq6_", __i0, __n0, __z__, __pp, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor dlasr_$descriptor() {
        return dlasr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle dlasr_$handle() {
        return dlasr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment dlasr_$address() {
        return dlasr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static int dlasr_(MemorySegment __side, MemorySegment __pivot, MemorySegment __direct, MemorySegment __m, MemorySegment __n, MemorySegment __c__, MemorySegment __s, MemorySegment __a, MemorySegment __lda) {
        var mh$ = dlasr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasr_", __side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
            }
            return (int)mh$.invokeExact(__side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasrt_(char *__id, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasrt_$descriptor() {
        return dlasrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasrt_(char *__id, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasrt_$handle() {
        return dlasrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasrt_(char *__id, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasrt_$address() {
        return dlasrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasrt_(char *__id, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_integer *__info)
     * }
     */
    public static int dlasrt_(MemorySegment __id, MemorySegment __n, MemorySegment __d__, MemorySegment __info) {
        var mh$ = dlasrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasrt_", __id, __n, __d__, __info);
            }
            return (int)mh$.invokeExact(__id, __n, __d__, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlassq_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static FunctionDescriptor dlassq_$descriptor() {
        return dlassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlassq_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static MethodHandle dlassq_$handle() {
        return dlassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlassq_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static MemorySegment dlassq_$address() {
        return dlassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlassq_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx, __CLPK_doublereal *__scale, __CLPK_doublereal *__sumsq)
     * }
     */
    public static int dlassq_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __scale, MemorySegment __sumsq) {
        var mh$ = dlassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlassq_", __n, __x, __incx, __scale, __sumsq);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __scale, __sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasv2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasv2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasv2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax, __CLPK_doublereal *__snr, __CLPK_doublereal *__csr, __CLPK_doublereal *__snl, __CLPK_doublereal *__csl)
     * }
     */
    public static FunctionDescriptor dlasv2_$descriptor() {
        return dlasv2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasv2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax, __CLPK_doublereal *__snr, __CLPK_doublereal *__csr, __CLPK_doublereal *__snl, __CLPK_doublereal *__csl)
     * }
     */
    public static MethodHandle dlasv2_$handle() {
        return dlasv2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasv2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax, __CLPK_doublereal *__snr, __CLPK_doublereal *__csr, __CLPK_doublereal *__snl, __CLPK_doublereal *__csl)
     * }
     */
    public static MemorySegment dlasv2_$address() {
        return dlasv2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasv2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g, __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin, __CLPK_doublereal *__ssmax, __CLPK_doublereal *__snr, __CLPK_doublereal *__csr, __CLPK_doublereal *__snl, __CLPK_doublereal *__csl)
     * }
     */
    public static int dlasv2_(MemorySegment __f, MemorySegment __g, MemorySegment __h__, MemorySegment __ssmin, MemorySegment __ssmax, MemorySegment __snr, MemorySegment __csr, MemorySegment __snl, MemorySegment __csl) {
        var mh$ = dlasv2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasv2_", __f, __g, __h__, __ssmin, __ssmax, __snr, __csr, __snl, __csl);
            }
            return (int)mh$.invokeExact(__f, __g, __h__, __ssmin, __ssmax, __snr, __csr, __snl, __csl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlaswp_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor dlaswp_$descriptor() {
        return dlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlaswp_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle dlaswp_$handle() {
        return dlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlaswp_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment dlaswp_$address() {
        return dlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlaswp_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static int dlaswp_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __k1, MemorySegment __k2, MemorySegment __ipiv, MemorySegment __incx) {
        var mh$ = dlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaswp_", __n, __a, __lda, __k1, __k2, __ipiv, __incx);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __k1, __k2, __ipiv, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__tl, __CLPK_integer *__ldtl, __CLPK_doublereal *__tr, __CLPK_integer *__ldtr, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasy2_$descriptor() {
        return dlasy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__tl, __CLPK_integer *__ldtl, __CLPK_doublereal *__tr, __CLPK_integer *__ldtr, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasy2_$handle() {
        return dlasy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__tl, __CLPK_integer *__ldtl, __CLPK_doublereal *__tr, __CLPK_integer *__ldtr, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasy2_$address() {
        return dlasy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__tl, __CLPK_integer *__ldtl, __CLPK_doublereal *__tr, __CLPK_integer *__ldtr, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__scale, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static int dlasy2_(MemorySegment __ltranl, MemorySegment __ltranr, MemorySegment __isgn, MemorySegment __n1, MemorySegment __n2, MemorySegment __tl, MemorySegment __ldtl, MemorySegment __tr, MemorySegment __ldtr, MemorySegment __b, MemorySegment __ldb, MemorySegment __scale, MemorySegment __x, MemorySegment __ldx, MemorySegment __xnorm, MemorySegment __info) {
        var mh$ = dlasy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasy2_", __ltranl, __ltranr, __isgn, __n1, __n2, __tl, __ldtl, __tr, __ldtr, __b, __ldb, __scale, __x, __ldx, __xnorm, __info);
            }
            return (int)mh$.invokeExact(__ltranl, __ltranr, __isgn, __n1, __n2, __tl, __ldtl, __tr, __ldtr, __b, __ldb, __scale, __x, __ldx, __xnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasyf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlasyf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlasyf_$descriptor() {
        return dlasyf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlasyf_$handle() {
        return dlasyf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlasyf_$address() {
        return dlasyf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static int dlasyf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __w, MemorySegment __ldw, MemorySegment __info) {
        var mh$ = dlasyf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasyf_", __uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlat2s_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlat2s_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlat2s_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlat2s_$descriptor() {
        return dlat2s_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlat2s_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlat2s_$handle() {
        return dlat2s_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlat2s_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlat2s_$address() {
        return dlat2s_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlat2s_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_integer *__info)
     * }
     */
    public static int dlat2s_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sa, MemorySegment __ldsa, MemorySegment __info) {
        var mh$ = dlat2s_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlat2s_", __uplo, __n, __a, __lda, __sa, __ldsa, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __sa, __ldsa, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatbs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatbs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlatbs_$descriptor() {
        return dlatbs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlatbs_$handle() {
        return dlatbs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlatbs_$address() {
        return dlatbs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int dlatbs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = dlatbs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatbs_", __uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatdf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatdf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static FunctionDescriptor dlatdf_$descriptor() {
        return dlatdf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MethodHandle dlatdf_$handle() {
        return dlatdf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MemorySegment dlatdf_$address() {
        return dlatdf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__rhs, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static int dlatdf_(MemorySegment __ijob, MemorySegment __n, MemorySegment __z__, MemorySegment __ldz, MemorySegment __rhs, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __ipiv, MemorySegment __jpiv) {
        var mh$ = dlatdf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatdf_", __ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
            }
            return (int)mh$.invokeExact(__ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlatps_$descriptor() {
        return dlatps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlatps_$handle() {
        return dlatps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlatps_$address() {
        return dlatps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int dlatps_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __ap, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = dlatps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatps_", __uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__w, __CLPK_integer *__ldw)
     * }
     */
    public static FunctionDescriptor dlatrd_$descriptor() {
        return dlatrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MethodHandle dlatrd_$handle() {
        return dlatrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MemorySegment dlatrd_$address() {
        return dlatrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__w, __CLPK_integer *__ldw)
     * }
     */
    public static int dlatrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __e, MemorySegment __tau, MemorySegment __w, MemorySegment __ldw) {
        var mh$ = dlatrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatrd_", __uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlatrs_$descriptor() {
        return dlatrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlatrs_$handle() {
        return dlatrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlatrs_$address() {
        return dlatrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__x, __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int dlatrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = dlatrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatrs_", __uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlatrz_$descriptor() {
        return dlatrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlatrz_$handle() {
        return dlatrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlatrz_$address() {
        return dlatrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work)
     * }
     */
    public static int dlatrz_(MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work) {
        var mh$ = dlatrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatrz_", __m, __n, __l, __a, __lda, __tau, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __l, __a, __lda, __tau, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatzm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlatzm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c1, __CLPK_doublereal *__c2, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static FunctionDescriptor dlatzm_$descriptor() {
        return dlatzm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c1, __CLPK_doublereal *__c2, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MethodHandle dlatzm_$handle() {
        return dlatzm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c1, __CLPK_doublereal *__c2, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static MemorySegment dlatzm_$address() {
        return dlatzm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_integer *__incv, __CLPK_doublereal *__tau, __CLPK_doublereal *__c1, __CLPK_doublereal *__c2, __CLPK_integer *__ldc, __CLPK_doublereal *__work)
     * }
     */
    public static int dlatzm_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c1, MemorySegment __c2, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = dlatzm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatzm_", __side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlauu2_$descriptor() {
        return dlauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlauu2_$handle() {
        return dlauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlauu2_$address() {
        return dlauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dlauu2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dlauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlauu2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dlauum_$descriptor() {
        return dlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dlauum_$handle() {
        return dlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dlauum_$address() {
        return dlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dlauum_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlauum_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dopgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dopgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dopgtr_$descriptor() {
        return dopgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dopgtr_$handle() {
        return dopgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dopgtr_$address() {
        return dopgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dopgtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = dopgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dopgtr_", __uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dopmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dopmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dopmtr_$descriptor() {
        return dopmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dopmtr_$handle() {
        return dopmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dopmtr_$address() {
        return dopmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dopmtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dopmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dopmtr_", __side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorg2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorg2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorg2l_$descriptor() {
        return dorg2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorg2l_$handle() {
        return dorg2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorg2l_$address() {
        return dorg2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorg2l_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorg2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorg2l_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorg2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorg2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorg2r_$descriptor() {
        return dorg2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorg2r_$handle() {
        return dorg2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorg2r_$address() {
        return dorg2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorg2r_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorg2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorg2r_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgbr_$descriptor() {
        return dorgbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgbr_$handle() {
        return dorgbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgbr_$address() {
        return dorgbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorgbr_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorgbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgbr_", __vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorghr_$descriptor() {
        return dorghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorghr_$handle() {
        return dorghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorghr_$address() {
        return dorghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorghr_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorghr_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgl2_$descriptor() {
        return dorgl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgl2_$handle() {
        return dorgl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgl2_$address() {
        return dorgl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorgl2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorgl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgl2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorglq_$descriptor() {
        return dorglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorglq_$handle() {
        return dorglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorglq_$address() {
        return dorglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorglq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorglq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgql_$descriptor() {
        return dorgql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgql_$handle() {
        return dorgql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgql_$address() {
        return dorgql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorgql_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorgql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgql_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgqr_$descriptor() {
        return dorgqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgqr_$handle() {
        return dorgqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgqr_$address() {
        return dorgqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorgqr_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorgqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgqr_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgr2_$descriptor() {
        return dorgr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgr2_$handle() {
        return dorgr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgr2_$address() {
        return dorgr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorgr2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorgr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgr2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgrq_$descriptor() {
        return dorgrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgrq_$handle() {
        return dorgrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgrq_$address() {
        return dorgrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorgrq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorgrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgrq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorgtr_$descriptor() {
        return dorgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorgtr_$handle() {
        return dorgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorgtr_$address() {
        return dorgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dorgtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dorgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgtr_", __uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorm2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorm2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorm2l_$descriptor() {
        return dorm2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorm2l_$handle() {
        return dorm2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorm2l_$address() {
        return dorm2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorm2l_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorm2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorm2l_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorm2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorm2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorm2r_$descriptor() {
        return dorm2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorm2r_$handle() {
        return dorm2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorm2r_$address() {
        return dorm2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorm2r_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorm2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorm2r_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormbr_$descriptor() {
        return dormbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormbr_$handle() {
        return dormbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormbr_$address() {
        return dormbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormbr_(MemorySegment __vect, MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormbr_", __vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormhr_$descriptor() {
        return dormhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormhr_$handle() {
        return dormhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormhr_$address() {
        return dormhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormhr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormhr_", __side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorml2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dorml2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dorml2_$descriptor() {
        return dorml2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dorml2_$handle() {
        return dorml2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dorml2_$address() {
        return dorml2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dorml2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dorml2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorml2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormlq_$descriptor() {
        return dormlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormlq_$handle() {
        return dormlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormlq_$address() {
        return dormlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormlq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormlq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormql_$descriptor() {
        return dormql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormql_$handle() {
        return dormql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormql_$address() {
        return dormql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormql_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormql_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormqr_$descriptor() {
        return dormqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormqr_$handle() {
        return dormqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormqr_$address() {
        return dormqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormqr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormqr_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormr2_$descriptor() {
        return dormr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormr2_$handle() {
        return dormr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormr2_$address() {
        return dormr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dormr2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dormr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormr2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormr3_$descriptor() {
        return dormr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormr3_$handle() {
        return dormr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormr3_$address() {
        return dormr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dormr3_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = dormr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormr3_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormrq_$descriptor() {
        return dormrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormrq_$handle() {
        return dormrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormrq_$address() {
        return dormrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormrq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormrq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormrz_$descriptor() {
        return dormrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormrz_$handle() {
        return dormrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormrz_$address() {
        return dormrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormrz_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormrz_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dormtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dormtr_$descriptor() {
        return dormtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dormtr_$handle() {
        return dormtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dormtr_$address() {
        return dormtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dormtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dormtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormtr_", __side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbcon_$descriptor() {
        return dpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbcon_$handle() {
        return dpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbcon_$address() {
        return dpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dpbcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbcon_", __uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbequ_$descriptor() {
        return dpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbequ_$handle() {
        return dpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbequ_$address() {
        return dpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dpbequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbequ_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbrfs_$descriptor() {
        return dpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbrfs_$handle() {
        return dpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbrfs_$address() {
        return dpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dpbrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbrfs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbstf_$descriptor() {
        return dpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbstf_$handle() {
        return dpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbstf_$address() {
        return dpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int dpbstf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = dpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbstf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbsv_$descriptor() {
        return dpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbsv_$handle() {
        return dpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbsv_$address() {
        return dpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dpbsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbsv_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbsvx_$descriptor() {
        return dpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbsvx_$handle() {
        return dpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbsvx_$address() {
        return dpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dpbsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbsvx_", __fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbtf2_$descriptor() {
        return dpbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbtf2_$handle() {
        return dpbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbtf2_$address() {
        return dpbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int dpbtf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = dpbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtf2_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbtrf_$descriptor() {
        return dpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbtrf_$handle() {
        return dpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbtrf_$address() {
        return dpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int dpbtrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = dpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtrf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpbtrs_$descriptor() {
        return dpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpbtrs_$handle() {
        return dpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpbtrs_$address() {
        return dpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dpbtrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtrs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpftrf_$descriptor() {
        return dpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpftrf_$handle() {
        return dpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpftrf_$address() {
        return dpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static int dpftrf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = dpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftrf_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpftri_$descriptor() {
        return dpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpftri_$handle() {
        return dpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpftri_$address() {
        return dpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpftri_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static int dpftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = dpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftri_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpftrs_$descriptor() {
        return dpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpftrs_$handle() {
        return dpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpftrs_$address() {
        return dpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dpftrs_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftrs_", __transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __nrhs, __a, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpocon_$descriptor() {
        return dpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpocon_$handle() {
        return dpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpocon_$address() {
        return dpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dpocon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpocon_", __uplo, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpoequ_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpoequ_$descriptor() {
        return dpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpoequ_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpoequ_$handle() {
        return dpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpoequ_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpoequ_$address() {
        return dpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpoequ_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dpoequ_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpoequ_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpoequb_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpoequb_$descriptor() {
        return dpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpoequb_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpoequb_$handle() {
        return dpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpoequb_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpoequb_$address() {
        return dpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpoequb_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dpoequb_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpoequb_", __n, __a, __lda, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dporfs_$descriptor() {
        return dporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dporfs_$handle() {
        return dporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dporfs_$address() {
        return dporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dporfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dporfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dposv_$descriptor() {
        return dposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dposv_$handle() {
        return dposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dposv_$address() {
        return dposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dposv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposv_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dposvx_$descriptor() {
        return dposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dposvx_$handle() {
        return dposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dposvx_$address() {
        return dposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dposvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dposvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpotf2_$descriptor() {
        return dpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpotf2_$handle() {
        return dpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpotf2_$address() {
        return dpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dpotf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotf2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpotrf_$descriptor() {
        return dpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpotrf_$handle() {
        return dpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpotrf_$address() {
        return dpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dpotrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrf_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpotri_$descriptor() {
        return dpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpotri_$handle() {
        return dpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpotri_$address() {
        return dpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dpotri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotri_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpotrs_$descriptor() {
        return dpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpotrs_$handle() {
        return dpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpotrs_$address() {
        return dpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dpotrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrs_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dppcon_$descriptor() {
        return dppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dppcon_$handle() {
        return dppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dppcon_$address() {
        return dppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dppcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppcon_", __uplo, __n, __ap, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dppequ_$descriptor() {
        return dppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dppequ_$handle() {
        return dppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dppequ_$address() {
        return dppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_integer *__info)
     * }
     */
    public static int dppequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = dppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppequ_", __uplo, __n, __ap, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpprfs_$descriptor() {
        return dpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpprfs_$handle() {
        return dpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpprfs_$address() {
        return dpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dpprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpprfs_", __uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dppsv_$descriptor() {
        return dppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dppsv_$handle() {
        return dppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dppsv_$address() {
        return dppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dppsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppsv_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dppsvx_$descriptor() {
        return dppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dppsvx_$handle() {
        return dppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dppsvx_$address() {
        return dppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, char *__equed, __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dppsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpptrf_$descriptor() {
        return dpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpptrf_$handle() {
        return dpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpptrf_$address() {
        return dpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static int dpptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = dpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptrf_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpptri_$descriptor() {
        return dpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpptri_$handle() {
        return dpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpptri_$address() {
        return dpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static int dpptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = dpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptri_", __uplo, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpptrs_$descriptor() {
        return dpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpptrs_$handle() {
        return dpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpptrs_$address() {
        return dpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dpptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptrs_", __uplo, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpstf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpstf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpstf2_$descriptor() {
        return dpstf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpstf2_$handle() {
        return dpstf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpstf2_$address() {
        return dpstf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dpstf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = dpstf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpstf2_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpstrf_$descriptor() {
        return dpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpstrf_$handle() {
        return dpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpstrf_$address() {
        return dpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank, __CLPK_doublereal *__tol, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dpstrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __piv, MemorySegment __rank, MemorySegment __tol, MemorySegment __work, MemorySegment __info) {
        var mh$ = dpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpstrf_", __uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __piv, __rank, __tol, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dptcon_$descriptor() {
        return dptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dptcon_$handle() {
        return dptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dptcon_$address() {
        return dptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dptcon_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __info) {
        var mh$ = dptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptcon_", __n, __d__, __e, __anorm, __rcond, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __anorm, __rcond, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpteqr_$descriptor() {
        return dpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpteqr_$handle() {
        return dpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpteqr_$address() {
        return dpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dpteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dptrfs_$descriptor() {
        return dptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dptrfs_$handle() {
        return dptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dptrfs_$address() {
        return dptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dptrfs_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __info) {
        var mh$ = dptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptrfs_", __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dptsv_$descriptor() {
        return dptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dptsv_$handle() {
        return dptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dptsv_$address() {
        return dptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dptsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptsv_", __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dptsvx_$descriptor() {
        return dptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dptsvx_$handle() {
        return dptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dptsvx_$address() {
        return dptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__df, __CLPK_doublereal *__ef, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dptsvx_(MemorySegment __fact, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __df, MemorySegment __ef, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __info) {
        var mh$ = dptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptsvx_", __fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __info);
            }
            return (int)mh$.invokeExact(__fact, __n, __nrhs, __d__, __e, __df, __ef, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpttrf_$descriptor() {
        return dpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpttrf_$handle() {
        return dpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpttrf_$address() {
        return dpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static int dpttrf_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = dpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpttrf_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dpttrs_$descriptor() {
        return dpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dpttrs_$handle() {
        return dpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dpttrs_$address() {
        return dpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dpttrs_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpttrs_", __n, __nrhs, __d__, __e, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dptts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor dptts2_$descriptor() {
        return dptts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle dptts2_$handle() {
        return dptts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment dptts2_$address() {
        return dptts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int dptts2_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = dptts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptts2_", __n, __nrhs, __d__, __e, __b, __ldb);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __d__, __e, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drscl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("drscl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int drscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublereal *__sx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor drscl_$descriptor() {
        return drscl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int drscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublereal *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle drscl_$handle() {
        return drscl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int drscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublereal *__sx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment drscl_$address() {
        return drscl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int drscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa, __CLPK_doublereal *__sx, __CLPK_integer *__incx)
     * }
     */
    public static int drscl_(MemorySegment __n, MemorySegment __sa, MemorySegment __sx, MemorySegment __incx) {
        var mh$ = drscl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drscl_", __n, __sa, __sx, __incx);
            }
            return (int)mh$.invokeExact(__n, __sa, __sx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbev_$descriptor() {
        return dsbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbev_$handle() {
        return dsbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbev_$address() {
        return dsbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsbev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbev_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbevd_$descriptor() {
        return dsbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbevd_$handle() {
        return dsbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbevd_$address() {
        return dsbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dsbevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dsbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevd_", __jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __kd, __ab, __ldab, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbevx_$descriptor() {
        return dsbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbevx_$handle() {
        return dsbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbevx_$address() {
        return dsbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dsbevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dsbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevx_", __jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __kd, __ab, __ldab, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbgst_$descriptor() {
        return dsbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbgst_$handle() {
        return dsbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbgst_$address() {
        return dsbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbgst_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsbgst_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgst_", __vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __x, __ldx, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbgv_$descriptor() {
        return dsbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbgv_$handle() {
        return dsbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbgv_$address() {
        return dsbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsbgv_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgv_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbgvd_$descriptor() {
        return dsbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbgvd_$handle() {
        return dsbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbgvd_$address() {
        return dsbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dsbgvd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dsbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgvd_", __jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbgvx_$descriptor() {
        return dsbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbgvx_$handle() {
        return dsbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbgvx_$address() {
        return dsbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dsbgvx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ka, MemorySegment __kb, MemorySegment __ab, MemorySegment __ldab, MemorySegment __bb, MemorySegment __ldbb, MemorySegment __q, MemorySegment __ldq, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dsbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgvx_", __jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ka, __kb, __ab, __ldab, __bb, __ldbb, __q, __ldq, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsbtrd_$descriptor() {
        return dsbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsbtrd_$handle() {
        return dsbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsbtrd_$address() {
        return dsbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsbtrd_(MemorySegment __vect, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbtrd_", __vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __uplo, __n, __kd, __ab, __ldab, __d__, __e, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublereal *__c__)
     * }
     */
    public static FunctionDescriptor dsfrk_$descriptor() {
        return dsfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublereal *__c__)
     * }
     */
    public static MethodHandle dsfrk_$handle() {
        return dsfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublereal *__c__)
     * }
     */
    public static MemorySegment dsfrk_$address() {
        return dsfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__beta, __CLPK_doublereal *__c__)
     * }
     */
    public static int dsfrk_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __trans, MemorySegment __n, MemorySegment __k, MemorySegment __alpha, MemorySegment __a, MemorySegment __lda, MemorySegment __beta, MemorySegment __c__) {
        var mh$ = dsfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsfrk_", __transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __trans, __n, __k, __alpha, __a, __lda, __beta, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsgesv_$descriptor() {
        return dsgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsgesv_$handle() {
        return dsgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsgesv_$address() {
        return dsgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static int dsgesv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __swork, MemorySegment __iter, MemorySegment __info) {
        var mh$ = dsgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsgesv_", __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __x, __ldx, __work, __swork, __iter, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __x, __ldx, __work, __swork, __iter, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspcon_$descriptor() {
        return dspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspcon_$handle() {
        return dspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspcon_$address() {
        return dspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dspcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspcon_", __uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspev_$descriptor() {
        return dspev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspev_$handle() {
        return dspev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspev_$address() {
        return dspev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dspev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dspev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspev_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspevd_$descriptor() {
        return dspevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspevd_$handle() {
        return dspevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspevd_$address() {
        return dspevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dspevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dspevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspevd_", __jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __ap, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspevx_$descriptor() {
        return dspevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspevx_$handle() {
        return dspevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspevx_$address() {
        return dspevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dspevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dspevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspevx_", __jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __ap, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspgst_$descriptor() {
        return dspgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspgst_$handle() {
        return dspgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspgst_$address() {
        return dspgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_integer *__info)
     * }
     */
    public static int dspgst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __info) {
        var mh$ = dspgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgst_", __itype, __uplo, __n, __ap, __bp, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __ap, __bp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspgv_$descriptor() {
        return dspgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspgv_$handle() {
        return dspgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspgv_$address() {
        return dspgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dspgv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dspgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgv_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspgvd_$descriptor() {
        return dspgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspgvd_$handle() {
        return dspgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspgvd_$address() {
        return dspgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dspgvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dspgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgvd_", __itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __ap, __bp, __w, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspgvx_$descriptor() {
        return dspgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspgvx_$handle() {
        return dspgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspgvx_$address() {
        return dspgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dspgvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __bp, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dspgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgvx_", __itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __ap, __bp, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsposv_$descriptor() {
        return dsposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsposv_$handle() {
        return dsposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsposv_$address() {
        return dsposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter, __CLPK_integer *__info)
     * }
     */
    public static int dsposv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __work, MemorySegment __swork, MemorySegment __iter, MemorySegment __info) {
        var mh$ = dsposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsposv_", __uplo, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __work, __swork, __iter, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __work, __swork, __iter, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsprfs_$descriptor() {
        return dsprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsprfs_$handle() {
        return dsprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsprfs_$address() {
        return dsprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dsprfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dsprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsprfs_", __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspsv_$descriptor() {
        return dspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspsv_$handle() {
        return dspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspsv_$address() {
        return dspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dspsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspsv_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dspsvx_$descriptor() {
        return dspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dspsvx_$handle() {
        return dspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dspsvx_$address() {
        return dspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__afp, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dspsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __afp, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspsvx_", __fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __ap, __afp, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsptrd_$descriptor() {
        return dsptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsptrd_$handle() {
        return dsptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsptrd_$address() {
        return dsptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static int dsptrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = dsptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrd_", __uplo, __n, __ap, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsptrf_$descriptor() {
        return dsptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsptrf_$handle() {
        return dsptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsptrf_$address() {
        return dsptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dsptrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dsptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrf_", __uplo, __n, __ap, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsptri_$descriptor() {
        return dsptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsptri_$handle() {
        return dsptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsptri_$address() {
        return dsptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsptri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptri_", __uplo, __n, __ap, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsptrs_$descriptor() {
        return dsptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsptrs_$handle() {
        return dsptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsptrs_$address() {
        return dsptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dsptrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dsptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrs_", __uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __ap, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstebz_$descriptor() {
        return dstebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstebz_$handle() {
        return dstebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstebz_$address() {
        return dstebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstebz_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_integer *__nsplit, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dstebz_(MemorySegment __range, MemorySegment __order, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __d__, MemorySegment __e, MemorySegment __m, MemorySegment __nsplit, MemorySegment __w, MemorySegment __iblock, MemorySegment __isplit, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dstebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstebz_", __range, __order, __n, __vl, __vu, __il, __iu, __abstol, __d__, __e, __m, __nsplit, __w, __iblock, __isplit, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__range, __order, __n, __vl, __vu, __il, __iu, __abstol, __d__, __e, __m, __nsplit, __w, __iblock, __isplit, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstedc_$descriptor() {
        return dstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstedc_$handle() {
        return dstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstedc_$address() {
        return dstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dstedc_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstedc_", __compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstegr_$descriptor() {
        return dstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstegr_$handle() {
        return dstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstegr_$address() {
        return dstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstegr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dstegr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstegr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstein_$descriptor() {
        return dstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstein_$handle() {
        return dstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstein_$address() {
        return dstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_integer *__iblock, __CLPK_integer *__isplit, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dstein_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __m, MemorySegment __w, MemorySegment __iblock, MemorySegment __isplit, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstein_", __n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __m, __w, __iblock, __isplit, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstemr_$descriptor() {
        return dstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstemr_$handle() {
        return dstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstemr_$address() {
        return dstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstemr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz, __CLPK_logical *__tryrac, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dstemr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __nzc, MemorySegment __isuppz, MemorySegment __tryrac, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstemr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __m, __w, __z__, __ldz, __nzc, __isuppz, __tryrac, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsteqr_$descriptor() {
        return dsteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsteqr_$handle() {
        return dsteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsteqr_$address() {
        return dsteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsteqr_(MemorySegment __compz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsteqr_", __compz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__compz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsterf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsterf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsterf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsterf_$descriptor() {
        return dsterf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsterf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsterf_$handle() {
        return dsterf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsterf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsterf_$address() {
        return dsterf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsterf_(__CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__info)
     * }
     */
    public static int dsterf_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = dsterf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsterf_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstev_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstev_$descriptor() {
        return dstev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstev_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstev_$handle() {
        return dstev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstev_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstev_$address() {
        return dstev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstev_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dstev_(MemorySegment __jobz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __info) {
        var mh$ = dstev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstev_", __jobz, __n, __d__, __e, __z__, __ldz, __work, __info);
            }
            return (int)mh$.invokeExact(__jobz, __n, __d__, __e, __z__, __ldz, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstevd_$descriptor() {
        return dstevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstevd_$handle() {
        return dstevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstevd_$address() {
        return dstevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dstevd_(MemorySegment __jobz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dstevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevd_", __jobz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __n, __d__, __e, __z__, __ldz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstevr_$descriptor() {
        return dstevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstevr_$handle() {
        return dstevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstevr_$address() {
        return dstevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstevr_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dstevr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dstevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevr_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dstevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dstevx_$descriptor() {
        return dstevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dstevx_$handle() {
        return dstevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dstevx_$address() {
        return dstevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dstevx_(char *__jobz, char *__range, __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dstevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dstevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevx_", __jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __n, __d__, __e, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsycon_$descriptor() {
        return dsycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsycon_$handle() {
        return dsycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsycon_$address() {
        return dsycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dsycon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dsycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsycon_", __uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsyequb_$descriptor() {
        return dsyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsyequb_$handle() {
        return dsyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsyequb_$address() {
        return dsyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__scond, __CLPK_doublereal *__amax, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsyequb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyequb_", __uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsyev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsyev_$descriptor() {
        return dsyev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsyev_$handle() {
        return dsyev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsyev_$address() {
        return dsyev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dsyev_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dsyev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyev_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsyevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsyevd_$descriptor() {
        return dsyevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsyevd_$handle() {
        return dsyevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsyevd_$address() {
        return dsyevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dsyevd_(MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dsyevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevd_", __jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsyevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsyevr_$descriptor() {
        return dsyevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsyevr_$handle() {
        return dsyevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsyevr_$address() {
        return dsyevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dsyevr_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dsyevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevr_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __isuppz, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsyevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsyevx_$descriptor() {
        return dsyevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsyevx_$handle() {
        return dsyevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsyevx_$address() {
        return dsyevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dsyevx_(MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dsyevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevx_", __jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__jobz, __range, __uplo, __n, __a, __lda, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsygs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsygs2_$descriptor() {
        return dsygs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsygs2_$handle() {
        return dsygs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsygs2_$address() {
        return dsygs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dsygs2_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dsygs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygs2_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsygst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsygst_$descriptor() {
        return dsygst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsygst_$handle() {
        return dsygst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsygst_$address() {
        return dsygst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dsygst_(MemorySegment __itype, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dsygst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygst_", __itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__itype, __uplo, __n, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsygv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsygv_$descriptor() {
        return dsygv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsygv_$handle() {
        return dsygv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsygv_$address() {
        return dsygv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dsygv_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dsygv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygv_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsygvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsygvd_$descriptor() {
        return dsygvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsygvd_$handle() {
        return dsygvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsygvd_$address() {
        return dsygvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dsygvd_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __w, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dsygvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygvd_", __itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __uplo, __n, __a, __lda, __b, __ldb, __w, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsygvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsygvx_$descriptor() {
        return dsygvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsygvx_$handle() {
        return dsygvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsygvx_$address() {
        return dsygvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m, __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail, __CLPK_integer *__info)
     * }
     */
    public static int dsygvx_(MemorySegment __itype, MemorySegment __jobz, MemorySegment __range, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __abstol, MemorySegment __m, MemorySegment __w, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __ifail, MemorySegment __info) {
        var mh$ = dsygvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygvx_", __itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
            }
            return (int)mh$.invokeExact(__itype, __jobz, __range, __uplo, __n, __a, __lda, __b, __ldb, __vl, __vu, __il, __iu, __abstol, __m, __w, __z__, __ldz, __work, __lwork, __iwork, __ifail, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsyrfs_$descriptor() {
        return dsyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsyrfs_$handle() {
        return dsyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsyrfs_$address() {
        return dsyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dsyrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dsyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyrfs_", __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsysv_$descriptor() {
        return dsysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsysv_$handle() {
        return dsysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsysv_$address() {
        return dsysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dsysv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dsysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsysvx_$descriptor() {
        return dsysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsysvx_$handle() {
        return dsysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsysvx_$address() {
        return dsysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dsysvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dsysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysvx_", __fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsytd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsytd2_$descriptor() {
        return dsytd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsytd2_$handle() {
        return dsytd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsytd2_$address() {
        return dsytd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static int dsytd2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __info) {
        var mh$ = dsytd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytd2_", __uplo, __n, __a, __lda, __d__, __e, __tau, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsytf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsytf2_$descriptor() {
        return dsytf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsytf2_$handle() {
        return dsytf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsytf2_$address() {
        return dsytf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int dsytf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = dsytf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytf2_", __uplo, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsytrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsytrd_$descriptor() {
        return dsytrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsytrd_$handle() {
        return dsytrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsytrd_$address() {
        return dsytrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dsytrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dsytrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrd_", __uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __d__, __e, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsytrf_$descriptor() {
        return dsytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsytrf_$handle() {
        return dsytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsytrf_$address() {
        return dsytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dsytrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dsytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_", __uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsytri_$descriptor() {
        return dsytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsytri_$handle() {
        return dsytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsytri_$address() {
        return dsytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dsytri_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __info) {
        var mh$ = dsytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri_", __uplo, __n, __a, __lda, __ipiv, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ipiv, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dsytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dsytrs_$descriptor() {
        return dsytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dsytrs_$handle() {
        return dsytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dsytrs_$address() {
        return dsytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dsytrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dsytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_", __uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtbcon_$descriptor() {
        return dtbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtbcon_$handle() {
        return dtbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtbcon_$address() {
        return dtbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtbcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbcon_", __norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __kd, __ab, __ldab, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtbrfs_$descriptor() {
        return dtbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtbrfs_$handle() {
        return dtbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtbrfs_$address() {
        return dtbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtbrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbrfs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtbtrs_$descriptor() {
        return dtbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtbtrs_$handle() {
        return dtbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtbtrs_$address() {
        return dtbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dtbtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dtbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbtrs_", __uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor dtfsm_$descriptor() {
        return dtfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle dtfsm_$handle() {
        return dtfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment dtfsm_$address() {
        return dtfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtfsm_(char *__transr, char *__side, char *__uplo, char *__trans, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a, __CLPK_doublereal *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int dtfsm_(MemorySegment __transr, MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __a, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = dtfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfsm_", __transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
            }
            return (int)mh$.invokeExact(__transr, __side, __uplo, __trans, __diag, __m, __n, __alpha, __a, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtftri_$descriptor() {
        return dtftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtftri_$handle() {
        return dtftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtftri_$address() {
        return dtftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__info)
     * }
     */
    public static int dtftri_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = dtftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtftri_", __transr, __uplo, __diag, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __diag, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtfttp_$descriptor() {
        return dtfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtfttp_$handle() {
        return dtfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtfttp_$address() {
        return dtfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtfttp_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static int dtfttp_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __ap, MemorySegment __info) {
        var mh$ = dtfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfttp_", __transr, __uplo, __n, __arf, __ap, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtfttr_$descriptor() {
        return dtfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtfttr_$handle() {
        return dtfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtfttr_$address() {
        return dtfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtfttr_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__arf, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dtfttr_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __arf, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dtfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfttr_", __transr, __uplo, __n, __arf, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __arf, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_doublereal *__p, __CLPK_integer *__ldp, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgevc_$descriptor() {
        return dtgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_doublereal *__p, __CLPK_integer *__ldp, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgevc_$handle() {
        return dtgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_doublereal *__p, __CLPK_integer *__ldp, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgevc_$address() {
        return dtgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__s, __CLPK_integer *__lds, __CLPK_doublereal *__p, __CLPK_integer *__ldp, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dtgevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __s, MemorySegment __lds, MemorySegment __p, MemorySegment __ldp, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __info) {
        var mh$ = dtgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgevc_", __side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __s, __lds, __p, __ldp, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgex2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgex2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgex2_$descriptor() {
        return dtgex2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgex2_$handle() {
        return dtgex2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgex2_$address() {
        return dtgex2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dtgex2_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __j1, MemorySegment __n1, MemorySegment __n2, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dtgex2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgex2_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __n1, __n2, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __j1, __n1, __n2, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgexc_$descriptor() {
        return dtgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgexc_$handle() {
        return dtgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgexc_$address() {
        return dtgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dtgexc_(MemorySegment __wantq, MemorySegment __wantz, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dtgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgexc_", __wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantq, __wantz, __n, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __ifst, __ilst, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgsen_$descriptor() {
        return dtgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgsen_$handle() {
        return dtgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgsen_$address() {
        return dtgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq, __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl, __CLPK_doublereal *__pr, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dtgsen_(MemorySegment __ijob, MemorySegment __wantq, MemorySegment __wantz, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __m, MemorySegment __pl, MemorySegment __pr, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dtgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsen_", __ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__ijob, __wantq, __wantz, __select, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __m, __pl, __pr, __dif, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgsja_$descriptor() {
        return dtgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgsja_$handle() {
        return dtgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgsja_$address() {
        return dtgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb, __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__work, __CLPK_integer *__ncycle, __CLPK_integer *__info)
     * }
     */
    public static int dtgsja_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __ncycle, MemorySegment __info) {
        var mh$ = dtgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsja_", __jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __k, __l, __a, __lda, __b, __ldb, __tola, __tolb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __ncycle, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgsna_$descriptor() {
        return dtgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgsna_$handle() {
        return dtgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgsna_$address() {
        return dtgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtgsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __dif, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsna_", __job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __a, __lda, __b, __ldb, __vl, __ldvl, __vr, __ldvr, __s, __dif, __mm, __m, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgsy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgsy2_$descriptor() {
        return dtgsy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgsy2_$handle() {
        return dtgsy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgsy2_$address() {
        return dtgsy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal, __CLPK_integer *__iwork, __CLPK_integer *__pq, __CLPK_integer *__info)
     * }
     */
    public static int dtgsy2_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __iwork, MemorySegment __pq, MemorySegment __info) {
        var mh$ = dtgsy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsy2_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __iwork, __pq, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __rdsum, __rdscal, __iwork, __pq, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtgsyl_$descriptor() {
        return dtgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtgsyl_$handle() {
        return dtgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtgsyl_$address() {
        return dtgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd, __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f, __CLPK_integer *__ldf, __CLPK_doublereal *__scale, __CLPK_doublereal *__dif, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtgsyl_(MemorySegment __trans, MemorySegment __ijob, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __d__, MemorySegment __ldd, MemorySegment __e, MemorySegment __lde, MemorySegment __f, MemorySegment __ldf, MemorySegment __scale, MemorySegment __dif, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsyl_", __trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __ijob, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __d__, __ldd, __e, __lde, __f, __ldf, __scale, __dif, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtpcon_$descriptor() {
        return dtpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtpcon_$handle() {
        return dtpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtpcon_$address() {
        return dtpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtpcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpcon_", __norm, __uplo, __diag, __n, __ap, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtprfs_$descriptor() {
        return dtprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtprfs_$handle() {
        return dtprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtprfs_$address() {
        return dtprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtprfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtprfs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtptri_$descriptor() {
        return dtptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtptri_$handle() {
        return dtptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtptri_$address() {
        return dtptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtptri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static int dtptri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __info) {
        var mh$ = dtptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtptri_", __uplo, __diag, __n, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtptrs_$descriptor() {
        return dtptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtptrs_$handle() {
        return dtptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtptrs_$address() {
        return dtptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dtptrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __ap, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dtptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtptrs_", __uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __ap, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtpttf_$descriptor() {
        return dtpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtpttf_$handle() {
        return dtpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtpttf_$address() {
        return dtpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtpttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static int dtpttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __arf, MemorySegment __info) {
        var mh$ = dtpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpttf_", __transr, __uplo, __n, __ap, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __ap, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtpttr_$descriptor() {
        return dtpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtpttr_$handle() {
        return dtpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtpttr_$address() {
        return dtpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dtpttr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dtpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpttr_", __uplo, __n, __ap, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrcon_$descriptor() {
        return dtrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrcon_$handle() {
        return dtrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrcon_$address() {
        return dtrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__rcond, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtrcon_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrcon_", __norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __uplo, __diag, __n, __a, __lda, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrevc_$descriptor() {
        return dtrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrevc_$handle() {
        return dtrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrevc_$address() {
        return dtrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrevc_(char *__side, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dtrevc_(MemorySegment __side, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __info) {
        var mh$ = dtrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrevc_", __side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrexc_$descriptor() {
        return dtrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrexc_$handle() {
        return dtrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrexc_$address() {
        return dtrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__ifst, __CLPK_integer *__ilst, __CLPK_doublereal *__work, __CLPK_integer *__info)
     * }
     */
    public static int dtrexc_(MemorySegment __compq, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __ifst, MemorySegment __ilst, MemorySegment __work, MemorySegment __info) {
        var mh$ = dtrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrexc_", __compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __work, __info);
            }
            return (int)mh$.invokeExact(__compq, __n, __t, __ldt, __q, __ldq, __ifst, __ilst, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrrfs_$descriptor() {
        return dtrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrrfs_$handle() {
        return dtrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrrfs_$address() {
        return dtrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx, __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr, __CLPK_doublereal *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtrrfs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrrfs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrsen_$descriptor() {
        return dtrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrsen_$handle() {
        return dtrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrsen_$address() {
        return dtrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrsen_(char *__job, char *__compq, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi, __CLPK_integer *__m, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_integer *__info)
     * }
     */
    public static int dtrsen_(MemorySegment __job, MemorySegment __compq, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __wr, MemorySegment __wi, MemorySegment __m, MemorySegment __s, MemorySegment __sep, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __info) {
        var mh$ = dtrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsen_", __job, __compq, __select, __n, __t, __ldt, __q, __ldq, __wr, __wi, __m, __s, __sep, __work, __lwork, __iwork, __liwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __select, __n, __t, __ldt, __q, __ldq, __wr, __wi, __m, __s, __sep, __work, __lwork, __iwork, __liwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrsna_$descriptor() {
        return dtrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrsna_$handle() {
        return dtrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrsna_$address() {
        return dtrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrsna_(char *__job, char *__howmny, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__vl, __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s, __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__ldwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int dtrsna_(MemorySegment __job, MemorySegment __howmny, MemorySegment __select, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __s, MemorySegment __sep, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __ldwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = dtrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsna_", __job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__job, __howmny, __select, __n, __t, __ldt, __vl, __ldvl, __vr, __ldvr, __s, __sep, __mm, __m, __work, __ldwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrsyl_$descriptor() {
        return dtrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrsyl_$handle() {
        return dtrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrsyl_$address() {
        return dtrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__, __CLPK_integer *__ldc, __CLPK_doublereal *__scale, __CLPK_integer *__info)
     * }
     */
    public static int dtrsyl_(MemorySegment __trana, MemorySegment __tranb, MemorySegment __isgn, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __ldc, MemorySegment __scale, MemorySegment __info) {
        var mh$ = dtrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsyl_", __trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
            }
            return (int)mh$.invokeExact(__trana, __tranb, __isgn, __m, __n, __a, __lda, __b, __ldb, __c__, __ldc, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrti2_$descriptor() {
        return dtrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrti2_$handle() {
        return dtrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrti2_$address() {
        return dtrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrti2_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dtrti2_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dtrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrti2_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrtri_$descriptor() {
        return dtrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrtri_$handle() {
        return dtrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrtri_$address() {
        return dtrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrtri_(char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int dtrtri_(MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = dtrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtri_", __uplo, __diag, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __diag, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrtrs_$descriptor() {
        return dtrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrtrs_$handle() {
        return dtrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrtrs_$address() {
        return dtrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int dtrtrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = dtrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtrs_", __uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __n, __nrhs, __a, __lda, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrttf_$descriptor() {
        return dtrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrttf_$handle() {
        return dtrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrttf_$address() {
        return dtrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrttf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__arf, __CLPK_integer *__info)
     * }
     */
    public static int dtrttf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __arf, MemorySegment __info) {
        var mh$ = dtrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrttf_", __transr, __uplo, __n, __a, __lda, __arf, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __lda, __arf, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtrttp_$descriptor() {
        return dtrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtrttp_$handle() {
        return dtrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtrttp_$address() {
        return dtrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__ap, __CLPK_integer *__info)
     * }
     */
    public static int dtrttp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ap, MemorySegment __info) {
        var mh$ = dtrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrttp_", __uplo, __n, __a, __lda, __ap, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __ap, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtzrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtzrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtzrqf_$descriptor() {
        return dtzrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtzrqf_$handle() {
        return dtzrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtzrqf_$address() {
        return dtzrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_integer *__info)
     * }
     */
    public static int dtzrqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __info) {
        var mh$ = dtzrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtzrqf_", __m, __n, __a, __lda, __tau, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dtzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor dtzrzf_$descriptor() {
        return dtzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle dtzrzf_$handle() {
        return dtzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment dtzrzf_$address() {
        return dtzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int dtzrzf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = dtzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtzrzf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dzsum1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("dzsum1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal dzsum1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor dzsum1_$descriptor() {
        return dzsum1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal dzsum1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle dzsum1_$handle() {
        return dzsum1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal dzsum1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment dzsum1_$address() {
        return dzsum1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal dzsum1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static double dzsum1_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx) {
        var mh$ = dzsum1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dzsum1_", __n, __cx, __incx);
            }
            return (double)mh$.invokeExact(__n, __cx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class icmax1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("icmax1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer icmax1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor icmax1_$descriptor() {
        return icmax1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer icmax1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle icmax1_$handle() {
        return icmax1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer icmax1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment icmax1_$address() {
        return icmax1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer icmax1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static int icmax1_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx) {
        var mh$ = icmax1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("icmax1_", __n, __cx, __incx);
            }
            return (int)mh$.invokeExact(__n, __cx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ieeeck_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ieeeck_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ieeeck_(__CLPK_integer *__ispec, __CLPK_real *__zero, __CLPK_real *__one)
     * }
     */
    public static FunctionDescriptor ieeeck_$descriptor() {
        return ieeeck_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ieeeck_(__CLPK_integer *__ispec, __CLPK_real *__zero, __CLPK_real *__one)
     * }
     */
    public static MethodHandle ieeeck_$handle() {
        return ieeeck_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ieeeck_(__CLPK_integer *__ispec, __CLPK_real *__zero, __CLPK_real *__one)
     * }
     */
    public static MemorySegment ieeeck_$address() {
        return ieeeck_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ieeeck_(__CLPK_integer *__ispec, __CLPK_real *__zero, __CLPK_real *__one)
     * }
     */
    public static int ieeeck_(MemorySegment __ispec, MemorySegment __zero, MemorySegment __one) {
        var mh$ = ieeeck_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ieeeck_", __ispec, __zero, __one);
            }
            return (int)mh$.invokeExact(__ispec, __zero, __one);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaclc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaclc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilaclc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor ilaclc_$descriptor() {
        return ilaclc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilaclc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle ilaclc_$handle() {
        return ilaclc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilaclc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment ilaclc_$address() {
        return ilaclc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilaclc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int ilaclc_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = ilaclc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaclc_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaclr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaclr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilaclr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor ilaclr_$descriptor() {
        return ilaclr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilaclr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle ilaclr_$handle() {
        return ilaclr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilaclr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment ilaclr_$address() {
        return ilaclr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilaclr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int ilaclr_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = ilaclr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaclr_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iladiag_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("iladiag_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer iladiag_(char *__diag)
     * }
     */
    public static FunctionDescriptor iladiag_$descriptor() {
        return iladiag_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer iladiag_(char *__diag)
     * }
     */
    public static MethodHandle iladiag_$handle() {
        return iladiag_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer iladiag_(char *__diag)
     * }
     */
    public static MemorySegment iladiag_$address() {
        return iladiag_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer iladiag_(char *__diag)
     * }
     */
    public static int iladiag_(MemorySegment __diag) {
        var mh$ = iladiag_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iladiag_", __diag);
            }
            return (int)mh$.invokeExact(__diag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iladlc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("iladlc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer iladlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor iladlc_$descriptor() {
        return iladlc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer iladlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle iladlc_$handle() {
        return iladlc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer iladlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment iladlc_$address() {
        return iladlc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer iladlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static int iladlc_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = iladlc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iladlc_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iladlr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("iladlr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer iladlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor iladlr_$descriptor() {
        return iladlr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer iladlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle iladlr_$handle() {
        return iladlr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer iladlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment iladlr_$address() {
        return iladlr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer iladlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda)
     * }
     */
    public static int iladlr_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = iladlr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iladlr_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaenv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaenv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilaenv_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_integer *__n3, __CLPK_integer *__n4)
     * }
     */
    public static FunctionDescriptor ilaenv_$descriptor() {
        return ilaenv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilaenv_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_integer *__n3, __CLPK_integer *__n4)
     * }
     */
    public static MethodHandle ilaenv_$handle() {
        return ilaenv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilaenv_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_integer *__n3, __CLPK_integer *__n4)
     * }
     */
    public static MemorySegment ilaenv_$address() {
        return ilaenv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilaenv_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_integer *__n3, __CLPK_integer *__n4)
     * }
     */
    public static int ilaenv_(MemorySegment __ispec, MemorySegment __name__, MemorySegment __opts, MemorySegment __n1, MemorySegment __n2, MemorySegment __n3, MemorySegment __n4) {
        var mh$ = ilaenv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaenv_", __ispec, __name__, __opts, __n1, __n2, __n3, __n4);
            }
            return (int)mh$.invokeExact(__ispec, __name__, __opts, __n1, __n2, __n3, __n4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaprec_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaprec_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilaprec_(char *__prec)
     * }
     */
    public static FunctionDescriptor ilaprec_$descriptor() {
        return ilaprec_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilaprec_(char *__prec)
     * }
     */
    public static MethodHandle ilaprec_$handle() {
        return ilaprec_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilaprec_(char *__prec)
     * }
     */
    public static MemorySegment ilaprec_$address() {
        return ilaprec_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilaprec_(char *__prec)
     * }
     */
    public static int ilaprec_(MemorySegment __prec) {
        var mh$ = ilaprec_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaprec_", __prec);
            }
            return (int)mh$.invokeExact(__prec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaslc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaslc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilaslc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor ilaslc_$descriptor() {
        return ilaslc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilaslc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle ilaslc_$handle() {
        return ilaslc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilaslc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment ilaslc_$address() {
        return ilaslc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilaslc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static int ilaslc_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = ilaslc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaslc_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaslr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaslr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilaslr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor ilaslr_$descriptor() {
        return ilaslr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilaslr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle ilaslr_$handle() {
        return ilaslr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilaslr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment ilaslr_$address() {
        return ilaslr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilaslr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static int ilaslr_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = ilaslr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaslr_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilatrans_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilatrans_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilatrans_(char *__trans)
     * }
     */
    public static FunctionDescriptor ilatrans_$descriptor() {
        return ilatrans_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilatrans_(char *__trans)
     * }
     */
    public static MethodHandle ilatrans_$handle() {
        return ilatrans_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilatrans_(char *__trans)
     * }
     */
    public static MemorySegment ilatrans_$address() {
        return ilatrans_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilatrans_(char *__trans)
     * }
     */
    public static int ilatrans_(MemorySegment __trans) {
        var mh$ = ilatrans_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilatrans_", __trans);
            }
            return (int)mh$.invokeExact(__trans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilauplo_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilauplo_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilauplo_(char *__uplo)
     * }
     */
    public static FunctionDescriptor ilauplo_$descriptor() {
        return ilauplo_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilauplo_(char *__uplo)
     * }
     */
    public static MethodHandle ilauplo_$handle() {
        return ilauplo_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilauplo_(char *__uplo)
     * }
     */
    public static MemorySegment ilauplo_$address() {
        return ilauplo_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilauplo_(char *__uplo)
     * }
     */
    public static int ilauplo_(MemorySegment __uplo) {
        var mh$ = ilauplo_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilauplo_", __uplo);
            }
            return (int)mh$.invokeExact(__uplo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaver_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilaver_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilaver_(__CLPK_integer *__vers_major__, __CLPK_integer *__vers_minor__, __CLPK_integer *__vers_patch__)
     * }
     */
    public static FunctionDescriptor ilaver_$descriptor() {
        return ilaver_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilaver_(__CLPK_integer *__vers_major__, __CLPK_integer *__vers_minor__, __CLPK_integer *__vers_patch__)
     * }
     */
    public static MethodHandle ilaver_$handle() {
        return ilaver_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilaver_(__CLPK_integer *__vers_major__, __CLPK_integer *__vers_minor__, __CLPK_integer *__vers_patch__)
     * }
     */
    public static MemorySegment ilaver_$address() {
        return ilaver_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilaver_(__CLPK_integer *__vers_major__, __CLPK_integer *__vers_minor__, __CLPK_integer *__vers_patch__)
     * }
     */
    public static int ilaver_(MemorySegment __vers_major__, MemorySegment __vers_minor__, MemorySegment __vers_patch__) {
        var mh$ = ilaver_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaver_", __vers_major__, __vers_minor__, __vers_patch__);
            }
            return (int)mh$.invokeExact(__vers_major__, __vers_minor__, __vers_patch__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilazlc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilazlc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilazlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor ilazlc_$descriptor() {
        return ilazlc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilazlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle ilazlc_$handle() {
        return ilazlc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilazlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment ilazlc_$address() {
        return ilazlc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilazlc_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int ilazlc_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = ilazlc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilazlc_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilazlr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("ilazlr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer ilazlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor ilazlr_$descriptor() {
        return ilazlr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer ilazlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle ilazlr_$handle() {
        return ilazlr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer ilazlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment ilazlr_$address() {
        return ilazlr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer ilazlr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublecomplex *__a, __CLPK_integer *__lda)
     * }
     */
    public static int ilazlr_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda) {
        var mh$ = ilazlr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilazlr_", __m, __n, __a, __lda);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iparmq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("iparmq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer iparmq_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor iparmq_$descriptor() {
        return iparmq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer iparmq_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle iparmq_$handle() {
        return iparmq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer iparmq_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment iparmq_$address() {
        return iparmq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer iparmq_(__CLPK_integer *__ispec, char *__name__, char *__opts, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_integer *__lwork)
     * }
     */
    public static int iparmq_(MemorySegment __ispec, MemorySegment __name__, MemorySegment __opts, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lwork) {
        var mh$ = iparmq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iparmq_", __ispec, __name__, __opts, __n, __ilo, __ihi, __lwork);
            }
            return (int)mh$.invokeExact(__ispec, __name__, __opts, __n, __ilo, __ihi, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class izmax1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("izmax1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer izmax1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor izmax1_$descriptor() {
        return izmax1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer izmax1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle izmax1_$handle() {
        return izmax1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer izmax1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment izmax1_$address() {
        return izmax1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer izmax1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static int izmax1_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx) {
        var mh$ = izmax1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("izmax1_", __n, __cx, __incx);
            }
            return (int)mh$.invokeExact(__n, __cx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lsamen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("lsamen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_logical lsamen_(__CLPK_integer *__n, char *__ca, char *__cb)
     * }
     */
    public static FunctionDescriptor lsamen_$descriptor() {
        return lsamen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_logical lsamen_(__CLPK_integer *__n, char *__ca, char *__cb)
     * }
     */
    public static MethodHandle lsamen_$handle() {
        return lsamen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_logical lsamen_(__CLPK_integer *__n, char *__ca, char *__cb)
     * }
     */
    public static MemorySegment lsamen_$address() {
        return lsamen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_logical lsamen_(__CLPK_integer *__n, char *__ca, char *__cb)
     * }
     */
    public static int lsamen_(MemorySegment __n, MemorySegment __ca, MemorySegment __cb) {
        var mh$ = lsamen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsamen_", __n, __ca, __cb);
            }
            return (int)mh$.invokeExact(__n, __ca, __cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class smaxloc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("smaxloc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer smaxloc_(__CLPK_real *__a, __CLPK_integer *__dimm)
     * }
     */
    public static FunctionDescriptor smaxloc_$descriptor() {
        return smaxloc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer smaxloc_(__CLPK_real *__a, __CLPK_integer *__dimm)
     * }
     */
    public static MethodHandle smaxloc_$handle() {
        return smaxloc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer smaxloc_(__CLPK_real *__a, __CLPK_integer *__dimm)
     * }
     */
    public static MemorySegment smaxloc_$address() {
        return smaxloc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer smaxloc_(__CLPK_real *__a, __CLPK_integer *__dimm)
     * }
     */
    public static int smaxloc_(MemorySegment __a, MemorySegment __dimm) {
        var mh$ = smaxloc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("smaxloc_", __a, __dimm);
            }
            return (int)mh$.invokeExact(__a, __dimm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsdc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sbdsdc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__q, __CLPK_integer *__iq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sbdsdc_$descriptor() {
        return sbdsdc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__q, __CLPK_integer *__iq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sbdsdc_$handle() {
        return sbdsdc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__q, __CLPK_integer *__iq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sbdsdc_$address() {
        return sbdsdc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__q, __CLPK_integer *__iq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sbdsdc_(MemorySegment __uplo, MemorySegment __compq, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __q, MemorySegment __iq, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sbdsdc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsdc_", __uplo, __compq, __n, __d__, __e, __u, __ldu, __vt, __ldvt, __q, __iq, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __compq, __n, __d__, __e, __u, __ldu, __vt, __ldvt, __q, __iq, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sbdsqr_$descriptor() {
        return sbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sbdsqr_$handle() {
        return sbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sbdsqr_$address() {
        return sbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sbdsqr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ncvt, MemorySegment __nru, MemorySegment __ncc, MemorySegment __d__, MemorySegment __e, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __u, MemorySegment __ldu, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsqr_", __uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scsum1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("scsum1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal scsum1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor scsum1_$descriptor() {
        return scsum1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal scsum1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle scsum1_$handle() {
        return scsum1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal scsum1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment scsum1_$address() {
        return scsum1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal scsum1_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx)
     * }
     */
    public static double scsum1_(MemorySegment __n, MemorySegment __cx, MemorySegment __incx) {
        var mh$ = scsum1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scsum1_", __n, __cx, __incx);
            }
            return (double)mh$.invokeExact(__n, __cx, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sdisna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sdisna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sdisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__sep, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sdisna_$descriptor() {
        return sdisna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sdisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__sep, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sdisna_$handle() {
        return sdisna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sdisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__sep, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sdisna_$address() {
        return sdisna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sdisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__sep, __CLPK_integer *__info)
     * }
     */
    public static int sdisna_(MemorySegment __job, MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __sep, MemorySegment __info) {
        var mh$ = sdisna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sdisna_", __job, __m, __n, __d__, __sep, __info);
            }
            return (int)mh$.invokeExact(__job, __m, __n, __d__, __sep, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__pt, __CLPK_integer *__ldpt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbbrd_$descriptor() {
        return sgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__pt, __CLPK_integer *__ldpt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbbrd_$handle() {
        return sgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__pt, __CLPK_integer *__ldpt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbbrd_$address() {
        return sgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__pt, __CLPK_integer *__ldpt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgbbrd_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __ncc, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __pt, MemorySegment __ldpt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbbrd_", __vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __ncc, __kl, __ku, __ab, __ldab, __d__, __e, __q, __ldq, __pt, __ldpt, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbcon_$descriptor() {
        return sgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbcon_$handle() {
        return sgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbcon_$address() {
        return sgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgbcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbcon_", __norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbequ_$descriptor() {
        return sgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbequ_$handle() {
        return sgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbequ_$address() {
        return sgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int sgbequ_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = sgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbequ_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbequb_$descriptor() {
        return sgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbequb_$handle() {
        return sgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbequb_$address() {
        return sgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int sgbequb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = sgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbequb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbrfs_$descriptor() {
        return sgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbrfs_$handle() {
        return sgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbrfs_$address() {
        return sgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgbrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbrfs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbsv_$descriptor() {
        return sgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbsv_$handle() {
        return sgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbsv_$address() {
        return sgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sgbsv_(MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsv_", __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbsvx_$descriptor() {
        return sgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbsvx_$handle() {
        return sgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbsvx_$address() {
        return sgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgbsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsvx_", __fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __afb, __ldafb, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbtf2_$descriptor() {
        return sgbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbtf2_$handle() {
        return sgbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbtf2_$address() {
        return sgbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int sgbtf2_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = sgbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtf2_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbtrf_$descriptor() {
        return sgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbtrf_$handle() {
        return sgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbtrf_$address() {
        return sgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int sgbtrf_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = sgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtrf_", __m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgbtrs_$descriptor() {
        return sgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgbtrs_$handle() {
        return sgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgbtrs_$address() {
        return sgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sgbtrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtrs_", __trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __kl, __ku, __nrhs, __ab, __ldab, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgebak_$descriptor() {
        return sgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgebak_$handle() {
        return sgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgebak_$address() {
        return sgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgebak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int sgebak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = sgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebak_", __job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __scale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgebal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgebal_$descriptor() {
        return sgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgebal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgebal_$handle() {
        return sgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgebal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgebal_$address() {
        return sgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgebal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_integer *__info)
     * }
     */
    public static int sgebal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __info) {
        var mh$ = sgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebal_", __job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __ilo, __ihi, __scale, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgebd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgebd2_$descriptor() {
        return sgebd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgebd2_$handle() {
        return sgebd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgebd2_$address() {
        return sgebd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgebd2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgebd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebd2_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgebrd_$descriptor() {
        return sgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgebrd_$handle() {
        return sgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgebrd_$address() {
        return sgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgebrd_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebrd_", __m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __d__, __e, __tauq, __taup, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgecon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgecon_$descriptor() {
        return sgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgecon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgecon_$handle() {
        return sgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgecon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgecon_$address() {
        return sgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgecon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgecon_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgecon_", __norm, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __a, __lda, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeequ_$descriptor() {
        return sgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeequ_$handle() {
        return sgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeequ_$address() {
        return sgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int sgeequ_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = sgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeequ_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeequb_$descriptor() {
        return sgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeequb_$handle() {
        return sgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeequb_$address() {
        return sgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int sgeequb_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __info) {
        var mh$ = sgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeequb_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgees_$descriptor() {
        return sgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgees_$handle() {
        return sgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgees_$address() {
        return sgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int sgees_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __wr, MemorySegment __wi, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __work, MemorySegment __lwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = sgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgees_", __jobvs, __sort, __select, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __work, __lwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __work, __lwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeesx_$descriptor() {
        return sgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeesx_$handle() {
        return sgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeesx_$address() {
        return sgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int sgeesx_(MemorySegment __jobvs, MemorySegment __sort, MemorySegment __select, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sdim, MemorySegment __wr, MemorySegment __wi, MemorySegment __vs, MemorySegment __ldvs, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = sgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeesx_", __jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvs, __sort, __select, __sense, __n, __a, __lda, __sdim, __wr, __wi, __vs, __ldvs, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeev_$descriptor() {
        return sgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeev_$handle() {
        return sgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeev_$address() {
        return sgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgeev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __wr, MemorySegment __wi, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeev_", __jobvl, __jobvr, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeevx_$descriptor() {
        return sgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeevx_$handle() {
        return sgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeevx_$address() {
        return sgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgeevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __wr, MemorySegment __wi, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __scale, MemorySegment __abnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __scale, __abnrm, __rconde, __rcondv, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgegs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgegs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgegs_$descriptor() {
        return sgegs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgegs_$handle() {
        return sgegs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgegs_$address() {
        return sgegs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgegs_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgegs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgegs_", __jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgegv_$descriptor() {
        return sgegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgegv_$handle() {
        return sgegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgegv_$address() {
        return sgegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgegv_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgegv_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgehd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgehd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgehd2_$descriptor() {
        return sgehd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgehd2_$handle() {
        return sgehd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgehd2_$address() {
        return sgehd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgehd2_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgehd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgehd2_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgehrd_$descriptor() {
        return sgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgehrd_$handle() {
        return sgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgehrd_$address() {
        return sgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgehrd_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgehrd_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgejsv_$descriptor() {
        return sgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgejsv_$handle() {
        return sgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgejsv_$address() {
        return sgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr, char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgejsv_(MemorySegment __joba, MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobr, MemorySegment __jobt, MemorySegment __jobp, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sva, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgejsv_", __joba, __jobu, __jobv, __jobr, __jobt, __jobp, __m, __n, __a, __lda, __sva, __u, __ldu, __v, __ldv, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__joba, __jobu, __jobv, __jobr, __jobt, __jobp, __m, __n, __a, __lda, __sva, __u, __ldu, __v, __ldv, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgelq2_$descriptor() {
        return sgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgelq2_$handle() {
        return sgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgelq2_$address() {
        return sgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgelq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgelqf_$descriptor() {
        return sgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgelqf_$handle() {
        return sgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgelqf_$address() {
        return sgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgelqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgels_$descriptor() {
        return sgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgels_$handle() {
        return sgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgels_$address() {
        return sgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgels_(MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgels_", __trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __m, __n, __nrhs, __a, __lda, __b, __ldb, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgelsd_$descriptor() {
        return sgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgelsd_$handle() {
        return sgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgelsd_$address() {
        return sgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgelsd_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsd_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgelss_$descriptor() {
        return sgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgelss_$handle() {
        return sgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgelss_$address() {
        return sgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgelss_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __s, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelss_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __s, __rcond, __rank, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgelsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgelsx_$descriptor() {
        return sgelsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgelsx_$handle() {
        return sgelsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgelsx_$address() {
        return sgelsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgelsx_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgelsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsx_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgelsy_$descriptor() {
        return sgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgelsy_$handle() {
        return sgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgelsy_$address() {
        return sgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgelsy_(MemorySegment __m, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __jpvt, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsy_", __m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __nrhs, __a, __lda, __b, __ldb, __jpvt, __rcond, __rank, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeql2_$descriptor() {
        return sgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeql2_$handle() {
        return sgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeql2_$address() {
        return sgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgeql2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeql2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeqlf_$descriptor() {
        return sgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeqlf_$handle() {
        return sgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeqlf_$address() {
        return sgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgeqlf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqlf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeqp3_$descriptor() {
        return sgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeqp3_$handle() {
        return sgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeqp3_$address() {
        return sgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgeqp3_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqp3_", __m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeqpf_$descriptor() {
        return sgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeqpf_$handle() {
        return sgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeqpf_$address() {
        return sgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgeqpf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqpf_", __m, __n, __a, __lda, __jpvt, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __jpvt, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeqr2_$descriptor() {
        return sgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeqr2_$handle() {
        return sgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeqr2_$address() {
        return sgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgeqr2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqr2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgeqrf_$descriptor() {
        return sgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgeqrf_$handle() {
        return sgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgeqrf_$address() {
        return sgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgeqrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgerfs_$descriptor() {
        return sgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgerfs_$handle() {
        return sgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgerfs_$address() {
        return sgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgerfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerfs_", __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgerq2_$descriptor() {
        return sgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgerq2_$handle() {
        return sgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgerq2_$address() {
        return sgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sgerq2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerq2_", __m, __n, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgerqf_$descriptor() {
        return sgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgerqf_$handle() {
        return sgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgerqf_$address() {
        return sgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgerqf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerqf_", __m, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgesc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static FunctionDescriptor sgesc2_$descriptor() {
        return sgesc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static MethodHandle sgesc2_$handle() {
        return sgesc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static MemorySegment sgesc2_$address() {
        return sgesc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_real *__scale)
     * }
     */
    public static int sgesc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __rhs, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __scale) {
        var mh$ = sgesc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesc2_", __n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __rhs, __ipiv, __jpiv, __scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgesdd_$descriptor() {
        return sgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgesdd_$handle() {
        return sgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgesdd_$address() {
        return sgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgesdd_(MemorySegment __jobz, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesdd_", __jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobz, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgesv_$descriptor() {
        return sgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgesv_$handle() {
        return sgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgesv_$address() {
        return sgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sgesv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesv_", __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgesvd_$descriptor() {
        return sgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgesvd_$handle() {
        return sgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgesvd_$address() {
        return sgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgesvd_(MemorySegment __jobu, MemorySegment __jobvt, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvd_", __jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobvt, __m, __n, __a, __lda, __s, __u, __ldu, __vt, __ldvt, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgesvj_$descriptor() {
        return sgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgesvj_$handle() {
        return sgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgesvj_$address() {
        return sgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgesvj_(MemorySegment __joba, MemorySegment __jobu, MemorySegment __jobv, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __sva, MemorySegment __mv, MemorySegment __v, MemorySegment __ldv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvj_", __joba, __jobu, __jobv, __m, __n, __a, __lda, __sva, __mv, __v, __ldv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__joba, __jobu, __jobv, __m, __n, __a, __lda, __sva, __mv, __v, __ldv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgesvx_$descriptor() {
        return sgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgesvx_$handle() {
        return sgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgesvx_$address() {
        return sgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgesvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgesvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __af, MemorySegment __ldaf, MemorySegment __ipiv, MemorySegment __equed, MemorySegment __r__, MemorySegment __c__, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvx_", __fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __a, __lda, __af, __ldaf, __ipiv, __equed, __r__, __c__, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetc2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgetc2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgetc2_$descriptor() {
        return sgetc2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgetc2_$handle() {
        return sgetc2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgetc2_$address() {
        return sgetc2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv, __CLPK_integer *__info)
     * }
     */
    public static int sgetc2_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __jpiv, MemorySegment __info) {
        var mh$ = sgetc2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetc2_", __n, __a, __lda, __ipiv, __jpiv, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __jpiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgetf2_$descriptor() {
        return sgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgetf2_$handle() {
        return sgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgetf2_$address() {
        return sgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int sgetf2_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = sgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetf2_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgetrf_$descriptor() {
        return sgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgetrf_$handle() {
        return sgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgetrf_$address() {
        return sgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int sgetrf_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = sgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrf_", __m, __n, __a, __lda, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetri_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgetri_$descriptor() {
        return sgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetri_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgetri_$handle() {
        return sgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetri_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgetri_$address() {
        return sgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetri_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgetri_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetri_", __n, __a, __lda, __ipiv, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __ipiv, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgetrs_$descriptor() {
        return sgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgetrs_$handle() {
        return sgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgetrs_$address() {
        return sgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sgetrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrs_", __trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __a, __lda, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggbak_$descriptor() {
        return sggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggbak_$handle() {
        return sggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggbak_$address() {
        return sggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggbak_(char *__job, char *__side, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__info)
     * }
     */
    public static int sggbak_(MemorySegment __job, MemorySegment __side, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __m, MemorySegment __v, MemorySegment __ldv, MemorySegment __info) {
        var mh$ = sggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggbak_", __job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
            }
            return (int)mh$.invokeExact(__job, __side, __n, __ilo, __ihi, __lscale, __rscale, __m, __v, __ldv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggbal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggbal_$descriptor() {
        return sggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggbal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggbal_$handle() {
        return sggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggbal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggbal_$address() {
        return sggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggbal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sggbal_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __work, MemorySegment __info) {
        var mh$ = sggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggbal_", __job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __lda, __b, __ldb, __ilo, __ihi, __lscale, __rscale, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgges_$descriptor() {
        return sgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgges_$handle() {
        return sgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgges_$address() {
        return sgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int sgges_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __work, MemorySegment __lwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = sgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgges_", __jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __work, __lwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggesx_$descriptor() {
        return sggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggesx_$handle() {
        return sggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggesx_$address() {
        return sggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__liwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int sggesx_(MemorySegment __jobvsl, MemorySegment __jobvsr, MemorySegment __sort, MemorySegment __selctg, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __sdim, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vsl, MemorySegment __ldvsl, MemorySegment __vsr, MemorySegment __ldvsr, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __liwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = sggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggesx_", __jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__jobvsl, __jobvsr, __sort, __selctg, __sense, __n, __a, __lda, __b, __ldb, __sdim, __alphar, __alphai, __beta, __vsl, __ldvsl, __vsr, __ldvsr, __rconde, __rcondv, __work, __lwork, __iwork, __liwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggev_$descriptor() {
        return sggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggev_$handle() {
        return sggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggev_$address() {
        return sggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sggev_(MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggev_", __jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobvl, __jobvr, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggevx_$descriptor() {
        return sggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggevx_$handle() {
        return sggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggevx_$address() {
        return sggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork, __CLPK_integer *__info)
     * }
     */
    public static int sggevx_(MemorySegment __balanc, MemorySegment __jobvl, MemorySegment __jobvr, MemorySegment __sense, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __lscale, MemorySegment __rscale, MemorySegment __abnrm, MemorySegment __bbnrm, MemorySegment __rconde, MemorySegment __rcondv, MemorySegment __work, MemorySegment __lwork, MemorySegment __iwork, MemorySegment __bwork, MemorySegment __info) {
        var mh$ = sggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggevx_", __balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __iwork, __bwork, __info);
            }
            return (int)mh$.invokeExact(__balanc, __jobvl, __jobvr, __sense, __n, __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __vl, __ldvl, __vr, __ldvr, __ilo, __ihi, __lscale, __rscale, __abnrm, __bbnrm, __rconde, __rcondv, __work, __lwork, __iwork, __bwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggglm_$descriptor() {
        return sggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggglm_$handle() {
        return sggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggglm_$address() {
        return sggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sggglm_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __d__, MemorySegment __x, MemorySegment __y, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggglm_", __n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __b, __ldb, __d__, __x, __y, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgghrd_$descriptor() {
        return sgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgghrd_$handle() {
        return sgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgghrd_$address() {
        return sgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgghrd_(char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int sgghrd_(MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = sgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgghrd_", __compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__compq, __compz, __n, __ilo, __ihi, __a, __lda, __b, __ldb, __q, __ldq, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgglse_$descriptor() {
        return sgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgglse_$handle() {
        return sgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgglse_$address() {
        return sgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgglse_(MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __c__, MemorySegment __d__, MemorySegment __x, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgglse_", __m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __p, __a, __lda, __b, __ldb, __c__, __d__, __x, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggqrf_$descriptor() {
        return sggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggqrf_$handle() {
        return sggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggqrf_$address() {
        return sggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sggqrf_(MemorySegment __n, MemorySegment __m, MemorySegment __p, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggqrf_", __n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __m, __p, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggrqf_$descriptor() {
        return sggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggrqf_$handle() {
        return sggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggrqf_$address() {
        return sggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sggrqf_(MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __taua, MemorySegment __b, MemorySegment __ldb, MemorySegment __taub, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggrqf_", __m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __p, __n, __a, __lda, __taua, __b, __ldb, __taub, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggsvd_$descriptor() {
        return sggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggsvd_$handle() {
        return sggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggsvd_$address() {
        return sggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sggsvd_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __n, MemorySegment __p, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvd_", __jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __n, __p, __k, __l, __a, __lda, __b, __ldb, __alpha, __beta, __u, __ldu, __v, __ldv, __q, __ldq, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sggsvp_$descriptor() {
        return sggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sggsvp_$handle() {
        return sggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sggsvp_$address() {
        return sggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sggsvp_(MemorySegment __jobu, MemorySegment __jobv, MemorySegment __jobq, MemorySegment __m, MemorySegment __p, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __tola, MemorySegment __tolb, MemorySegment __k, MemorySegment __l, MemorySegment __u, MemorySegment __ldu, MemorySegment __v, MemorySegment __ldv, MemorySegment __q, MemorySegment __ldq, MemorySegment __iwork, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvp_", __jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__jobu, __jobv, __jobq, __m, __p, __n, __a, __lda, __b, __ldb, __tola, __tolb, __k, __l, __u, __ldu, __v, __ldv, __q, __ldq, __iwork, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgsvj0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgsvj0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgsvj0_$descriptor() {
        return sgsvj0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgsvj0_$handle() {
        return sgsvj0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgsvj0_$address() {
        return sgsvj0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgsvj0_(MemorySegment __jobv, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __sva, MemorySegment __mv, MemorySegment __v, MemorySegment __ldv, MemorySegment __eps, MemorySegment __sfmin, MemorySegment __tol, MemorySegment __nsweep, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgsvj0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgsvj0_", __jobv, __m, __n, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobv, __m, __n, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgsvj1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgsvj1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgsvj1_$descriptor() {
        return sgsvj1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgsvj1_$handle() {
        return sgsvj1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgsvj1_$address() {
        return sgsvj1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sgsvj1_(MemorySegment __jobv, MemorySegment __m, MemorySegment __n, MemorySegment __n1, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __sva, MemorySegment __mv, MemorySegment __v, MemorySegment __ldv, MemorySegment __eps, MemorySegment __sfmin, MemorySegment __tol, MemorySegment __nsweep, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sgsvj1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgsvj1_", __jobv, __m, __n, __n1, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__jobv, __m, __n, __n1, __a, __lda, __d__, __sva, __mv, __v, __ldv, __eps, __sfmin, __tol, __nsweep, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgtcon_$descriptor() {
        return sgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgtcon_$handle() {
        return sgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgtcon_$address() {
        return sgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgtcon_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtcon_", __norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__norm, __n, __dl, __d__, __du, __du2, __ipiv, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgtrfs_$descriptor() {
        return sgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgtrfs_$handle() {
        return sgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgtrfs_$address() {
        return sgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgtrfs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtrfs_", __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgtsv_$descriptor() {
        return sgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgtsv_$handle() {
        return sgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgtsv_$address() {
        return sgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sgtsv_(MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtsv_", __n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__n, __nrhs, __dl, __d__, __du, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgtsvx_$descriptor() {
        return sgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgtsvx_$handle() {
        return sgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgtsvx_$address() {
        return sgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int sgtsvx_(MemorySegment __fact, MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __dlf, MemorySegment __df, MemorySegment __duf, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = sgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtsvx_", __fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __trans, __n, __nrhs, __dl, __d__, __du, __dlf, __df, __duf, __du2, __ipiv, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgttrf_(__CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgttrf_$descriptor() {
        return sgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgttrf_(__CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgttrf_$handle() {
        return sgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgttrf_(__CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgttrf_$address() {
        return sgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgttrf_(__CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_integer *__info)
     * }
     */
    public static int sgttrf_(MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __info) {
        var mh$ = sgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgttrf_", __n, __dl, __d__, __du, __du2, __ipiv, __info);
            }
            return (int)mh$.invokeExact(__n, __dl, __d__, __du, __du2, __ipiv, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sgttrs_$descriptor() {
        return sgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sgttrs_$handle() {
        return sgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sgttrs_$address() {
        return sgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int sgttrs_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = sgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgttrs_", __trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtts2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sgtts2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor sgtts2_$descriptor() {
        return sgtts2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle sgtts2_$handle() {
        return sgtts2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment sgtts2_$address() {
        return sgtts2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int sgtts2_(MemorySegment __itrans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __du2, MemorySegment __ipiv, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = sgtts2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtts2_", __itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
            }
            return (int)mh$.invokeExact(__itrans, __n, __nrhs, __dl, __d__, __du, __du2, __ipiv, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("shgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor shgeqz_$descriptor() {
        return shgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle shgeqz_$handle() {
        return shgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int shgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment shgeqz_$address() {
        return shgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int shgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int shgeqz_(MemorySegment __job, MemorySegment __compq, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __t, MemorySegment __ldt, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __q, MemorySegment __ldq, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = shgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shgeqz_", __job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compq, __compz, __n, __ilo, __ihi, __h__, __ldh, __t, __ldt, __alphar, __alphai, __beta, __q, __ldq, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("shsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor shsein_$descriptor() {
        return shsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle shsein_$handle() {
        return shsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int shsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment shsein_$address() {
        return shsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int shsein_(char *__side, char *__eigsrc, char *__initv, __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_real *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr, __CLPK_integer *__info)
     * }
     */
    public static int shsein_(MemorySegment __side, MemorySegment __eigsrc, MemorySegment __initv, MemorySegment __select, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __vl, MemorySegment __ldvl, MemorySegment __vr, MemorySegment __ldvr, MemorySegment __mm, MemorySegment __m, MemorySegment __work, MemorySegment __ifaill, MemorySegment __ifailr, MemorySegment __info) {
        var mh$ = shsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shsein_", __side, __eigsrc, __initv, __select, __n, __h__, __ldh, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __ifaill, __ifailr, __info);
            }
            return (int)mh$.invokeExact(__side, __eigsrc, __initv, __select, __n, __h__, __ldh, __wr, __wi, __vl, __ldvl, __vr, __ldvr, __mm, __m, __work, __ifaill, __ifailr, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("shseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor shseqr_$descriptor() {
        return shseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle shseqr_$handle() {
        return shseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int shseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment shseqr_$address() {
        return shseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int shseqr_(char *__job, char *__compz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int shseqr_(MemorySegment __job, MemorySegment __compz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = shseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shseqr_", __job, __compz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__job, __compz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sisnan_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sisnan_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_logical sisnan_(__CLPK_real *__sin__)
     * }
     */
    public static FunctionDescriptor sisnan_$descriptor() {
        return sisnan_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_logical sisnan_(__CLPK_real *__sin__)
     * }
     */
    public static MethodHandle sisnan_$handle() {
        return sisnan_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_logical sisnan_(__CLPK_real *__sin__)
     * }
     */
    public static MemorySegment sisnan_$address() {
        return sisnan_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_logical sisnan_(__CLPK_real *__sin__)
     * }
     */
    public static int sisnan_(MemorySegment __sin__) {
        var mh$ = sisnan_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sisnan_", __sin__);
            }
            return (int)mh$.invokeExact(__sin__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slabad_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slabad_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slabad_(__CLPK_real *__small, __CLPK_real *__large)
     * }
     */
    public static FunctionDescriptor slabad_$descriptor() {
        return slabad_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slabad_(__CLPK_real *__small, __CLPK_real *__large)
     * }
     */
    public static MethodHandle slabad_$handle() {
        return slabad_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slabad_(__CLPK_real *__small, __CLPK_real *__large)
     * }
     */
    public static MemorySegment slabad_$address() {
        return slabad_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slabad_(__CLPK_real *__small, __CLPK_real *__large)
     * }
     */
    public static int slabad_(MemorySegment __small, MemorySegment __large) {
        var mh$ = slabad_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slabad_", __small, __large);
            }
            return (int)mh$.invokeExact(__small, __large);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slabrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slabrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor slabrd_$descriptor() {
        return slabrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle slabrd_$handle() {
        return slabrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment slabrd_$address() {
        return slabrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int slabrd_(MemorySegment __m, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __d__, MemorySegment __e, MemorySegment __tauq, MemorySegment __taup, MemorySegment __x, MemorySegment __ldx, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = slabrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slabrd_", __m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
            }
            return (int)mh$.invokeExact(__m, __n, __nb, __a, __lda, __d__, __e, __tauq, __taup, __x, __ldx, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slacn2_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static FunctionDescriptor slacn2_$descriptor() {
        return slacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slacn2_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MethodHandle slacn2_$handle() {
        return slacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slacn2_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static MemorySegment slacn2_$address() {
        return slacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slacn2_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase, __CLPK_integer *__isave)
     * }
     */
    public static int slacn2_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __isgn, MemorySegment __est, MemorySegment __kase, MemorySegment __isave) {
        var mh$ = slacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacn2_", __n, __v, __x, __isgn, __est, __kase, __isave);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __isgn, __est, __kase, __isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slacon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slacon_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static FunctionDescriptor slacon_$descriptor() {
        return slacon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slacon_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static MethodHandle slacon_$handle() {
        return slacon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slacon_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static MemorySegment slacon_$address() {
        return slacon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slacon_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x, __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase)
     * }
     */
    public static int slacon_(MemorySegment __n, MemorySegment __v, MemorySegment __x, MemorySegment __isgn, MemorySegment __est, MemorySegment __kase) {
        var mh$ = slacon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacon_", __n, __v, __x, __isgn, __est, __kase);
            }
            return (int)mh$.invokeExact(__n, __v, __x, __isgn, __est, __kase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor slacpy_$descriptor() {
        return slacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle slacpy_$handle() {
        return slacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment slacpy_$address() {
        return slacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int slacpy_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = slacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacpy_", __uplo, __m, __n, __a, __lda, __b, __ldb);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __a, __lda, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sladiv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sladiv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sladiv_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__p, __CLPK_real *__q)
     * }
     */
    public static FunctionDescriptor sladiv_$descriptor() {
        return sladiv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sladiv_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__p, __CLPK_real *__q)
     * }
     */
    public static MethodHandle sladiv_$handle() {
        return sladiv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sladiv_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__p, __CLPK_real *__q)
     * }
     */
    public static MemorySegment sladiv_$address() {
        return sladiv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sladiv_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__p, __CLPK_real *__q)
     * }
     */
    public static int sladiv_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __d__, MemorySegment __p, MemorySegment __q) {
        var mh$ = sladiv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sladiv_", __a, __b, __c__, __d__, __p, __q);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __d__, __p, __q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slae2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slae2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slae2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2)
     * }
     */
    public static FunctionDescriptor slae2_$descriptor() {
        return slae2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slae2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2)
     * }
     */
    public static MethodHandle slae2_$handle() {
        return slae2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slae2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2)
     * }
     */
    public static MemorySegment slae2_$address() {
        return slae2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slae2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2)
     * }
     */
    public static int slae2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2) {
        var mh$ = slae2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slae2_", __a, __b, __c__, __rt1, __rt2);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_real *__abstol, __CLPK_real *__reltol, __CLPK_real *__pivmin, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_integer *__nval, __CLPK_real *__ab, __CLPK_real *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaebz_$descriptor() {
        return slaebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_real *__abstol, __CLPK_real *__reltol, __CLPK_real *__pivmin, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_integer *__nval, __CLPK_real *__ab, __CLPK_real *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaebz_$handle() {
        return slaebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_real *__abstol, __CLPK_real *__reltol, __CLPK_real *__pivmin, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_integer *__nval, __CLPK_real *__ab, __CLPK_real *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaebz_$address() {
        return slaebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax, __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp, __CLPK_integer *__nbmin, __CLPK_real *__abstol, __CLPK_real *__reltol, __CLPK_real *__pivmin, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_integer *__nval, __CLPK_real *__ab, __CLPK_real *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slaebz_(MemorySegment __ijob, MemorySegment __nitmax, MemorySegment __n, MemorySegment __mmax, MemorySegment __minp, MemorySegment __nbmin, MemorySegment __abstol, MemorySegment __reltol, MemorySegment __pivmin, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __nval, MemorySegment __ab, MemorySegment __c__, MemorySegment __mout, MemorySegment __nab, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slaebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaebz_", __ijob, __nitmax, __n, __mmax, __minp, __nbmin, __abstol, __reltol, __pivmin, __d__, __e, __e2, __nval, __ab, __c__, __mout, __nab, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__ijob, __nitmax, __n, __mmax, __minp, __nbmin, __abstol, __reltol, __pivmin, __d__, __e, __e2, __nval, __ab, __c__, __mout, __nab, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed0_$descriptor() {
        return slaed0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed0_$handle() {
        return slaed0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed0_$address() {
        return slaed0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slaed0_(MemorySegment __icompq, MemorySegment __qsiz, MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __q, MemorySegment __ldq, MemorySegment __qstore, MemorySegment __ldqs, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slaed0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed0_", __icompq, __qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __qsiz, __n, __d__, __e, __q, __ldq, __qstore, __ldqs, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed1_$descriptor() {
        return slaed1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed1_$handle() {
        return slaed1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed1_$address() {
        return slaed1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slaed1_(MemorySegment __n, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slaed1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed1_", __n, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed2_$descriptor() {
        return slaed2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed2_$handle() {
        return slaed2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed2_$address() {
        return slaed2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__indxc, __CLPK_integer *__indxp, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static int slaed2_(MemorySegment __k, MemorySegment __n, MemorySegment __n1, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __z__, MemorySegment __dlamda, MemorySegment __w, MemorySegment __q2, MemorySegment __indx, MemorySegment __indxc, MemorySegment __indxp, MemorySegment __coltyp, MemorySegment __info) {
        var mh$ = slaed2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed2_", __k, __n, __n1, __d__, __q, __ldq, __indxq, __rho, __z__, __dlamda, __w, __q2, __indx, __indxc, __indxp, __coltyp, __info);
            }
            return (int)mh$.invokeExact(__k, __n, __n1, __d__, __q, __ldq, __indxq, __rho, __z__, __dlamda, __w, __q2, __indx, __indxc, __indxp, __coltyp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed3_$descriptor() {
        return slaed3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed3_$handle() {
        return slaed3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed3_$address() {
        return slaed3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static int slaed3_(MemorySegment __k, MemorySegment __n, MemorySegment __n1, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __rho, MemorySegment __dlamda, MemorySegment __q2, MemorySegment __indx, MemorySegment __ctot, MemorySegment __w, MemorySegment __s, MemorySegment __info) {
        var mh$ = slaed3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed3_", __k, __n, __n1, __d__, __q, __ldq, __rho, __dlamda, __q2, __indx, __ctot, __w, __s, __info);
            }
            return (int)mh$.invokeExact(__k, __n, __n1, __d__, __q, __ldq, __rho, __dlamda, __q2, __indx, __ctot, __w, __s, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed4_$descriptor() {
        return slaed4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed4_$handle() {
        return slaed4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed4_$address() {
        return slaed4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam, __CLPK_integer *__info)
     * }
     */
    public static int slaed4_(MemorySegment __n, MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __dlam, MemorySegment __info) {
        var mh$ = slaed4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed4_", __n, __i__, __d__, __z__, __delta, __rho, __dlam, __info);
            }
            return (int)mh$.invokeExact(__n, __i__, __d__, __z__, __delta, __rho, __dlam, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam)
     * }
     */
    public static FunctionDescriptor slaed5_$descriptor() {
        return slaed5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam)
     * }
     */
    public static MethodHandle slaed5_$handle() {
        return slaed5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam)
     * }
     */
    public static MemorySegment slaed5_$address() {
        return slaed5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dlam)
     * }
     */
    public static int slaed5_(MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __dlam) {
        var mh$ = slaed5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed5_", __i__, __d__, __z__, __delta, __rho, __dlam);
            }
            return (int)mh$.invokeExact(__i__, __d__, __z__, __delta, __rho, __dlam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed6_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed6_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_real *__rho, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__finit, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed6_$descriptor() {
        return slaed6_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_real *__rho, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__finit, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed6_$handle() {
        return slaed6_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_real *__rho, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__finit, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed6_$address() {
        return slaed6_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati, __CLPK_real *__rho, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__finit, __CLPK_real *__tau, __CLPK_integer *__info)
     * }
     */
    public static int slaed6_(MemorySegment __kniter, MemorySegment __orgati, MemorySegment __rho, MemorySegment __d__, MemorySegment __z__, MemorySegment __finit, MemorySegment __tau, MemorySegment __info) {
        var mh$ = slaed6_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed6_", __kniter, __orgati, __rho, __d__, __z__, __finit, __tau, __info);
            }
            return (int)mh$.invokeExact(__kniter, __orgati, __rho, __d__, __z__, __finit, __tau, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed7_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed7_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed7_$descriptor() {
        return slaed7_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed7_$handle() {
        return slaed7_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed7_$address() {
        return slaed7_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__qstore, __CLPK_integer *__qptr, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slaed7_(MemorySegment __icompq, MemorySegment __n, MemorySegment __qsiz, MemorySegment __tlvls, MemorySegment __curlvl, MemorySegment __curpbm, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __qstore, MemorySegment __qptr, MemorySegment __prmptr, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slaed7_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed7_", __icompq, __n, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __n, __qsiz, __tlvls, __curlvl, __curpbm, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __qstore, __qptr, __prmptr, __perm, __givptr, __givcol, __givnum, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed8_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed8_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed8_$descriptor() {
        return slaed8_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed8_$handle() {
        return slaed8_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed8_$address() {
        return slaed8_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda, __CLPK_real *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_integer *__indxp, __CLPK_integer *__indx, __CLPK_integer *__info)
     * }
     */
    public static int slaed8_(MemorySegment __icompq, MemorySegment __k, MemorySegment __n, MemorySegment __qsiz, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __indxq, MemorySegment __rho, MemorySegment __cutpnt, MemorySegment __z__, MemorySegment __dlamda, MemorySegment __q2, MemorySegment __ldq2, MemorySegment __w, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __indxp, MemorySegment __indx, MemorySegment __info) {
        var mh$ = slaed8_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed8_", __icompq, __k, __n, __qsiz, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __perm, __givptr, __givcol, __givnum, __indxp, __indx, __info);
            }
            return (int)mh$.invokeExact(__icompq, __k, __n, __qsiz, __d__, __q, __ldq, __indxq, __rho, __cutpnt, __z__, __dlamda, __q2, __ldq2, __w, __perm, __givptr, __givcol, __givnum, __indxp, __indx, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaed9_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaed9_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaed9_$descriptor() {
        return slaed9_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaed9_$handle() {
        return slaed9_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaed9_$address() {
        return slaed9_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart, __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__s, __CLPK_integer *__lds, __CLPK_integer *__info)
     * }
     */
    public static int slaed9_(MemorySegment __k, MemorySegment __kstart, MemorySegment __kstop, MemorySegment __n, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __rho, MemorySegment __dlamda, MemorySegment __w, MemorySegment __s, MemorySegment __lds, MemorySegment __info) {
        var mh$ = slaed9_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaed9_", __k, __kstart, __kstop, __n, __d__, __q, __ldq, __rho, __dlamda, __w, __s, __lds, __info);
            }
            return (int)mh$.invokeExact(__k, __kstart, __kstop, __n, __d__, __q, __ldq, __rho, __dlamda, __w, __s, __lds, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaeda_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaeda_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__q, __CLPK_integer *__qptr, __CLPK_real *__z__, __CLPK_real *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaeda_$descriptor() {
        return slaeda_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__q, __CLPK_integer *__qptr, __CLPK_real *__z__, __CLPK_real *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaeda_$handle() {
        return slaeda_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__q, __CLPK_integer *__qptr, __CLPK_real *__z__, __CLPK_real *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaeda_$address() {
        return slaeda_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls, __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_integer *__prmptr, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__q, __CLPK_integer *__qptr, __CLPK_real *__z__, __CLPK_real *__ztemp, __CLPK_integer *__info)
     * }
     */
    public static int slaeda_(MemorySegment __n, MemorySegment __tlvls, MemorySegment __curlvl, MemorySegment __curpbm, MemorySegment __prmptr, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __givnum, MemorySegment __q, MemorySegment __qptr, MemorySegment __z__, MemorySegment __ztemp, MemorySegment __info) {
        var mh$ = slaeda_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaeda_", __n, __tlvls, __curlvl, __curpbm, __prmptr, __perm, __givptr, __givcol, __givnum, __q, __qptr, __z__, __ztemp, __info);
            }
            return (int)mh$.invokeExact(__n, __tlvls, __curlvl, __curpbm, __prmptr, __perm, __givptr, __givcol, __givnum, __q, __qptr, __z__, __ztemp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vr, __CLPK_real *__vi, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_real *__bignum, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaein_$descriptor() {
        return slaein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vr, __CLPK_real *__vi, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_real *__bignum, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaein_$handle() {
        return slaein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vr, __CLPK_real *__vi, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_real *__bignum, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaein_$address() {
        return slaein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit, __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vr, __CLPK_real *__vi, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work, __CLPK_real *__eps3, __CLPK_real *__smlnum, __CLPK_real *__bignum, __CLPK_integer *__info)
     * }
     */
    public static int slaein_(MemorySegment __rightv, MemorySegment __noinit, MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __vr, MemorySegment __vi, MemorySegment __b, MemorySegment __ldb, MemorySegment __work, MemorySegment __eps3, MemorySegment __smlnum, MemorySegment __bignum, MemorySegment __info) {
        var mh$ = slaein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaein_", __rightv, __noinit, __n, __h__, __ldh, __wr, __wi, __vr, __vi, __b, __ldb, __work, __eps3, __smlnum, __bignum, __info);
            }
            return (int)mh$.invokeExact(__rightv, __noinit, __n, __h__, __ldh, __wr, __wi, __vr, __vi, __b, __ldb, __work, __eps3, __smlnum, __bignum, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaev2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaev2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaev2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_real *__sn1)
     * }
     */
    public static FunctionDescriptor slaev2_$descriptor() {
        return slaev2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaev2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_real *__sn1)
     * }
     */
    public static MethodHandle slaev2_$handle() {
        return slaev2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaev2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_real *__sn1)
     * }
     */
    public static MemorySegment slaev2_$address() {
        return slaev2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaev2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1, __CLPK_real *__sn1)
     * }
     */
    public static int slaev2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __rt1, MemorySegment __rt2, MemorySegment __cs1, MemorySegment __sn1) {
        var mh$ = slaev2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaev2_", __a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __rt1, __rt2, __cs1, __sn1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaexc_$descriptor() {
        return slaexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaexc_$handle() {
        return slaexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaexc_$address() {
        return slaexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slaexc_(MemorySegment __wantq, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __q, MemorySegment __ldq, MemorySegment __j1, MemorySegment __n1, MemorySegment __n2, MemorySegment __work, MemorySegment __info) {
        var mh$ = slaexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaexc_", __wantq, __n, __t, __ldt, __q, __ldq, __j1, __n1, __n2, __work, __info);
            }
            return (int)mh$.invokeExact(__wantq, __n, __t, __ldt, __q, __ldq, __j1, __n1, __n2, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slag2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slag2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slag2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__safmin, __CLPK_real *__scale1, __CLPK_real *__scale2, __CLPK_real *__wr1, __CLPK_real *__wr2, __CLPK_real *__wi)
     * }
     */
    public static FunctionDescriptor slag2_$descriptor() {
        return slag2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slag2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__safmin, __CLPK_real *__scale1, __CLPK_real *__scale2, __CLPK_real *__wr1, __CLPK_real *__wr2, __CLPK_real *__wi)
     * }
     */
    public static MethodHandle slag2_$handle() {
        return slag2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slag2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__safmin, __CLPK_real *__scale1, __CLPK_real *__scale2, __CLPK_real *__wr1, __CLPK_real *__wr2, __CLPK_real *__wi)
     * }
     */
    public static MemorySegment slag2_$address() {
        return slag2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slag2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__safmin, __CLPK_real *__scale1, __CLPK_real *__scale2, __CLPK_real *__wr1, __CLPK_real *__wr2, __CLPK_real *__wi)
     * }
     */
    public static int slag2_(MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __safmin, MemorySegment __scale1, MemorySegment __scale2, MemorySegment __wr1, MemorySegment __wr2, MemorySegment __wi) {
        var mh$ = slag2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slag2_", __a, __lda, __b, __ldb, __safmin, __scale1, __scale2, __wr1, __wr2, __wi);
            }
            return (int)mh$.invokeExact(__a, __lda, __b, __ldb, __safmin, __scale1, __scale2, __wr1, __wr2, __wi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slag2d_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slag2d_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slag2d_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slag2d_$descriptor() {
        return slag2d_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slag2d_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slag2d_$handle() {
        return slag2d_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slag2d_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slag2d_$address() {
        return slag2d_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slag2d_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__sa, __CLPK_integer *__ldsa, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int slag2d_(MemorySegment __m, MemorySegment __n, MemorySegment __sa, MemorySegment __ldsa, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = slag2d_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slag2d_", __m, __n, __sa, __ldsa, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __sa, __ldsa, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slags2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slags2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_real *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_real *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_real *__snu, __CLPK_real *__csv, __CLPK_real *__snv, __CLPK_real *__csq, __CLPK_real *__snq)
     * }
     */
    public static FunctionDescriptor slags2_$descriptor() {
        return slags2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_real *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_real *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_real *__snu, __CLPK_real *__csv, __CLPK_real *__snv, __CLPK_real *__csq, __CLPK_real *__snq)
     * }
     */
    public static MethodHandle slags2_$handle() {
        return slags2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_real *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_real *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_real *__snu, __CLPK_real *__csv, __CLPK_real *__snv, __CLPK_real *__csq, __CLPK_real *__snq)
     * }
     */
    public static MemorySegment slags2_$address() {
        return slags2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_real *__a2, __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_real *__b2, __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_real *__snu, __CLPK_real *__csv, __CLPK_real *__snv, __CLPK_real *__csq, __CLPK_real *__snq)
     * }
     */
    public static int slags2_(MemorySegment __upper, MemorySegment __a1, MemorySegment __a2, MemorySegment __a3, MemorySegment __b1, MemorySegment __b2, MemorySegment __b3, MemorySegment __csu, MemorySegment __snu, MemorySegment __csv, MemorySegment __snv, MemorySegment __csq, MemorySegment __snq) {
        var mh$ = slags2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slags2_", __upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
            }
            return (int)mh$.invokeExact(__upper, __a1, __a2, __a3, __b1, __b2, __b3, __csu, __snu, __csv, __snv, __csq, __snq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagtf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slagtf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slagtf_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__lambda, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__tol, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slagtf_$descriptor() {
        return slagtf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slagtf_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__lambda, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__tol, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slagtf_$handle() {
        return slagtf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slagtf_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__lambda, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__tol, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slagtf_$address() {
        return slagtf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slagtf_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__lambda, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__tol, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_integer *__info)
     * }
     */
    public static int slagtf_(MemorySegment __n, MemorySegment __a, MemorySegment __lambda, MemorySegment __b, MemorySegment __c__, MemorySegment __tol, MemorySegment __d__, MemorySegment __in, MemorySegment __info) {
        var mh$ = slagtf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagtf_", __n, __a, __lambda, __b, __c__, __tol, __d__, __in, __info);
            }
            return (int)mh$.invokeExact(__n, __a, __lambda, __b, __c__, __tol, __d__, __in, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagtm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slagtm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static FunctionDescriptor slagtm_$descriptor() {
        return slagtm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MethodHandle slagtm_$handle() {
        return slagtm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static MemorySegment slagtm_$address() {
        return slagtm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__alpha, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__beta, __CLPK_real *__b, __CLPK_integer *__ldb)
     * }
     */
    public static int slagtm_(MemorySegment __trans, MemorySegment __n, MemorySegment __nrhs, MemorySegment __alpha, MemorySegment __dl, MemorySegment __d__, MemorySegment __du, MemorySegment __x, MemorySegment __ldx, MemorySegment __beta, MemorySegment __b, MemorySegment __ldb) {
        var mh$ = slagtm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagtm_", __trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
            }
            return (int)mh$.invokeExact(__trans, __n, __nrhs, __alpha, __dl, __d__, __du, __x, __ldx, __beta, __b, __ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagts_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slagts_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_real *__y, __CLPK_real *__tol, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slagts_$descriptor() {
        return slagts_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_real *__y, __CLPK_real *__tol, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slagts_$handle() {
        return slagts_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_real *__y, __CLPK_real *__tol, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slagts_$address() {
        return slagts_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_integer *__in, __CLPK_real *__y, __CLPK_real *__tol, __CLPK_integer *__info)
     * }
     */
    public static int slagts_(MemorySegment __job, MemorySegment __n, MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __d__, MemorySegment __in, MemorySegment __y, MemorySegment __tol, MemorySegment __info) {
        var mh$ = slagts_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagts_", __job, __n, __a, __b, __c__, __d__, __in, __y, __tol, __info);
            }
            return (int)mh$.invokeExact(__job, __n, __a, __b, __c__, __d__, __in, __y, __tol, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagv2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slagv2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slagv2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__csl, __CLPK_real *__snl, __CLPK_real *__csr, __CLPK_real *__snr)
     * }
     */
    public static FunctionDescriptor slagv2_$descriptor() {
        return slagv2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slagv2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__csl, __CLPK_real *__snl, __CLPK_real *__csr, __CLPK_real *__snr)
     * }
     */
    public static MethodHandle slagv2_$handle() {
        return slagv2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slagv2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__csl, __CLPK_real *__snl, __CLPK_real *__csr, __CLPK_real *__snr)
     * }
     */
    public static MemorySegment slagv2_$address() {
        return slagv2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slagv2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__csl, __CLPK_real *__snl, __CLPK_real *__csr, __CLPK_real *__snr)
     * }
     */
    public static int slagv2_(MemorySegment __a, MemorySegment __lda, MemorySegment __b, MemorySegment __ldb, MemorySegment __alphar, MemorySegment __alphai, MemorySegment __beta, MemorySegment __csl, MemorySegment __snl, MemorySegment __csr, MemorySegment __snr) {
        var mh$ = slagv2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagv2_", __a, __lda, __b, __ldb, __alphar, __alphai, __beta, __csl, __snl, __csr, __snr);
            }
            return (int)mh$.invokeExact(__a, __lda, __b, __ldb, __alphar, __alphai, __beta, __csl, __snl, __csr, __snr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slahqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slahqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slahqr_$descriptor() {
        return slahqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slahqr_$handle() {
        return slahqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slahqr_$address() {
        return slahqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__info)
     * }
     */
    public static int slahqr_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __info) {
        var mh$ = slahqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slahqr_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slahr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slahr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor slahr2_$descriptor() {
        return slahr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle slahr2_$handle() {
        return slahr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment slahr2_$address() {
        return slahr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int slahr2_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = slahr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slahr2_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slahrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slahrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static FunctionDescriptor slahrd_$descriptor() {
        return slahrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MethodHandle slahrd_$handle() {
        return slahrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static MemorySegment slahrd_$address() {
        return slahrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y, __CLPK_integer *__ldy)
     * }
     */
    public static int slahrd_(MemorySegment __n, MemorySegment __k, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt, MemorySegment __y, MemorySegment __ldy) {
        var mh$ = slahrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slahrd_", __n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
            }
            return (int)mh$.invokeExact(__n, __k, __nb, __a, __lda, __tau, __t, __ldt, __y, __ldy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaic1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaic1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_real *__x, __CLPK_real *__sest, __CLPK_real *__w, __CLPK_real *__gamma, __CLPK_real *__sestpr, __CLPK_real *__s, __CLPK_real *__c__)
     * }
     */
    public static FunctionDescriptor slaic1_$descriptor() {
        return slaic1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_real *__x, __CLPK_real *__sest, __CLPK_real *__w, __CLPK_real *__gamma, __CLPK_real *__sestpr, __CLPK_real *__s, __CLPK_real *__c__)
     * }
     */
    public static MethodHandle slaic1_$handle() {
        return slaic1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_real *__x, __CLPK_real *__sest, __CLPK_real *__w, __CLPK_real *__gamma, __CLPK_real *__sestpr, __CLPK_real *__s, __CLPK_real *__c__)
     * }
     */
    public static MemorySegment slaic1_$address() {
        return slaic1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_real *__x, __CLPK_real *__sest, __CLPK_real *__w, __CLPK_real *__gamma, __CLPK_real *__sestpr, __CLPK_real *__s, __CLPK_real *__c__)
     * }
     */
    public static int slaic1_(MemorySegment __job, MemorySegment __j, MemorySegment __x, MemorySegment __sest, MemorySegment __w, MemorySegment __gamma, MemorySegment __sestpr, MemorySegment __s, MemorySegment __c__) {
        var mh$ = slaic1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaic1_", __job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
            }
            return (int)mh$.invokeExact(__job, __j, __x, __sest, __w, __gamma, __sestpr, __s, __c__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaisnan_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaisnan_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_logical slaisnan_(__CLPK_real *__sin1, __CLPK_real *__sin2)
     * }
     */
    public static FunctionDescriptor slaisnan_$descriptor() {
        return slaisnan_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_logical slaisnan_(__CLPK_real *__sin1, __CLPK_real *__sin2)
     * }
     */
    public static MethodHandle slaisnan_$handle() {
        return slaisnan_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_logical slaisnan_(__CLPK_real *__sin1, __CLPK_real *__sin2)
     * }
     */
    public static MemorySegment slaisnan_$address() {
        return slaisnan_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_logical slaisnan_(__CLPK_real *__sin1, __CLPK_real *__sin2)
     * }
     */
    public static int slaisnan_(MemorySegment __sin1, MemorySegment __sin2) {
        var mh$ = slaisnan_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaisnan_", __sin1, __sin2);
            }
            return (int)mh$.invokeExact(__sin1, __sin2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaln2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaln2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_real *__smin, __CLPK_real *__ca, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d1, __CLPK_real *__d2, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__scale, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaln2_$descriptor() {
        return slaln2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_real *__smin, __CLPK_real *__ca, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d1, __CLPK_real *__d2, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__scale, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaln2_$handle() {
        return slaln2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_real *__smin, __CLPK_real *__ca, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d1, __CLPK_real *__d2, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__scale, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaln2_$address() {
        return slaln2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na, __CLPK_integer *__nw, __CLPK_real *__smin, __CLPK_real *__ca, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d1, __CLPK_real *__d2, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__scale, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static int slaln2_(MemorySegment __ltrans, MemorySegment __na, MemorySegment __nw, MemorySegment __smin, MemorySegment __ca, MemorySegment __a, MemorySegment __lda, MemorySegment __d1, MemorySegment __d2, MemorySegment __b, MemorySegment __ldb, MemorySegment __wr, MemorySegment __wi, MemorySegment __x, MemorySegment __ldx, MemorySegment __scale, MemorySegment __xnorm, MemorySegment __info) {
        var mh$ = slaln2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaln2_", __ltrans, __na, __nw, __smin, __ca, __a, __lda, __d1, __d2, __b, __ldb, __wr, __wi, __x, __ldx, __scale, __xnorm, __info);
            }
            return (int)mh$.invokeExact(__ltrans, __na, __nw, __smin, __ca, __a, __lda, __d1, __d2, __b, __ldb, __wr, __wi, __x, __ldx, __scale, __xnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slals0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slals0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slals0_$descriptor() {
        return slals0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slals0_$handle() {
        return slals0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slals0_$address() {
        return slals0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slals0_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __poles, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __k, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __info) {
        var mh$ = slals0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slals0_", __icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __nrhs, __b, __ldb, __bx, __ldbx, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slalsa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slalsa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slalsa_$descriptor() {
        return slalsa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slalsa_$handle() {
        return slalsa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slalsa_$address() {
        return slalsa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slalsa_(MemorySegment __icompq, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __b, MemorySegment __ldb, MemorySegment __bx, MemorySegment __ldbx, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __k, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __poles, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __perm, MemorySegment __givnum, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slalsa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slalsa_", __icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __smlsiz, __n, __nrhs, __b, __ldb, __bx, __ldbx, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slalsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slalsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slalsd_$descriptor() {
        return slalsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slalsd_$handle() {
        return slalsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slalsd_$address() {
        return slalsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond, __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slalsd_(MemorySegment __uplo, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __nrhs, MemorySegment __d__, MemorySegment __e, MemorySegment __b, MemorySegment __ldb, MemorySegment __rcond, MemorySegment __rank, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slalsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slalsd_", __uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __smlsiz, __n, __nrhs, __d__, __e, __b, __ldb, __rcond, __rank, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamrg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slamrg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__a, __CLPK_integer *__strd1, __CLPK_integer *__strd2, __CLPK_integer *__index)
     * }
     */
    public static FunctionDescriptor slamrg_$descriptor() {
        return slamrg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__a, __CLPK_integer *__strd1, __CLPK_integer *__strd2, __CLPK_integer *__index)
     * }
     */
    public static MethodHandle slamrg_$handle() {
        return slamrg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__a, __CLPK_integer *__strd1, __CLPK_integer *__strd2, __CLPK_integer *__index)
     * }
     */
    public static MemorySegment slamrg_$address() {
        return slamrg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__a, __CLPK_integer *__strd1, __CLPK_integer *__strd2, __CLPK_integer *__index)
     * }
     */
    public static int slamrg_(MemorySegment __n1, MemorySegment __n2, MemorySegment __a, MemorySegment __strd1, MemorySegment __strd2, MemorySegment __index) {
        var mh$ = slamrg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamrg_", __n1, __n2, __a, __strd1, __strd2, __index);
            }
            return (int)mh$.invokeExact(__n1, __n2, __a, __strd1, __strd2, __index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaneg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaneg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_integer slaneg_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_real *__sigma, __CLPK_real *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static FunctionDescriptor slaneg_$descriptor() {
        return slaneg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_integer slaneg_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_real *__sigma, __CLPK_real *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static MethodHandle slaneg_$handle() {
        return slaneg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_integer slaneg_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_real *__sigma, __CLPK_real *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static MemorySegment slaneg_$address() {
        return slaneg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_integer slaneg_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_real *__sigma, __CLPK_real *__pivmin, __CLPK_integer *__r__)
     * }
     */
    public static int slaneg_(MemorySegment __n, MemorySegment __d__, MemorySegment __lld, MemorySegment __sigma, MemorySegment __pivmin, MemorySegment __r__) {
        var mh$ = slaneg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaneg_", __n, __d__, __lld, __sigma, __pivmin, __r__);
            }
            return (int)mh$.invokeExact(__n, __d__, __lld, __sigma, __pivmin, __r__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slangb_$descriptor() {
        return slangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slangb_$handle() {
        return slangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slangb_$address() {
        return slangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slangb_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double slangb_(MemorySegment __norm, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = slangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slangb_", __norm, __n, __kl, __ku, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __kl, __ku, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slange_$descriptor() {
        return slange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slange_$handle() {
        return slange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slange_$address() {
        return slange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slange_(char *__norm, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double slange_(MemorySegment __norm, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = slange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slange_", __norm, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slangt_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du)
     * }
     */
    public static FunctionDescriptor slangt_$descriptor() {
        return slangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slangt_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du)
     * }
     */
    public static MethodHandle slangt_$handle() {
        return slangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slangt_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du)
     * }
     */
    public static MemorySegment slangt_$address() {
        return slangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slangt_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du)
     * }
     */
    public static double slangt_(MemorySegment __norm, MemorySegment __n, MemorySegment __dl, MemorySegment __d__, MemorySegment __du) {
        var mh$ = slangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slangt_", __norm, __n, __dl, __d__, __du);
            }
            return (double)mh$.invokeExact(__norm, __n, __dl, __d__, __du);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slanhs_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slanhs_$descriptor() {
        return slanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slanhs_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slanhs_$handle() {
        return slanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slanhs_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slanhs_$address() {
        return slanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slanhs_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double slanhs_(MemorySegment __norm, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = slanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanhs_", __norm, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slansb_$descriptor() {
        return slansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slansb_$handle() {
        return slansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slansb_$address() {
        return slansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slansb_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double slansb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = slansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansb_", __norm, __uplo, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slansf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slansf_$descriptor() {
        return slansf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slansf_$handle() {
        return slansf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slansf_$address() {
        return slansf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slansf_(char *__norm, char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__work)
     * }
     */
    public static double slansf_(MemorySegment __norm, MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __work) {
        var mh$ = slansf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansf_", __norm, __transr, __uplo, __n, __a, __work);
            }
            return (double)mh$.invokeExact(__norm, __transr, __uplo, __n, __a, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slansp_$descriptor() {
        return slansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slansp_$handle() {
        return slansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slansp_$address() {
        return slansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slansp_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static double slansp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = slansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansp_", __norm, __uplo, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slanst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slanst_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e)
     * }
     */
    public static FunctionDescriptor slanst_$descriptor() {
        return slanst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slanst_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e)
     * }
     */
    public static MethodHandle slanst_$handle() {
        return slanst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slanst_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e)
     * }
     */
    public static MemorySegment slanst_$address() {
        return slanst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slanst_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e)
     * }
     */
    public static double slanst_(MemorySegment __norm, MemorySegment __n, MemorySegment __d__, MemorySegment __e) {
        var mh$ = slanst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanst_", __norm, __n, __d__, __e);
            }
            return (double)mh$.invokeExact(__norm, __n, __d__, __e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slansy_$descriptor() {
        return slansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slansy_$handle() {
        return slansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slansy_$address() {
        return slansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slansy_(char *__norm, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double slansy_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = slansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansy_", __norm, __uplo, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slantb_$descriptor() {
        return slantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slantb_$handle() {
        return slantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slantb_$address() {
        return slantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slantb_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__work)
     * }
     */
    public static double slantb_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __k, MemorySegment __ab, MemorySegment __ldab, MemorySegment __work) {
        var mh$ = slantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantb_", __norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __k, __ab, __ldab, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slantp_$descriptor() {
        return slantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slantp_$handle() {
        return slantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slantp_$address() {
        return slantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slantp_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__work)
     * }
     */
    public static double slantp_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __n, MemorySegment __ap, MemorySegment __work) {
        var mh$ = slantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantp_", __norm, __uplo, __diag, __n, __ap, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __n, __ap, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slantr_$descriptor() {
        return slantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slantr_$handle() {
        return slantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slantr_$address() {
        return slantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slantr_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__work)
     * }
     */
    public static double slantr_(MemorySegment __norm, MemorySegment __uplo, MemorySegment __diag, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __work) {
        var mh$ = slantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantr_", __norm, __uplo, __diag, __m, __n, __a, __lda, __work);
            }
            return (double)mh$.invokeExact(__norm, __uplo, __diag, __m, __n, __a, __lda, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanv2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slanv2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slanv2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__rt1r, __CLPK_real *__rt1i, __CLPK_real *__rt2r, __CLPK_real *__rt2i, __CLPK_real *__cs, __CLPK_real *__sn)
     * }
     */
    public static FunctionDescriptor slanv2_$descriptor() {
        return slanv2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slanv2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__rt1r, __CLPK_real *__rt1i, __CLPK_real *__rt2r, __CLPK_real *__rt2i, __CLPK_real *__cs, __CLPK_real *__sn)
     * }
     */
    public static MethodHandle slanv2_$handle() {
        return slanv2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slanv2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__rt1r, __CLPK_real *__rt1i, __CLPK_real *__rt2r, __CLPK_real *__rt2i, __CLPK_real *__cs, __CLPK_real *__sn)
     * }
     */
    public static MemorySegment slanv2_$address() {
        return slanv2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slanv2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__, __CLPK_real *__rt1r, __CLPK_real *__rt1i, __CLPK_real *__rt2r, __CLPK_real *__rt2i, __CLPK_real *__cs, __CLPK_real *__sn)
     * }
     */
    public static int slanv2_(MemorySegment __a, MemorySegment __b, MemorySegment __c__, MemorySegment __d__, MemorySegment __rt1r, MemorySegment __rt1i, MemorySegment __rt2r, MemorySegment __rt2i, MemorySegment __cs, MemorySegment __sn) {
        var mh$ = slanv2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanv2_", __a, __b, __c__, __d__, __rt1r, __rt1i, __rt2r, __rt2i, __cs, __sn);
            }
            return (int)mh$.invokeExact(__a, __b, __c__, __d__, __rt1r, __rt1i, __rt2r, __rt2i, __cs, __sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapll_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slapll_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slapll_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static FunctionDescriptor slapll_$descriptor() {
        return slapll_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slapll_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static MethodHandle slapll_$handle() {
        return slapll_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slapll_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static MemorySegment slapll_$address() {
        return slapll_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slapll_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__ssmin)
     * }
     */
    public static int slapll_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __ssmin) {
        var mh$ = slapll_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapll_", __n, __x, __incx, __y, __incy, __ssmin);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __ssmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static FunctionDescriptor slapmt_$descriptor() {
        return slapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MethodHandle slapmt_$handle() {
        return slapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static MemorySegment slapmt_$address() {
        return slapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_integer *__k)
     * }
     */
    public static int slapmt_(MemorySegment __forwrd, MemorySegment __m, MemorySegment __n, MemorySegment __x, MemorySegment __ldx, MemorySegment __k) {
        var mh$ = slapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapmt_", __forwrd, __m, __n, __x, __ldx, __k);
            }
            return (int)mh$.invokeExact(__forwrd, __m, __n, __x, __ldx, __k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slapy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slapy2_(__CLPK_real *__x, __CLPK_real *__y)
     * }
     */
    public static FunctionDescriptor slapy2_$descriptor() {
        return slapy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slapy2_(__CLPK_real *__x, __CLPK_real *__y)
     * }
     */
    public static MethodHandle slapy2_$handle() {
        return slapy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slapy2_(__CLPK_real *__x, __CLPK_real *__y)
     * }
     */
    public static MemorySegment slapy2_$address() {
        return slapy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slapy2_(__CLPK_real *__x, __CLPK_real *__y)
     * }
     */
    public static double slapy2_(MemorySegment __x, MemorySegment __y) {
        var mh$ = slapy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapy2_", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapy3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_DOUBLE,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slapy3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __CLPK_doublereal slapy3_(__CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__)
     * }
     */
    public static FunctionDescriptor slapy3_$descriptor() {
        return slapy3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __CLPK_doublereal slapy3_(__CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__)
     * }
     */
    public static MethodHandle slapy3_$handle() {
        return slapy3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __CLPK_doublereal slapy3_(__CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__)
     * }
     */
    public static MemorySegment slapy3_$address() {
        return slapy3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __CLPK_doublereal slapy3_(__CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__)
     * }
     */
    public static double slapy3_(MemorySegment __x, MemorySegment __y, MemorySegment __z__) {
        var mh$ = slapy3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapy3_", __x, __y, __z__);
            }
            return (double)mh$.invokeExact(__x, __y, __z__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqgb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqgb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor slaqgb_$descriptor() {
        return slaqgb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle slaqgb_$handle() {
        return slaqgb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment slaqgb_$address() {
        return slaqgb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int slaqgb_(MemorySegment __m, MemorySegment __n, MemorySegment __kl, MemorySegment __ku, MemorySegment __ab, MemorySegment __ldab, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = slaqgb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqgb_", __m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __kl, __ku, __ab, __ldab, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor slaqge_$descriptor() {
        return slaqge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle slaqge_$handle() {
        return slaqge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment slaqge_$address() {
        return slaqge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int slaqge_(MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __r__, MemorySegment __c__, MemorySegment __rowcnd, MemorySegment __colcnd, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = slaqge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqge_", __m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
            }
            return (int)mh$.invokeExact(__m, __n, __a, __lda, __r__, __c__, __rowcnd, __colcnd, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slaqp2_$descriptor() {
        return slaqp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slaqp2_$handle() {
        return slaqp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slaqp2_$address() {
        return slaqp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__work)
     * }
     */
    public static int slaqp2_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __work) {
        var mh$ = slaqp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqp2_", __m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __a, __lda, __jpvt, __tau, __vn1, __vn2, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__auxv, __CLPK_real *__f, __CLPK_integer *__ldf)
     * }
     */
    public static FunctionDescriptor slaqps_$descriptor() {
        return slaqps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__auxv, __CLPK_real *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MethodHandle slaqps_$handle() {
        return slaqps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__auxv, __CLPK_real *__f, __CLPK_integer *__ldf)
     * }
     */
    public static MemorySegment slaqps_$address() {
        return slaqps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__auxv, __CLPK_real *__f, __CLPK_integer *__ldf)
     * }
     */
    public static int slaqps_(MemorySegment __m, MemorySegment __n, MemorySegment __offset, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __jpvt, MemorySegment __tau, MemorySegment __vn1, MemorySegment __vn2, MemorySegment __auxv, MemorySegment __f, MemorySegment __ldf) {
        var mh$ = slaqps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqps_", __m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
            }
            return (int)mh$.invokeExact(__m, __n, __offset, __nb, __kb, __a, __lda, __jpvt, __tau, __vn1, __vn2, __auxv, __f, __ldf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqr0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqr0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaqr0_$descriptor() {
        return slaqr0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaqr0_$handle() {
        return slaqr0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaqr0_$address() {
        return slaqr0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int slaqr0_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = slaqr0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqr0_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqr1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqr1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqr1_(__CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__sr1, __CLPK_real *__si1, __CLPK_real *__sr2, __CLPK_real *__si2, __CLPK_real *__v)
     * }
     */
    public static FunctionDescriptor slaqr1_$descriptor() {
        return slaqr1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqr1_(__CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__sr1, __CLPK_real *__si1, __CLPK_real *__sr2, __CLPK_real *__si2, __CLPK_real *__v)
     * }
     */
    public static MethodHandle slaqr1_$handle() {
        return slaqr1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqr1_(__CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__sr1, __CLPK_real *__si1, __CLPK_real *__sr2, __CLPK_real *__si2, __CLPK_real *__v)
     * }
     */
    public static MemorySegment slaqr1_$address() {
        return slaqr1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqr1_(__CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__sr1, __CLPK_real *__si1, __CLPK_real *__sr2, __CLPK_real *__si2, __CLPK_real *__v)
     * }
     */
    public static int slaqr1_(MemorySegment __n, MemorySegment __h__, MemorySegment __ldh, MemorySegment __sr1, MemorySegment __si1, MemorySegment __sr2, MemorySegment __si2, MemorySegment __v) {
        var mh$ = slaqr1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqr1_", __n, __h__, __ldh, __sr1, __si1, __sr2, __si2, __v);
            }
            return (int)mh$.invokeExact(__n, __h__, __ldh, __sr1, __si1, __sr2, __si2, __v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor slaqr2_$descriptor() {
        return slaqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle slaqr2_$handle() {
        return slaqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment slaqr2_$address() {
        return slaqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int slaqr2_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sr, MemorySegment __si, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = slaqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqr2_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static FunctionDescriptor slaqr3_$descriptor() {
        return slaqr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MethodHandle slaqr3_$handle() {
        return slaqr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static MemorySegment slaqr3_$address() {
        return slaqr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_real *__work, __CLPK_integer *__lwork)
     * }
     */
    public static int slaqr3_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nw, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __ns, MemorySegment __nd, MemorySegment __sr, MemorySegment __si, MemorySegment __v, MemorySegment __ldv, MemorySegment __nh, MemorySegment __t, MemorySegment __ldt, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __work, MemorySegment __lwork) {
        var mh$ = slaqr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqr3_", __wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ktop, __kbot, __nw, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __ns, __nd, __sr, __si, __v, __ldv, __nh, __t, __ldt, __nv, __wv, __ldwv, __work, __lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqr4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqr4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaqr4_$descriptor() {
        return slaqr4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaqr4_$handle() {
        return slaqr4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaqr4_$address() {
        return slaqr4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int slaqr4_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __h__, MemorySegment __ldh, MemorySegment __wr, MemorySegment __wi, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = slaqr4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqr4_", __wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __n, __ilo, __ihi, __h__, __ldh, __wr, __wi, __iloz, __ihiz, __z__, __ldz, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqr5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqr5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_real *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static FunctionDescriptor slaqr5_$descriptor() {
        return slaqr5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_real *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MethodHandle slaqr5_$handle() {
        return slaqr5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_real *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static MemorySegment slaqr5_$address() {
        return slaqr5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz, __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_real *__wh, __CLPK_integer *__ldwh)
     * }
     */
    public static int slaqr5_(MemorySegment __wantt, MemorySegment __wantz, MemorySegment __kacc22, MemorySegment __n, MemorySegment __ktop, MemorySegment __kbot, MemorySegment __nshfts, MemorySegment __sr, MemorySegment __si, MemorySegment __h__, MemorySegment __ldh, MemorySegment __iloz, MemorySegment __ihiz, MemorySegment __z__, MemorySegment __ldz, MemorySegment __v, MemorySegment __ldv, MemorySegment __u, MemorySegment __ldu, MemorySegment __nv, MemorySegment __wv, MemorySegment __ldwv, MemorySegment __nh, MemorySegment __wh, MemorySegment __ldwh) {
        var mh$ = slaqr5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqr5_", __wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __sr, __si, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
            }
            return (int)mh$.invokeExact(__wantt, __wantz, __kacc22, __n, __ktop, __kbot, __nshfts, __sr, __si, __h__, __ldh, __iloz, __ihiz, __z__, __ldz, __v, __ldv, __u, __ldu, __nv, __wv, __ldwv, __nh, __wh, __ldwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqsb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqsb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor slaqsb_$descriptor() {
        return slaqsb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle slaqsb_$handle() {
        return slaqsb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment slaqsb_$address() {
        return slaqsb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int slaqsb_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = slaqsb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqsb_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqsp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqsp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor slaqsp_$descriptor() {
        return slaqsp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle slaqsp_$handle() {
        return slaqsp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment slaqsp_$address() {
        return slaqsp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int slaqsp_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = slaqsp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqsp_", __uplo, __n, __ap, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static FunctionDescriptor slaqsy_$descriptor() {
        return slaqsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MethodHandle slaqsy_$handle() {
        return slaqsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static MemorySegment slaqsy_$address() {
        return slaqsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, char *__equed)
     * }
     */
    public static int slaqsy_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __equed) {
        var mh$ = slaqsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqsy_", __uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __s, __scond, __amax, __equed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaqtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaqtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__b, __CLPK_real *__w, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slaqtr_$descriptor() {
        return slaqtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__b, __CLPK_real *__w, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slaqtr_$handle() {
        return slaqtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__b, __CLPK_real *__w, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slaqtr_$address() {
        return slaqtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real, __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__b, __CLPK_real *__w, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slaqtr_(MemorySegment __ltran, MemorySegment __l__CLPK_real, MemorySegment __n, MemorySegment __t, MemorySegment __ldt, MemorySegment __b, MemorySegment __w, MemorySegment __scale, MemorySegment __x, MemorySegment __work, MemorySegment __info) {
        var mh$ = slaqtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaqtr_", __ltran, __l__CLPK_real, __n, __t, __ldt, __b, __w, __scale, __x, __work, __info);
            }
            return (int)mh$.invokeExact(__ltran, __l__CLPK_real, __n, __t, __ldt, __b, __w, __scale, __x, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slar1v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slar1v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_real *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slar1v_$descriptor() {
        return slar1v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_real *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slar1v_$handle() {
        return slar1v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_real *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slar1v_$address() {
        return slar1v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn, __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin, __CLPK_real *__gaptol, __CLPK_real *__z__, __CLPK_logical *__wantnc, __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma, __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv, __CLPK_real *__resid, __CLPK_real *__rqcorr, __CLPK_real *__work)
     * }
     */
    public static int slar1v_(MemorySegment __n, MemorySegment __b1, MemorySegment __bn, MemorySegment __lambda, MemorySegment __d__, MemorySegment __l, MemorySegment __ld, MemorySegment __lld, MemorySegment __pivmin, MemorySegment __gaptol, MemorySegment __z__, MemorySegment __wantnc, MemorySegment __negcnt, MemorySegment __ztz, MemorySegment __mingma, MemorySegment __r__, MemorySegment __isuppz, MemorySegment __nrminv, MemorySegment __resid, MemorySegment __rqcorr, MemorySegment __work) {
        var mh$ = slar1v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slar1v_", __n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
            }
            return (int)mh$.invokeExact(__n, __b1, __bn, __lambda, __d__, __l, __ld, __lld, __pivmin, __gaptol, __z__, __wantnc, __negcnt, __ztz, __mingma, __r__, __isuppz, __nrminv, __resid, __rqcorr, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slar2v_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slar2v_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slar2v_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor slar2v_$descriptor() {
        return slar2v_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slar2v_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle slar2v_$handle() {
        return slar2v_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slar2v_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment slar2v_$address() {
        return slar2v_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slar2v_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_real *__y, __CLPK_real *__z__, __CLPK_integer *__incx, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static int slar2v_(MemorySegment __n, MemorySegment __x, MemorySegment __y, MemorySegment __z__, MemorySegment __incx, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = slar2v_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slar2v_", __n, __x, __y, __z__, __incx, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __y, __z__, __incx, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slarf_$descriptor() {
        return slarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slarf_$handle() {
        return slarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slarf_$address() {
        return slarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static int slarf_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = slarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarf_", __side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor slarfb_$descriptor() {
        return slarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle slarfb_$handle() {
        return slarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment slarfb_$address() {
        return slarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarfb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int slarfb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = slarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfb_", __side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarfg_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static FunctionDescriptor slarfg_$descriptor() {
        return slarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarfg_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static MethodHandle slarfg_$handle() {
        return slarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarfg_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static MemorySegment slarfg_$address() {
        return slarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarfg_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static int slarfg_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = slarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfg_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarfp_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static FunctionDescriptor slarfp_$descriptor() {
        return slarfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarfp_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static MethodHandle slarfp_$handle() {
        return slarfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarfp_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static MemorySegment slarfp_$address() {
        return slarfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarfp_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__tau)
     * }
     */
    public static int slarfp_(MemorySegment __n, MemorySegment __alpha, MemorySegment __x, MemorySegment __incx, MemorySegment __tau) {
        var mh$ = slarfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfp_", __n, __alpha, __x, __incx, __tau);
            }
            return (int)mh$.invokeExact(__n, __alpha, __x, __incx, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor slarft_$descriptor() {
        return slarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle slarft_$handle() {
        return slarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment slarft_$address() {
        return slarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarft_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int slarft_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = slarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarft_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slarfx_$descriptor() {
        return slarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slarfx_$handle() {
        return slarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slarfx_$address() {
        return slarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static int slarfx_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = slarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfx_", __side, __m, __n, __v, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slargv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slargv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slargv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor slargv_$descriptor() {
        return slargv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slargv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle slargv_$handle() {
        return slargv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slargv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment slargv_$address() {
        return slargv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slargv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_integer *__incc)
     * }
     */
    public static int slargv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __incc) {
        var mh$ = slargv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slargv_", __n, __x, __incx, __y, __incy, __c__, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static FunctionDescriptor slarnv_$descriptor() {
        return slarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static MethodHandle slarnv_$handle() {
        return slarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static MemorySegment slarnv_$address() {
        return slarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static int slarnv_(MemorySegment __idist, MemorySegment __iseed, MemorySegment __n, MemorySegment __x) {
        var mh$ = slarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarnv_", __idist, __iseed, __n, __x);
            }
            return (int)mh$.invokeExact(__idist, __iseed, __n, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarra_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarra_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarra_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__spltol, __CLPK_real *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarra_$descriptor() {
        return slarra_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarra_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__spltol, __CLPK_real *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarra_$handle() {
        return slarra_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarra_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__spltol, __CLPK_real *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarra_$address() {
        return slarra_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarra_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__spltol, __CLPK_real *__tnrm, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__info)
     * }
     */
    public static int slarra_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __spltol, MemorySegment __tnrm, MemorySegment __nsplit, MemorySegment __isplit, MemorySegment __info) {
        var mh$ = slarra_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarra_", __n, __d__, __e, __e2, __spltol, __tnrm, __nsplit, __isplit, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __e2, __spltol, __tnrm, __nsplit, __isplit, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrb_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrb_$descriptor() {
        return slarrb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrb_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrb_$handle() {
        return slarrb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrb_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrb_$address() {
        return slarrb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrb_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__twist, __CLPK_integer *__info)
     * }
     */
    public static int slarrb_(MemorySegment __n, MemorySegment __d__, MemorySegment __lld, MemorySegment __ifirst, MemorySegment __ilast, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __offset, MemorySegment __w, MemorySegment __wgap, MemorySegment __werr, MemorySegment __work, MemorySegment __iwork, MemorySegment __pivmin, MemorySegment __spdiam, MemorySegment __twist, MemorySegment __info) {
        var mh$ = slarrb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrb_", __n, __d__, __lld, __ifirst, __ilast, __rtol1, __rtol2, __offset, __w, __wgap, __werr, __work, __iwork, __pivmin, __spdiam, __twist, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __lld, __ifirst, __ilast, __rtol1, __rtol2, __offset, __w, __wgap, __werr, __work, __iwork, __pivmin, __spdiam, __twist, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrc_$descriptor() {
        return slarrc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrc_$handle() {
        return slarrc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrc_$address() {
        return slarrc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt, __CLPK_integer *__rcnt, __CLPK_integer *__info)
     * }
     */
    public static int slarrc_(MemorySegment __jobt, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __d__, MemorySegment __e, MemorySegment __pivmin, MemorySegment __eigcnt, MemorySegment __lcnt, MemorySegment __rcnt, MemorySegment __info) {
        var mh$ = slarrc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrc_", __jobt, __n, __vl, __vu, __d__, __e, __pivmin, __eigcnt, __lcnt, __rcnt, __info);
            }
            return (int)mh$.invokeExact(__jobt, __n, __vl, __vu, __d__, __e, __pivmin, __eigcnt, __lcnt, __rcnt, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__gers, __CLPK_real *__reltol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wl, __CLPK_real *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrd_$descriptor() {
        return slarrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__gers, __CLPK_real *__reltol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wl, __CLPK_real *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrd_$handle() {
        return slarrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__gers, __CLPK_real *__reltol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wl, __CLPK_real *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrd_$address() {
        return slarrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrd_(char *__range, char *__order, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__gers, __CLPK_real *__reltol, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wl, __CLPK_real *__wu, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slarrd_(MemorySegment __range, MemorySegment __order, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __gers, MemorySegment __reltol, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __pivmin, MemorySegment __nsplit, MemorySegment __isplit, MemorySegment __m, MemorySegment __w, MemorySegment __werr, MemorySegment __wl, MemorySegment __wu, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slarrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrd_", __range, __order, __n, __vl, __vu, __il, __iu, __gers, __reltol, __d__, __e, __e2, __pivmin, __nsplit, __isplit, __m, __w, __werr, __wl, __wu, __iblock, __indexw, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__range, __order, __n, __vl, __vu, __il, __iu, __gers, __reltol, __d__, __e, __e2, __pivmin, __nsplit, __isplit, __m, __w, __werr, __wl, __wu, __iblock, __indexw, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarre_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarre_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarre_(char *__range, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__pivmin, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarre_$descriptor() {
        return slarre_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarre_(char *__range, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__pivmin, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarre_$handle() {
        return slarre_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarre_(char *__range, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__pivmin, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarre_$address() {
        return slarre_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarre_(char *__range, __CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__spltol, __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__pivmin, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slarre_(MemorySegment __range, MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __il, MemorySegment __iu, MemorySegment __d__, MemorySegment __e, MemorySegment __e2, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __spltol, MemorySegment __nsplit, MemorySegment __isplit, MemorySegment __m, MemorySegment __w, MemorySegment __werr, MemorySegment __wgap, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __gers, MemorySegment __pivmin, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slarre_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarre_", __range, __n, __vl, __vu, __il, __iu, __d__, __e, __e2, __rtol1, __rtol2, __spltol, __nsplit, __isplit, __m, __w, __werr, __wgap, __iblock, __indexw, __gers, __pivmin, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__range, __n, __vl, __vu, __il, __iu, __d__, __e, __e2, __rtol1, __rtol2, __spltol, __nsplit, __isplit, __m, __w, __werr, __wgap, __iblock, __indexw, __gers, __pivmin, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__spdiam, __CLPK_real *__clgapl, __CLPK_real *__clgapr, __CLPK_real *__pivmin, __CLPK_real *__sigma, __CLPK_real *__dplus, __CLPK_real *__lplus, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrf_$descriptor() {
        return slarrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__spdiam, __CLPK_real *__clgapl, __CLPK_real *__clgapr, __CLPK_real *__pivmin, __CLPK_real *__sigma, __CLPK_real *__dplus, __CLPK_real *__lplus, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrf_$handle() {
        return slarrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__spdiam, __CLPK_real *__clgapl, __CLPK_real *__clgapr, __CLPK_real *__pivmin, __CLPK_real *__sigma, __CLPK_real *__dplus, __CLPK_real *__lplus, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrf_$address() {
        return slarrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend, __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__spdiam, __CLPK_real *__clgapl, __CLPK_real *__clgapr, __CLPK_real *__pivmin, __CLPK_real *__sigma, __CLPK_real *__dplus, __CLPK_real *__lplus, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slarrf_(MemorySegment __n, MemorySegment __d__, MemorySegment __l, MemorySegment __ld, MemorySegment __clstrt, MemorySegment __clend, MemorySegment __w, MemorySegment __wgap, MemorySegment __werr, MemorySegment __spdiam, MemorySegment __clgapl, MemorySegment __clgapr, MemorySegment __pivmin, MemorySegment __sigma, MemorySegment __dplus, MemorySegment __lplus, MemorySegment __work, MemorySegment __info) {
        var mh$ = slarrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrf_", __n, __d__, __l, __ld, __clstrt, __clend, __w, __wgap, __werr, __spdiam, __clgapl, __clgapr, __pivmin, __sigma, __dplus, __lplus, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __l, __ld, __clstrt, __clend, __w, __wgap, __werr, __spdiam, __clgapl, __clgapr, __pivmin, __sigma, __dplus, __lplus, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrj_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrj_$descriptor() {
        return slarrj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrj_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrj_$handle() {
        return slarrj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrj_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrj_$address() {
        return slarrj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrj_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol, __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam, __CLPK_integer *__info)
     * }
     */
    public static int slarrj_(MemorySegment __n, MemorySegment __d__, MemorySegment __e2, MemorySegment __ifirst, MemorySegment __ilast, MemorySegment __rtol, MemorySegment __offset, MemorySegment __w, MemorySegment __werr, MemorySegment __work, MemorySegment __iwork, MemorySegment __pivmin, MemorySegment __spdiam, MemorySegment __info) {
        var mh$ = slarrj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrj_", __n, __d__, __e2, __ifirst, __ilast, __rtol, __offset, __w, __werr, __work, __iwork, __pivmin, __spdiam, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e2, __ifirst, __ilast, __rtol, __offset, __w, __werr, __work, __iwork, __pivmin, __spdiam, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_real *__gl, __CLPK_real *__gu, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_real *__reltol, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrk_$descriptor() {
        return slarrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_real *__gl, __CLPK_real *__gu, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_real *__reltol, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrk_$handle() {
        return slarrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_real *__gl, __CLPK_real *__gu, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_real *__reltol, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrk_$address() {
        return slarrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_real *__gl, __CLPK_real *__gu, __CLPK_real *__d__, __CLPK_real *__e2, __CLPK_real *__pivmin, __CLPK_real *__reltol, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_integer *__info)
     * }
     */
    public static int slarrk_(MemorySegment __n, MemorySegment __iw, MemorySegment __gl, MemorySegment __gu, MemorySegment __d__, MemorySegment __e2, MemorySegment __pivmin, MemorySegment __reltol, MemorySegment __w, MemorySegment __werr, MemorySegment __info) {
        var mh$ = slarrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrk_", __n, __iw, __gl, __gu, __d__, __e2, __pivmin, __reltol, __w, __werr, __info);
            }
            return (int)mh$.invokeExact(__n, __iw, __gl, __gu, __d__, __e2, __pivmin, __reltol, __w, __werr, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrr_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrr_$descriptor() {
        return slarrr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrr_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrr_$handle() {
        return slarrr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrr_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrr_$address() {
        return slarrr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrr_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_integer *__info)
     * }
     */
    public static int slarrr_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __info) {
        var mh$ = slarrr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrr_", __n, __d__, __e, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarrv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarrv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slarrv_$descriptor() {
        return slarrv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slarrv_$handle() {
        return slarrv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slarrv_$address() {
        return slarrv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin, __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol, __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slarrv_(MemorySegment __n, MemorySegment __vl, MemorySegment __vu, MemorySegment __d__, MemorySegment __l, MemorySegment __pivmin, MemorySegment __isplit, MemorySegment __m, MemorySegment __dol, MemorySegment __dou, MemorySegment __minrgp, MemorySegment __rtol1, MemorySegment __rtol2, MemorySegment __w, MemorySegment __werr, MemorySegment __wgap, MemorySegment __iblock, MemorySegment __indexw, MemorySegment __gers, MemorySegment __z__, MemorySegment __ldz, MemorySegment __isuppz, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slarrv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarrv_", __n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__n, __vl, __vu, __d__, __l, __pivmin, __isplit, __m, __dol, __dou, __minrgp, __rtol1, __rtol2, __w, __werr, __wgap, __iblock, __indexw, __gers, __z__, __ldz, __isuppz, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarscl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarscl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor slarscl2_$descriptor() {
        return slarscl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle slarscl2_$handle() {
        return slarscl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment slarscl2_$address() {
        return slarscl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int slarscl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = slarscl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarscl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slartg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slartg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slartg_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__cs, __CLPK_real *__sn, __CLPK_real *__r__)
     * }
     */
    public static FunctionDescriptor slartg_$descriptor() {
        return slartg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slartg_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__cs, __CLPK_real *__sn, __CLPK_real *__r__)
     * }
     */
    public static MethodHandle slartg_$handle() {
        return slartg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slartg_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__cs, __CLPK_real *__sn, __CLPK_real *__r__)
     * }
     */
    public static MemorySegment slartg_$address() {
        return slartg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slartg_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__cs, __CLPK_real *__sn, __CLPK_real *__r__)
     * }
     */
    public static int slartg_(MemorySegment __f, MemorySegment __g, MemorySegment __cs, MemorySegment __sn, MemorySegment __r__) {
        var mh$ = slartg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slartg_", __f, __g, __cs, __sn, __r__);
            }
            return (int)mh$.invokeExact(__f, __g, __cs, __sn, __r__);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slartv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slartv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slartv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static FunctionDescriptor slartv_$descriptor() {
        return slartv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slartv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static MethodHandle slartv_$handle() {
        return slartv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slartv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static MemorySegment slartv_$address() {
        return slartv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slartv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__incc)
     * }
     */
    public static int slartv_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __y, MemorySegment __incy, MemorySegment __c__, MemorySegment __s, MemorySegment __incc) {
        var mh$ = slartv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slartv_", __n, __x, __incx, __y, __incy, __c__, __s, __incc);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __y, __incy, __c__, __s, __incc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaruv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaruv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static FunctionDescriptor slaruv_$descriptor() {
        return slaruv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static MethodHandle slaruv_$handle() {
        return slaruv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static MemorySegment slaruv_$address() {
        return slaruv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n, __CLPK_real *__x)
     * }
     */
    public static int slaruv_(MemorySegment __iseed, MemorySegment __n, MemorySegment __x) {
        var mh$ = slaruv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaruv_", __iseed, __n, __x);
            }
            return (int)mh$.invokeExact(__iseed, __n, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slarz_$descriptor() {
        return slarz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slarz_$handle() {
        return slarz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slarz_$address() {
        return slarz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static int slarz_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = slarz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarz_", __side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __l, __v, __incv, __tau, __c__, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarzb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarzb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static FunctionDescriptor slarzb_$descriptor() {
        return slarzb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MethodHandle slarzb_$handle() {
        return slarzb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static MemorySegment slarzb_$address() {
        return slarzb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarzb_(char *__side, char *__trans, char *__direct, char *__storev, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__ldwork)
     * }
     */
    public static int slarzb_(MemorySegment __side, MemorySegment __trans, MemorySegment __direct, MemorySegment __storev, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __v, MemorySegment __ldv, MemorySegment __t, MemorySegment __ldt, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __ldwork) {
        var mh$ = slarzb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarzb_", __side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
            }
            return (int)mh$.invokeExact(__side, __trans, __direct, __storev, __m, __n, __k, __l, __v, __ldv, __t, __ldt, __c__, __ldc, __work, __ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarzt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slarzt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static FunctionDescriptor slarzt_$descriptor() {
        return slarzt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MethodHandle slarzt_$handle() {
        return slarzt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static MemorySegment slarzt_$address() {
        return slarzt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slarzt_(char *__direct, char *__storev, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__tau, __CLPK_real *__t, __CLPK_integer *__ldt)
     * }
     */
    public static int slarzt_(MemorySegment __direct, MemorySegment __storev, MemorySegment __n, MemorySegment __k, MemorySegment __v, MemorySegment __ldv, MemorySegment __tau, MemorySegment __t, MemorySegment __ldt) {
        var mh$ = slarzt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarzt_", __direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
            }
            return (int)mh$.invokeExact(__direct, __storev, __n, __k, __v, __ldv, __tau, __t, __ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slas2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slas2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slas2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax)
     * }
     */
    public static FunctionDescriptor slas2_$descriptor() {
        return slas2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slas2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax)
     * }
     */
    public static MethodHandle slas2_$handle() {
        return slas2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slas2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax)
     * }
     */
    public static MemorySegment slas2_$address() {
        return slas2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slas2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax)
     * }
     */
    public static int slas2_(MemorySegment __f, MemorySegment __g, MemorySegment __h__, MemorySegment __ssmin, MemorySegment __ssmax) {
        var mh$ = slas2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slas2_", __f, __g, __h__, __ssmin, __ssmax);
            }
            return (int)mh$.invokeExact(__f, __g, __h__, __ssmin, __ssmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slascl_$descriptor() {
        return slascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slascl_$handle() {
        return slascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slascl_$address() {
        return slascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int slascl_(MemorySegment __type__, MemorySegment __kl, MemorySegment __ku, MemorySegment __cfrom, MemorySegment __cto, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = slascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slascl_", __type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__type__, __kl, __ku, __cfrom, __cto, __m, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slascl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slascl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static FunctionDescriptor slascl2_$descriptor() {
        return slascl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MethodHandle slascl2_$handle() {
        return slascl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static MemorySegment slascl2_$address() {
        return slascl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__x, __CLPK_integer *__ldx)
     * }
     */
    public static int slascl2_(MemorySegment __m, MemorySegment __n, MemorySegment __d__, MemorySegment __x, MemorySegment __ldx) {
        var mh$ = slascl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slascl2_", __m, __n, __d__, __x, __ldx);
            }
            return (int)mh$.invokeExact(__m, __n, __d__, __x, __ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd0_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd0_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd0_$descriptor() {
        return slasd0_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd0_$handle() {
        return slasd0_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd0_$address() {
        return slasd0_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slasd0_(MemorySegment __n, MemorySegment __sqre, MemorySegment __d__, MemorySegment __e, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __smlsiz, MemorySegment __iwork, MemorySegment __work, MemorySegment __info) {
        var mh$ = slasd0_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd0_", __n, __sqre, __d__, __e, __u, __ldu, __vt, __ldvt, __smlsiz, __iwork, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __sqre, __d__, __e, __u, __ldu, __vt, __ldvt, __smlsiz, __iwork, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd1_$descriptor() {
        return slasd1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd1_$handle() {
        return slasd1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd1_$address() {
        return slasd1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slasd1_(MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __d__, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __idxq, MemorySegment __iwork, MemorySegment __work, MemorySegment __info) {
        var mh$ = slasd1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd1_", __nl, __nr, __sqre, __d__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __idxq, __iwork, __work, __info);
            }
            return (int)mh$.invokeExact(__nl, __nr, __sqre, __d__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __idxq, __iwork, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__dsigma, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd2_$descriptor() {
        return slasd2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__dsigma, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd2_$handle() {
        return slasd2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__dsigma, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd2_$address() {
        return slasd2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__dsigma, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq, __CLPK_integer *__coltyp, __CLPK_integer *__info)
     * }
     */
    public static int slasd2_(MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __k, MemorySegment __d__, MemorySegment __z__, MemorySegment __alpha, MemorySegment __beta, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __dsigma, MemorySegment __u2, MemorySegment __ldu2, MemorySegment __vt2, MemorySegment __ldvt2, MemorySegment __idxp, MemorySegment __idx, MemorySegment __idxc, MemorySegment __idxq, MemorySegment __coltyp, MemorySegment __info) {
        var mh$ = slasd2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd2_", __nl, __nr, __sqre, __k, __d__, __z__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __dsigma, __u2, __ldu2, __vt2, __ldvt2, __idxp, __idx, __idxc, __idxq, __coltyp, __info);
            }
            return (int)mh$.invokeExact(__nl, __nr, __sqre, __k, __d__, __z__, __alpha, __beta, __u, __ldu, __vt, __ldvt, __dsigma, __u2, __ldu2, __vt2, __ldvt2, __idxp, __idx, __idxc, __idxq, __coltyp, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__dsigma, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd3_$descriptor() {
        return slasd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__dsigma, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd3_$handle() {
        return slasd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__dsigma, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd3_$address() {
        return slasd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__dsigma, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__u2, __CLPK_integer *__ldu2, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static int slasd3_(MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __k, MemorySegment __d__, MemorySegment __q, MemorySegment __ldq, MemorySegment __dsigma, MemorySegment __u, MemorySegment __ldu, MemorySegment __u2, MemorySegment __ldu2, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __vt2, MemorySegment __ldvt2, MemorySegment __idxc, MemorySegment __ctot, MemorySegment __z__, MemorySegment __info) {
        var mh$ = slasd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd3_", __nl, __nr, __sqre, __k, __d__, __q, __ldq, __dsigma, __u, __ldu, __u2, __ldu2, __vt, __ldvt, __vt2, __ldvt2, __idxc, __ctot, __z__, __info);
            }
            return (int)mh$.invokeExact(__nl, __nr, __sqre, __k, __d__, __q, __ldq, __dsigma, __u, __ldu, __u2, __ldu2, __vt, __ldvt, __vt2, __ldvt2, __idxc, __ctot, __z__, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__sigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd4_$descriptor() {
        return slasd4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__sigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd4_$handle() {
        return slasd4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__sigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd4_$address() {
        return slasd4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__sigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slasd4_(MemorySegment __n, MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __sigma, MemorySegment __work, MemorySegment __info) {
        var mh$ = slasd4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd4_", __n, __i__, __d__, __z__, __delta, __rho, __sigma, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __i__, __d__, __z__, __delta, __rho, __sigma, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dsigma, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slasd5_$descriptor() {
        return slasd5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dsigma, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slasd5_$handle() {
        return slasd5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dsigma, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slasd5_$address() {
        return slasd5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dsigma, __CLPK_real *__work)
     * }
     */
    public static int slasd5_(MemorySegment __i__, MemorySegment __d__, MemorySegment __z__, MemorySegment __delta, MemorySegment __rho, MemorySegment __dsigma, MemorySegment __work) {
        var mh$ = slasd5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd5_", __i__, __d__, __z__, __delta, __rho, __dsigma, __work);
            }
            return (int)mh$.invokeExact(__i__, __d__, __z__, __delta, __rho, __dsigma, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd6_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd6_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd6_$descriptor() {
        return slasd6_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd6_$handle() {
        return slasd6_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd6_$address() {
        return slasd6_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slasd6_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __d__, MemorySegment __vf, MemorySegment __vl, MemorySegment __alpha, MemorySegment __beta, MemorySegment __idxq, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __poles, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __k, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slasd6_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd6_", __icompq, __nl, __nr, __sqre, __d__, __vf, __vl, __alpha, __beta, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __d__, __vf, __vl, __alpha, __beta, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __poles, __difl, __difr, __z__, __k, __c__, __s, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd7_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd7_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__zw, __CLPK_real *__vf, __CLPK_real *__vfw, __CLPK_real *__vl, __CLPK_real *__vlw, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd7_$descriptor() {
        return slasd7_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__zw, __CLPK_real *__vf, __CLPK_real *__vfw, __CLPK_real *__vl, __CLPK_real *__vlw, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd7_$handle() {
        return slasd7_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__zw, __CLPK_real *__vf, __CLPK_real *__vfw, __CLPK_real *__vl, __CLPK_real *__vlw, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd7_$address() {
        return slasd7_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__zw, __CLPK_real *__vf, __CLPK_real *__vfw, __CLPK_real *__vl, __CLPK_real *__vlw, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq, __CLPK_integer *__perm, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_real *__givnum, __CLPK_integer *__ldgnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_integer *__info)
     * }
     */
    public static int slasd7_(MemorySegment __icompq, MemorySegment __nl, MemorySegment __nr, MemorySegment __sqre, MemorySegment __k, MemorySegment __d__, MemorySegment __z__, MemorySegment __zw, MemorySegment __vf, MemorySegment __vfw, MemorySegment __vl, MemorySegment __vlw, MemorySegment __alpha, MemorySegment __beta, MemorySegment __dsigma, MemorySegment __idx, MemorySegment __idxp, MemorySegment __idxq, MemorySegment __perm, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __givnum, MemorySegment __ldgnum, MemorySegment __c__, MemorySegment __s, MemorySegment __info) {
        var mh$ = slasd7_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd7_", __icompq, __nl, __nr, __sqre, __k, __d__, __z__, __zw, __vf, __vfw, __vl, __vlw, __alpha, __beta, __dsigma, __idx, __idxp, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __c__, __s, __info);
            }
            return (int)mh$.invokeExact(__icompq, __nl, __nr, __sqre, __k, __d__, __z__, __zw, __vf, __vfw, __vl, __vlw, __alpha, __beta, __dsigma, __idx, __idxp, __idxq, __perm, __givptr, __givcol, __ldgcol, __givnum, __ldgnum, __c__, __s, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasd8_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasd8_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_integer *__lddifr, __CLPK_real *__dsigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasd8_$descriptor() {
        return slasd8_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_integer *__lddifr, __CLPK_real *__dsigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasd8_$handle() {
        return slasd8_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_integer *__lddifr, __CLPK_real *__dsigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasd8_$address() {
        return slasd8_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_integer *__lddifr, __CLPK_real *__dsigma, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slasd8_(MemorySegment __icompq, MemorySegment __k, MemorySegment __d__, MemorySegment __z__, MemorySegment __vf, MemorySegment __vl, MemorySegment __difl, MemorySegment __difr, MemorySegment __lddifr, MemorySegment __dsigma, MemorySegment __work, MemorySegment __info) {
        var mh$ = slasd8_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasd8_", __icompq, __k, __d__, __z__, __vf, __vl, __difl, __difr, __lddifr, __dsigma, __work, __info);
            }
            return (int)mh$.invokeExact(__icompq, __k, __d__, __z__, __vf, __vl, __difl, __difr, __lddifr, __dsigma, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasda_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasda_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasda_$descriptor() {
        return slasda_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasda_$handle() {
        return slasda_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasda_$address() {
        return slasda_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz, __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr, __CLPK_integer *__givcol, __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int slasda_(MemorySegment __icompq, MemorySegment __smlsiz, MemorySegment __n, MemorySegment __sqre, MemorySegment __d__, MemorySegment __e, MemorySegment __u, MemorySegment __ldu, MemorySegment __vt, MemorySegment __k, MemorySegment __difl, MemorySegment __difr, MemorySegment __z__, MemorySegment __poles, MemorySegment __givptr, MemorySegment __givcol, MemorySegment __ldgcol, MemorySegment __perm, MemorySegment __givnum, MemorySegment __c__, MemorySegment __s, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = slasda_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasda_", __icompq, __smlsiz, __n, __sqre, __d__, __e, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__icompq, __smlsiz, __n, __sqre, __d__, __e, __u, __ldu, __vt, __k, __difl, __difr, __z__, __poles, __givptr, __givcol, __ldgcol, __perm, __givnum, __c__, __s, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasdq_$descriptor() {
        return slasdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasdq_$handle() {
        return slasdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasdq_$address() {
        return slasdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n, __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slasdq_(MemorySegment __uplo, MemorySegment __sqre, MemorySegment __n, MemorySegment __ncvt, MemorySegment __nru, MemorySegment __ncc, MemorySegment __d__, MemorySegment __e, MemorySegment __vt, MemorySegment __ldvt, MemorySegment __u, MemorySegment __ldu, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = slasdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasdq_", __uplo, __sqre, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __sqre, __n, __ncvt, __nru, __ncc, __d__, __e, __vt, __ldvt, __u, __ldu, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasdt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasdt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static FunctionDescriptor slasdt_$descriptor() {
        return slasdt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static MethodHandle slasdt_$handle() {
        return slasdt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static MemorySegment slasdt_$address() {
        return slasdt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd, __CLPK_integer *__inode, __CLPK_integer *__ndiml, __CLPK_integer *__ndimr, __CLPK_integer *__msub)
     * }
     */
    public static int slasdt_(MemorySegment __n, MemorySegment __lvl, MemorySegment __nd, MemorySegment __inode, MemorySegment __ndiml, MemorySegment __ndimr, MemorySegment __msub) {
        var mh$ = slasdt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasdt_", __n, __lvl, __nd, __inode, __ndiml, __ndimr, __msub);
            }
            return (int)mh$.invokeExact(__n, __lvl, __nd, __inode, __ndiml, __ndimr, __msub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor slaset_$descriptor() {
        return slaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle slaset_$handle() {
        return slaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment slaset_$address() {
        return slaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static int slaset_(MemorySegment __uplo, MemorySegment __m, MemorySegment __n, MemorySegment __alpha, MemorySegment __beta, MemorySegment __a, MemorySegment __lda) {
        var mh$ = slaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaset_", __uplo, __m, __n, __alpha, __beta, __a, __lda);
            }
            return (int)mh$.invokeExact(__uplo, __m, __n, __alpha, __beta, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasq1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasq1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasq1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasq1_$descriptor() {
        return slasq1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasq1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasq1_$handle() {
        return slasq1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasq1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasq1_$address() {
        return slasq1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasq1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int slasq1_(MemorySegment __n, MemorySegment __d__, MemorySegment __e, MemorySegment __work, MemorySegment __info) {
        var mh$ = slasq1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasq1_", __n, __d__, __e, __work, __info);
            }
            return (int)mh$.invokeExact(__n, __d__, __e, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasq2_(__CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasq2_$descriptor() {
        return slasq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasq2_(__CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasq2_$handle() {
        return slasq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasq2_(__CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasq2_$address() {
        return slasq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasq2_(__CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__info)
     * }
     */
    public static int slasq2_(MemorySegment __n, MemorySegment __z__, MemorySegment __info) {
        var mh$ = slasq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasq2_", __n, __z__, __info);
            }
            return (int)mh$.invokeExact(__n, __z__, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasq3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasq3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__sigma, __CLPK_real *__desig, __CLPK_real *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__g, __CLPK_real *__tau)
     * }
     */
    public static FunctionDescriptor slasq3_$descriptor() {
        return slasq3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__sigma, __CLPK_real *__desig, __CLPK_real *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__g, __CLPK_real *__tau)
     * }
     */
    public static MethodHandle slasq3_$handle() {
        return slasq3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__sigma, __CLPK_real *__desig, __CLPK_real *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__g, __CLPK_real *__tau)
     * }
     */
    public static MemorySegment slasq3_$address() {
        return slasq3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__sigma, __CLPK_real *__desig, __CLPK_real *__qmax, __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee, __CLPK_integer *__ttype, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__g, __CLPK_real *__tau)
     * }
     */
    public static int slasq3_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __dmin__, MemorySegment __sigma, MemorySegment __desig, MemorySegment __qmax, MemorySegment __nfail, MemorySegment __iter, MemorySegment __ndiv, MemorySegment __ieee, MemorySegment __ttype, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dn1, MemorySegment __dn2, MemorySegment __g, MemorySegment __tau) {
        var mh$ = slasq3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasq3_", __i0, __n0, __z__, __pp, __dmin__, __sigma, __desig, __qmax, __nfail, __iter, __ndiv, __ieee, __ttype, __dmin1, __dmin2, __dn, __dn1, __dn2, __g, __tau);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __dmin__, __sigma, __desig, __qmax, __nfail, __iter, __ndiv, __ieee, __ttype, __dmin1, __dmin2, __dn, __dn1, __dn2, __g, __tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasq4_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasq4_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__tau, __CLPK_integer *__ttype, __CLPK_real *__g)
     * }
     */
    public static FunctionDescriptor slasq4_$descriptor() {
        return slasq4_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__tau, __CLPK_integer *__ttype, __CLPK_real *__g)
     * }
     */
    public static MethodHandle slasq4_$handle() {
        return slasq4_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__tau, __CLPK_integer *__ttype, __CLPK_real *__g)
     * }
     */
    public static MemorySegment slasq4_$address() {
        return slasq4_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__tau, __CLPK_integer *__ttype, __CLPK_real *__g)
     * }
     */
    public static int slasq4_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __n0in, MemorySegment __dmin__, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dn1, MemorySegment __dn2, MemorySegment __tau, MemorySegment __ttype, MemorySegment __g) {
        var mh$ = slasq4_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasq4_", __i0, __n0, __z__, __pp, __n0in, __dmin__, __dmin1, __dmin2, __dn, __dn1, __dn2, __tau, __ttype, __g);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __n0in, __dmin__, __dmin1, __dmin2, __dn, __dn1, __dn2, __tau, __ttype, __g);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasq5_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasq5_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__tau, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static FunctionDescriptor slasq5_$descriptor() {
        return slasq5_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__tau, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static MethodHandle slasq5_$handle() {
        return slasq5_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__tau, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static MemorySegment slasq5_$address() {
        return slasq5_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__tau, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2, __CLPK_logical *__ieee)
     * }
     */
    public static int slasq5_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __tau, MemorySegment __dmin__, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dnm1, MemorySegment __dnm2, MemorySegment __ieee) {
        var mh$ = slasq5_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasq5_", __i0, __n0, __z__, __pp, __tau, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2, __ieee);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __tau, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2, __ieee);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasq6_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasq6_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2)
     * }
     */
    public static FunctionDescriptor slasq6_$descriptor() {
        return slasq6_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2)
     * }
     */
    public static MethodHandle slasq6_$handle() {
        return slasq6_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2)
     * }
     */
    public static MemorySegment slasq6_$address() {
        return slasq6_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__, __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1, __CLPK_real *__dnm2)
     * }
     */
    public static int slasq6_(MemorySegment __i0, MemorySegment __n0, MemorySegment __z__, MemorySegment __pp, MemorySegment __dmin__, MemorySegment __dmin1, MemorySegment __dmin2, MemorySegment __dn, MemorySegment __dnm1, MemorySegment __dnm2) {
        var mh$ = slasq6_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasq6_", __i0, __n0, __z__, __pp, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2);
            }
            return (int)mh$.invokeExact(__i0, __n0, __z__, __pp, __dmin__, __dmin1, __dmin2, __dn, __dnm1, __dnm2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static FunctionDescriptor slasr_$descriptor() {
        return slasr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MethodHandle slasr_$handle() {
        return slasr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static MemorySegment slasr_$address() {
        return slasr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__a, __CLPK_integer *__lda)
     * }
     */
    public static int slasr_(MemorySegment __side, MemorySegment __pivot, MemorySegment __direct, MemorySegment __m, MemorySegment __n, MemorySegment __c__, MemorySegment __s, MemorySegment __a, MemorySegment __lda) {
        var mh$ = slasr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasr_", __side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
            }
            return (int)mh$.invokeExact(__side, __pivot, __direct, __m, __n, __c__, __s, __a, __lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasrt_(char *__id, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasrt_$descriptor() {
        return slasrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasrt_(char *__id, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasrt_$handle() {
        return slasrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasrt_(char *__id, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasrt_$address() {
        return slasrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasrt_(char *__id, __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_integer *__info)
     * }
     */
    public static int slasrt_(MemorySegment __id, MemorySegment __n, MemorySegment __d__, MemorySegment __info) {
        var mh$ = slasrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasrt_", __id, __n, __d__, __info);
            }
            return (int)mh$.invokeExact(__id, __n, __d__, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slassq_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static FunctionDescriptor slassq_$descriptor() {
        return slassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slassq_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static MethodHandle slassq_$handle() {
        return slassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slassq_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static MemorySegment slassq_$address() {
        return slassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slassq_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx, __CLPK_real *__scale, __CLPK_real *__sumsq)
     * }
     */
    public static int slassq_(MemorySegment __n, MemorySegment __x, MemorySegment __incx, MemorySegment __scale, MemorySegment __sumsq) {
        var mh$ = slassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slassq_", __n, __x, __incx, __scale, __sumsq);
            }
            return (int)mh$.invokeExact(__n, __x, __incx, __scale, __sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasv2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasv2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasv2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax, __CLPK_real *__snr, __CLPK_real *__csr, __CLPK_real *__snl, __CLPK_real *__csl)
     * }
     */
    public static FunctionDescriptor slasv2_$descriptor() {
        return slasv2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasv2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax, __CLPK_real *__snr, __CLPK_real *__csr, __CLPK_real *__snl, __CLPK_real *__csl)
     * }
     */
    public static MethodHandle slasv2_$handle() {
        return slasv2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasv2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax, __CLPK_real *__snr, __CLPK_real *__csr, __CLPK_real *__snl, __CLPK_real *__csl)
     * }
     */
    public static MemorySegment slasv2_$address() {
        return slasv2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasv2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__, __CLPK_real *__ssmin, __CLPK_real *__ssmax, __CLPK_real *__snr, __CLPK_real *__csr, __CLPK_real *__snl, __CLPK_real *__csl)
     * }
     */
    public static int slasv2_(MemorySegment __f, MemorySegment __g, MemorySegment __h__, MemorySegment __ssmin, MemorySegment __ssmax, MemorySegment __snr, MemorySegment __csr, MemorySegment __snl, MemorySegment __csl) {
        var mh$ = slasv2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasv2_", __f, __g, __h__, __ssmin, __ssmax, __snr, __csr, __snl, __csl);
            }
            return (int)mh$.invokeExact(__f, __g, __h__, __ssmin, __ssmax, __snr, __csr, __snl, __csl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slaswp_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static FunctionDescriptor slaswp_$descriptor() {
        return slaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slaswp_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MethodHandle slaswp_$handle() {
        return slaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slaswp_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static MemorySegment slaswp_$address() {
        return slaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slaswp_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv, __CLPK_integer *__incx)
     * }
     */
    public static int slaswp_(MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __k1, MemorySegment __k2, MemorySegment __ipiv, MemorySegment __incx) {
        var mh$ = slaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaswp_", __n, __a, __lda, __k1, __k2, __ipiv, __incx);
            }
            return (int)mh$.invokeExact(__n, __a, __lda, __k1, __k2, __ipiv, __incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__tl, __CLPK_integer *__ldtl, __CLPK_real *__tr, __CLPK_integer *__ldtr, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasy2_$descriptor() {
        return slasy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__tl, __CLPK_integer *__ldtl, __CLPK_real *__tr, __CLPK_integer *__ldtr, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasy2_$handle() {
        return slasy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__tl, __CLPK_integer *__ldtl, __CLPK_real *__tr, __CLPK_integer *__ldtr, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasy2_$address() {
        return slasy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr, __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__tl, __CLPK_integer *__ldtl, __CLPK_real *__tr, __CLPK_integer *__ldtr, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__scale, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__xnorm, __CLPK_integer *__info)
     * }
     */
    public static int slasy2_(MemorySegment __ltranl, MemorySegment __ltranr, MemorySegment __isgn, MemorySegment __n1, MemorySegment __n2, MemorySegment __tl, MemorySegment __ldtl, MemorySegment __tr, MemorySegment __ldtr, MemorySegment __b, MemorySegment __ldb, MemorySegment __scale, MemorySegment __x, MemorySegment __ldx, MemorySegment __xnorm, MemorySegment __info) {
        var mh$ = slasy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasy2_", __ltranl, __ltranr, __isgn, __n1, __n2, __tl, __ldtl, __tr, __ldtr, __b, __ldb, __scale, __x, __ldx, __xnorm, __info);
            }
            return (int)mh$.invokeExact(__ltranl, __ltranr, __isgn, __n1, __n2, __tl, __ldtl, __tr, __ldtr, __b, __ldb, __scale, __x, __ldx, __xnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasyf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slasyf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slasyf_$descriptor() {
        return slasyf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slasyf_$handle() {
        return slasyf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slasyf_$address() {
        return slasyf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__w, __CLPK_integer *__ldw, __CLPK_integer *__info)
     * }
     */
    public static int slasyf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __kb, MemorySegment __a, MemorySegment __lda, MemorySegment __ipiv, MemorySegment __w, MemorySegment __ldw, MemorySegment __info) {
        var mh$ = slasyf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasyf_", __uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __kb, __a, __lda, __ipiv, __w, __ldw, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatbs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatbs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slatbs_$descriptor() {
        return slatbs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slatbs_$handle() {
        return slatbs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slatbs_$address() {
        return slatbs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatbs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int slatbs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = slatbs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatbs_", __uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __kd, __ab, __ldab, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatdf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatdf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static FunctionDescriptor slatdf_$descriptor() {
        return slatdf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MethodHandle slatdf_$handle() {
        return slatdf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static MemorySegment slatdf_$address() {
        return slatdf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__rhs, __CLPK_real *__rdsum, __CLPK_real *__rdscal, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv)
     * }
     */
    public static int slatdf_(MemorySegment __ijob, MemorySegment __n, MemorySegment __z__, MemorySegment __ldz, MemorySegment __rhs, MemorySegment __rdsum, MemorySegment __rdscal, MemorySegment __ipiv, MemorySegment __jpiv) {
        var mh$ = slatdf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatdf_", __ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
            }
            return (int)mh$.invokeExact(__ijob, __n, __z__, __ldz, __rhs, __rdsum, __rdscal, __ipiv, __jpiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatps_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatps_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slatps_$descriptor() {
        return slatps_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slatps_$handle() {
        return slatps_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slatps_$address() {
        return slatps_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatps_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int slatps_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __ap, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = slatps_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatps_", __uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __ap, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__w, __CLPK_integer *__ldw)
     * }
     */
    public static FunctionDescriptor slatrd_$descriptor() {
        return slatrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MethodHandle slatrd_$handle() {
        return slatrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__w, __CLPK_integer *__ldw)
     * }
     */
    public static MemorySegment slatrd_$address() {
        return slatrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__e, __CLPK_real *__tau, __CLPK_real *__w, __CLPK_integer *__ldw)
     * }
     */
    public static int slatrd_(MemorySegment __uplo, MemorySegment __n, MemorySegment __nb, MemorySegment __a, MemorySegment __lda, MemorySegment __e, MemorySegment __tau, MemorySegment __w, MemorySegment __ldw) {
        var mh$ = slatrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatrd_", __uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
            }
            return (int)mh$.invokeExact(__uplo, __n, __nb, __a, __lda, __e, __tau, __w, __ldw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slatrs_$descriptor() {
        return slatrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slatrs_$handle() {
        return slatrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slatrs_$address() {
        return slatrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatrs_(char *__uplo, char *__trans, char *__diag, char *__normin, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm, __CLPK_integer *__info)
     * }
     */
    public static int slatrs_(MemorySegment __uplo, MemorySegment __trans, MemorySegment __diag, MemorySegment __normin, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __x, MemorySegment __scale, MemorySegment __cnorm, MemorySegment __info) {
        var mh$ = slatrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatrs_", __uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
            }
            return (int)mh$.invokeExact(__uplo, __trans, __diag, __normin, __n, __a, __lda, __x, __scale, __cnorm, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slatrz_$descriptor() {
        return slatrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slatrz_$handle() {
        return slatrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slatrz_$address() {
        return slatrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work)
     * }
     */
    public static int slatrz_(MemorySegment __m, MemorySegment __n, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work) {
        var mh$ = slatrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatrz_", __m, __n, __l, __a, __lda, __tau, __work);
            }
            return (int)mh$.invokeExact(__m, __n, __l, __a, __lda, __tau, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatzm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slatzm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c1, __CLPK_real *__c2, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static FunctionDescriptor slatzm_$descriptor() {
        return slatzm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c1, __CLPK_real *__c2, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MethodHandle slatzm_$handle() {
        return slatzm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c1, __CLPK_real *__c2, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static MemorySegment slatzm_$address() {
        return slatzm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau, __CLPK_real *__c1, __CLPK_real *__c2, __CLPK_integer *__ldc, __CLPK_real *__work)
     * }
     */
    public static int slatzm_(MemorySegment __side, MemorySegment __m, MemorySegment __n, MemorySegment __v, MemorySegment __incv, MemorySegment __tau, MemorySegment __c1, MemorySegment __c2, MemorySegment __ldc, MemorySegment __work) {
        var mh$ = slatzm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatzm_", __side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
            }
            return (int)mh$.invokeExact(__side, __m, __n, __v, __incv, __tau, __c1, __c2, __ldc, __work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slauu2_$descriptor() {
        return slauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slauu2_$handle() {
        return slauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slauu2_$address() {
        return slauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int slauu2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = slauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slauu2_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("slauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slauum_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor slauum_$descriptor() {
        return slauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slauum_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle slauum_$handle() {
        return slauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slauum_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment slauum_$address() {
        return slauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slauum_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__info)
     * }
     */
    public static int slauum_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __info) {
        var mh$ = slauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slauum_", __uplo, __n, __a, __lda, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sopgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sopgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sopgtr_$descriptor() {
        return sopgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sopgtr_$handle() {
        return sopgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sopgtr_$address() {
        return sopgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sopgtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __q, MemorySegment __ldq, MemorySegment __work, MemorySegment __info) {
        var mh$ = sopgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sopgtr_", __uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __ap, __tau, __q, __ldq, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sopmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sopmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sopmtr_$descriptor() {
        return sopmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sopmtr_$handle() {
        return sopmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sopmtr_$address() {
        return sopmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sopmtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ap, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sopmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sopmtr_", __side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __ap, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorg2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorg2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorg2l_$descriptor() {
        return sorg2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorg2l_$handle() {
        return sorg2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorg2l_$address() {
        return sorg2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorg2l_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorg2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorg2l_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorg2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorg2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorg2r_$descriptor() {
        return sorg2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorg2r_$handle() {
        return sorg2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorg2r_$address() {
        return sorg2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorg2r_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorg2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorg2r_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgbr_$descriptor() {
        return sorgbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgbr_$handle() {
        return sorgbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgbr_$address() {
        return sorgbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorgbr_(MemorySegment __vect, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorgbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgbr_", __vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorghr_$descriptor() {
        return sorghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorghr_$handle() {
        return sorghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorghr_$address() {
        return sorghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorghr_(MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorghr_", __n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__n, __ilo, __ihi, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgl2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgl2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgl2_$descriptor() {
        return sorgl2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgl2_$handle() {
        return sorgl2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgl2_$address() {
        return sorgl2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorgl2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorgl2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgl2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorglq_$descriptor() {
        return sorglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorglq_$handle() {
        return sorglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorglq_$address() {
        return sorglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorglq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorglq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgql_$descriptor() {
        return sorgql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgql_$handle() {
        return sorgql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgql_$address() {
        return sorgql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorgql_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorgql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgql_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgqr_$descriptor() {
        return sorgqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgqr_$handle() {
        return sorgqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgqr_$address() {
        return sorgqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorgqr_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorgqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgqr_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgr2_$descriptor() {
        return sorgr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgr2_$handle() {
        return sorgr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgr2_$address() {
        return sorgr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorgr2_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorgr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgr2_", __m, __n, __k, __a, __lda, __tau, __work, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgrq_$descriptor() {
        return sorgrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgrq_$handle() {
        return sorgrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgrq_$address() {
        return sorgrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorgrq_(MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorgrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgrq_", __m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__m, __n, __k, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorgtr_$descriptor() {
        return sorgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorgtr_$handle() {
        return sorgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorgtr_$address() {
        return sorgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sorgtr_(MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sorgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgtr_", __uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __a, __lda, __tau, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorm2l_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorm2l_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorm2l_$descriptor() {
        return sorm2l_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorm2l_$handle() {
        return sorm2l_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorm2l_$address() {
        return sorm2l_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorm2l_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorm2l_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorm2l_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorm2l_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorm2r_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorm2r_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorm2r_$descriptor() {
        return sorm2r_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorm2r_$handle() {
        return sorm2r_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorm2r_$address() {
        return sorm2r_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorm2r_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorm2r_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorm2r_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorm2r_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormbr_$descriptor() {
        return sormbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormbr_$handle() {
        return sormbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormbr_$address() {
        return sormbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormbr_(MemorySegment __vect, MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormbr_", __vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__vect, __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormhr_$descriptor() {
        return sormhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormhr_$handle() {
        return sormhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormhr_$address() {
        return sormhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormhr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormhr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __ilo, MemorySegment __ihi, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormhr_", __side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __ilo, __ihi, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorml2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sorml2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sorml2_$descriptor() {
        return sorml2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sorml2_$handle() {
        return sorml2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sorml2_$address() {
        return sorml2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sorml2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sorml2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sorml2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorml2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormlq_$descriptor() {
        return sormlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormlq_$handle() {
        return sormlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormlq_$address() {
        return sormlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormlq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormlq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormlq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormql_$descriptor() {
        return sormql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormql_$handle() {
        return sormql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormql_$address() {
        return sormql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormql_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormql_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormql_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormqr_$descriptor() {
        return sormqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormqr_$handle() {
        return sormqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormqr_$address() {
        return sormqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormqr_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormqr_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormqr_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormr2_$descriptor() {
        return sormr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormr2_$handle() {
        return sormr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormr2_$address() {
        return sormr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormr2_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sormr2_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sormr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormr2_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormr3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormr3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormr3_$descriptor() {
        return sormr3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormr3_$handle() {
        return sormr3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormr3_$address() {
        return sormr3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormr3_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__info)
     * }
     */
    public static int sormr3_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __info) {
        var mh$ = sormr3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormr3_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormrq_$descriptor() {
        return sormrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormrq_$handle() {
        return sormrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormrq_$address() {
        return sormrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormrq_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormrq_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormrq_", __side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormrz_$descriptor() {
        return sormrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormrz_$handle() {
        return sormrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormrz_$address() {
        return sormrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormrz_(char *__side, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormrz_(MemorySegment __side, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __k, MemorySegment __l, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormrz_", __side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __trans, __m, __n, __k, __l, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("sormtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor sormtr_$descriptor() {
        return sormtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle sormtr_$handle() {
        return sormtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment sormtr_$address() {
        return sormtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
     * }
     */
    public static int sormtr_(MemorySegment __side, MemorySegment __uplo, MemorySegment __trans, MemorySegment __m, MemorySegment __n, MemorySegment __a, MemorySegment __lda, MemorySegment __tau, MemorySegment __c__, MemorySegment __ldc, MemorySegment __work, MemorySegment __lwork, MemorySegment __info) {
        var mh$ = sormtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormtr_", __side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
            }
            return (int)mh$.invokeExact(__side, __uplo, __trans, __m, __n, __a, __lda, __tau, __c__, __ldc, __work, __lwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbcon_$descriptor() {
        return spbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbcon_$handle() {
        return spbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbcon_$address() {
        return spbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int spbcon_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __anorm, MemorySegment __rcond, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = spbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbcon_", __uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __anorm, __rcond, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbequ_$descriptor() {
        return spbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbequ_$handle() {
        return spbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbequ_$address() {
        return spbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax, __CLPK_integer *__info)
     * }
     */
    public static int spbequ_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __s, MemorySegment __scond, MemorySegment __amax, MemorySegment __info) {
        var mh$ = spbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbequ_", __uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __s, __scond, __amax, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbrfs_$descriptor() {
        return spbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbrfs_$handle() {
        return spbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbrfs_$address() {
        return spbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int spbrfs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = spbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbrfs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __b, __ldb, __x, __ldx, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbstf_$descriptor() {
        return spbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbstf_$handle() {
        return spbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbstf_$address() {
        return spbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int spbstf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = spbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbstf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbsv_$descriptor() {
        return spbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbsv_$handle() {
        return spbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbsv_$address() {
        return spbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int spbsv_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = spbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbsv_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbsvx_$descriptor() {
        return spbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbsvx_$handle() {
        return spbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbsvx_$address() {
        return spbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb, char *__equed, __CLPK_real *__s, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__info)
     * }
     */
    public static int spbsvx_(MemorySegment __fact, MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __afb, MemorySegment __ldafb, MemorySegment __equed, MemorySegment __s, MemorySegment __b, MemorySegment __ldb, MemorySegment __x, MemorySegment __ldx, MemorySegment __rcond, MemorySegment __ferr, MemorySegment __berr, MemorySegment __work, MemorySegment __iwork, MemorySegment __info) {
        var mh$ = spbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbsvx_", __fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
            }
            return (int)mh$.invokeExact(__fact, __uplo, __n, __kd, __nrhs, __ab, __ldab, __afb, __ldafb, __equed, __s, __b, __ldb, __x, __ldx, __rcond, __ferr, __berr, __work, __iwork, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbtf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbtf2_$descriptor() {
        return spbtf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbtf2_$handle() {
        return spbtf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbtf2_$address() {
        return spbtf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int spbtf2_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = spbtf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtf2_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbtrf_$descriptor() {
        return spbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbtrf_$handle() {
        return spbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbtrf_$address() {
        return spbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_integer *__info)
     * }
     */
    public static int spbtrf_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __ab, MemorySegment __ldab, MemorySegment __info) {
        var mh$ = spbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtrf_", __uplo, __n, __kd, __ab, __ldab, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __ab, __ldab, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spbtrs_$descriptor() {
        return spbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spbtrs_$handle() {
        return spbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spbtrs_$address() {
        return spbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
     * }
     */
    public static int spbtrs_(MemorySegment __uplo, MemorySegment __n, MemorySegment __kd, MemorySegment __nrhs, MemorySegment __ab, MemorySegment __ldab, MemorySegment __b, MemorySegment __ldb, MemorySegment __info) {
        var mh$ = spbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtrs_", __uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
            }
            return (int)mh$.invokeExact(__uplo, __n, __kd, __nrhs, __ab, __ldab, __b, __ldb, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            clapack_h.C_INT,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER,
            clapack_h.C_POINTER
        );

        public static final MemorySegment ADDR = clapack_h.findOrThrow("spftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static FunctionDescriptor spftrf_$descriptor() {
        return spftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static MethodHandle spftrf_$handle() {
        return spftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static MemorySegment spftrf_$address() {
        return spftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spftrf_(char *__transr, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__info)
     * }
     */
    public static int spftrf_(MemorySegment __transr, MemorySegment __uplo, MemorySegment __n, MemorySegment __a, MemorySegment __info) {
        var mh$ = spftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftrf_", __transr, __uplo, __n, __a, __info);
            }
            return (int)mh$.invokeExact(__transr, __uplo, __n, __a, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

