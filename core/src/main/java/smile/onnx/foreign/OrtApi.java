// Generated by jextract

package smile.onnx.foreign;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct OrtApi {
 *     OrtStatus *(*CreateStatus)(OrtErrorCode, const char *);
 *     OrtErrorCode (*GetErrorCode)(const OrtStatus *);
 *     const char *(*GetErrorMessage)(const OrtStatus *);
 *     OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **);
 *     OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **);
 *     OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *);
 *     OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *);
 *     OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **);
 *     OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **);
 *     OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **);
 *     OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode);
 *     OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *);
 *     OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *);
 *     OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *);
 *     OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *);
 *     OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *);
 *     OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel);
 *     OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **);
 *     OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *);
 *     OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *);
 *     OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **);
 *     OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **);
 *     OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int);
 *     OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int);
 *     OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *);
 *     OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *);
 *     OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *);
 *     OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **);
 *     OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *);
 *     OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *);
 *     OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*IsTensor)(const OrtValue *, int *);
 *     OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **);
 *     OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t);
 *     OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t);
 *     OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *);
 *     OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType);
 *     OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t);
 *     OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *);
 *     OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *);
 *     OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t);
 *     OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t);
 *     OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *);
 *     OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *);
 *     OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **);
 *     OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **);
 *     OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *);
 *     OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **);
 *     OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *);
 *     OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *);
 *     OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *);
 *     OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **);
 *     OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *);
 *     OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **);
 *     OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **);
 *     OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t);
 *     OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **);
 *     OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **);
 *     OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **);
 *     OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t);
 *     OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *);
 *     OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *);
 *     OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **);
 *     OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **);
 *     void (*ReleaseEnv)(OrtEnv *);
 *     void (*ReleaseStatus)(OrtStatus *);
 *     void (*ReleaseMemoryInfo)(OrtMemoryInfo *);
 *     void (*ReleaseSession)(OrtSession *);
 *     void (*ReleaseValue)(OrtValue *);
 *     void (*ReleaseRunOptions)(OrtRunOptions *);
 *     void (*ReleaseTypeInfo)(OrtTypeInfo *);
 *     void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *);
 *     void (*ReleaseSessionOptions)(OrtSessionOptions *);
 *     void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *);
 *     OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *);
 *     OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **);
 *     OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **);
 *     OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *);
 *     OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **);
 *     void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *);
 *     void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *);
 *     OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **);
 *     OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **);
 *     OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *);
 *     void (*ReleaseModelMetadata)(OrtModelMetadata *);
 *     OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **);
 *     OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *);
 *     OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **);
 *     void (*ReleaseThreadingOptions)(OrtThreadingOptions *);
 *     OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *);
 *     OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t);
 *     OrtStatusPtr (*GetAvailableProviders)(char ***, int *);
 *     OrtStatusPtr (*ReleaseAvailableProviders)(char **, int);
 *     OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *);
 *     OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *);
 *     OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t);
 *     OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *);
 *     OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **);
 *     void (*ReleaseAllocator)(OrtAllocator *);
 *     OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *);
 *     OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **);
 *     void (*ReleaseIoBinding)(OrtIoBinding *);
 *     OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *);
 *     OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *);
 *     OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *);
 *     OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *);
 *     OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *);
 *     void (*ClearBoundInputs)(OrtIoBinding *);
 *     void (*ClearBoundOutputs)(OrtIoBinding *);
 *     OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **);
 *     OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *);
 *     OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection);
 *     OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *);
 *     OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *);
 *     OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *);
 *     OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *);
 *     OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **);
 *     void (*ReleaseArenaCfg)(OrtArenaCfg *);
 *     OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *);
 *     OrtStatusPtr (*SetCurrentGpuDeviceId)(int);
 *     OrtStatusPtr (*GetCurrentGpuDeviceId)(int *);
 *     OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *);
 *     OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *);
 *     OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **);
 *     OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *);
 *     OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **);
 *     void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *);
 *     OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);
 *     OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *);
 *     OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **);
 *     OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **);
 *     void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *);
 *     OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *);
 *     OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *);
 *     OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *);
 *     OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *);
 *     OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t);
 *     OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t);
 *     OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *);
 *     OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t);
 *     OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t);
 *     OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *);
 *     OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *);
 *     OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **);
 *     OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **);
 *     OrtStatusPtr (*HasValue)(const OrtValue *, int *);
 *     OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **);
 *     OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **);
 *     OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **);
 *     OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn);
 *     OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *);
 *     OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn);
 *     OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn);
 *     OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *);
 *     OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn);
 *     OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *);
 *     OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *);
 *     OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **);
 *     OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **);
 *     void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *);
 *     OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t);
 *     OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **);
 *     void (*ReleaseOpAttr)(OrtOpAttr *);
 *     OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **);
 *     OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int);
 *     void (*ReleaseOp)(OrtOp *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **);
 *     void (*ReleaseKernelInfo)(OrtKernelInfo *);
 *     const OrtTrainingApi *(*GetTrainingApi)(uint32_t);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *);
 *     OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **);
 *     OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *);
 *     void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *);
 *     OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel);
 *     OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *);
 *     OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **);
 *     OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *);
 *     OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *);
 *     OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **);
 *     OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *);
 *     OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **);
 *     OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **);
 *     OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *);
 *     OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *);
 *     OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **);
 *     OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **);
 *     OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **);
 *     OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **);
 *     const char *(*GetBuildInfoString)(void);
 *     OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **);
 *     OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *);
 *     OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *);
 *     OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *);
 *     OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **);
 *     OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *);
 *     OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **);
 *     OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **);
 *     OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *);
 *     OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *);
 *     OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **);
 *     OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *);
 *     OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t);
 *     OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *);
 *     OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool);
 *     OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **);
 *     OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **);
 *     OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t);
 *     OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **);
 *     OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **);
 *     void (*ReleaseLoraAdapter)(OrtLoraAdapter *);
 *     OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *);
 *     OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t);
 *     void (*ReleaseValueInfo)(OrtValueInfo *);
 *     void (*ReleaseNode)(OrtNode *);
 *     void (*ReleaseGraph)(OrtGraph *);
 *     void (*ReleaseModel)(OrtModel *);
 *     OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **);
 *     OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **);
 *     const OrtModelEditorApi *(*GetModelEditorApi)();
 *     OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool);
 *     const OrtCompileApi *(*GetCompileApi)();
 *     void (*CreateKeyValuePairs)(OrtKeyValuePairs **);
 *     void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *);
 *     const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *);
 *     void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *);
 *     void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *);
 *     void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *);
 *     OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *);
 *     OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *);
 *     OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy);
 *     OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *);
 *     OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *);
 *     uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *);
 *     const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *);
 *     uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *);
 *     const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *);
 *     const char *(*EpDevice_EpName)(const OrtEpDevice *);
 *     const char *(*EpDevice_EpVendor)(const OrtEpDevice *);
 *     const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *);
 *     const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *);
 *     const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *);
 *     const OrtEpApi *(*GetEpApi)();
 *     OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **);
 *     OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **);
 *     OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *);
 *     uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *);
 *     OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *);
 *     OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *);
 *     OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t);
 *     OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **);
 *     OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **);
 *     OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *);
 *     OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *);
 *     OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *);
 *     OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *);
 *     OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *);
 *     OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **);
 *     OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **);
 *     OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *);
 *     OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *);
 *     OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t);
 *     OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *);
 *     OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t);
 *     OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *);
 *     OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t);
 *     OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *);
 *     OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t);
 *     OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *);
 *     OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t);
 *     OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **);
 *     OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **);
 *     OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *);
 *     OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **);
 *     OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **);
 *     OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **);
 *     OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *);
 *     OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *);
 *     OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t);
 *     OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *);
 *     OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t);
 *     OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *);
 *     OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t);
 *     OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *);
 *     OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t);
 *     OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **);
 *     OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **);
 *     OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *);
 *     OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **);
 *     OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *);
 *     OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **);
 *     OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **);
 *     OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **);
 *     void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *);
 *     const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *);
 *     int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *);
 *     size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *);
 *     const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *);
 *     const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType);
 *     OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **);
 *     OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **);
 *     OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType);
 *     OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **);
 *     OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **);
 *     OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t);
 *     OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t);
 *     OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t);
 *     OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **);
 *     void *(*SyncStream_GetHandle)(OrtSyncStream *);
 *     void (*ReleaseSyncStream)(OrtSyncStream *);
 *     OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t);
 *     OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **);
 *     OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *);
 *     OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **);
 * }
 * }
 */
public class OrtApi {

    OrtApi() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        onnxruntime_c_api_h.C_POINTER.withName("CreateStatus"),
        onnxruntime_c_api_h.C_POINTER.withName("GetErrorCode"),
        onnxruntime_c_api_h.C_POINTER.withName("GetErrorMessage"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnv"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnvWithCustomLogger"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableTelemetryEvents"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableTelemetryEvents"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSession"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionFromArray"),
        onnxruntime_c_api_h.C_POINTER.withName("Run"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SetOptimizedModelFilePath"),
        onnxruntime_c_api_h.C_POINTER.withName("CloneSessionOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionExecutionMode"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableProfiling"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableProfiling"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableMemPattern"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableMemPattern"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableCpuMemArena"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableCpuMemArena"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionLogId"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionLogVerbosityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionLogSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionGraphOptimizationLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetIntraOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("SetInterOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCustomOpDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("CustomOpDomain_Add"),
        onnxruntime_c_api_h.C_POINTER.withName("AddCustomOpDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterCustomOpsLibrary"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOutputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOverridableInitializerCount"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetInputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOutputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOverridableInitializerTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetInputName"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOutputName"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOverridableInitializerName"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateRunOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetRunLogVerbosityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetRunLogSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetRunTag"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsGetRunLogVerbosityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsGetRunLogSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsGetRunTag"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetTerminate"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsUnsetTerminate"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorWithDataAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("IsTensor"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorMutableData"),
        onnxruntime_c_api_h.C_POINTER.withName("FillStringTensor"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorDataLength"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorContent"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToTensorInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOnnxTypeFromTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorTypeAndShapeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SetTensorElementType"),
        onnxruntime_c_api_h.C_POINTER.withName("SetDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorElementType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDimensionsCount"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSymbolicDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorShapeElementCount"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorTypeAndShape"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValueType"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCpuMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CompareMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetName"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetId"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetMemType"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetType"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorAlloc"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorFree"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorGetInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetAllocatorWithDefaultOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("AddFreeDimensionOverride"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValueCount"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateValue"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOpaqueValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOpaqueValue"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_float"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_int64"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_string"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetOutputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetInput"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetOutput"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseEnv"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseStatus"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSession"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseValue"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseRunOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseTensorTypeAndShapeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSessionOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseCustomOpDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDenotationFromTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToMapTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToSequenceTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetMapKeyType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetMapValueType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSequenceElementType"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseMapTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSequenceTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionEndProfiling"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetModelMetadata"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetProducerName"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetGraphName"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetDescription"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataLookupCustomMetadataMap"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetVersion"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseModelMetadata"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnvWithGlobalThreadPools"),
        onnxruntime_c_api_h.C_POINTER.withName("DisablePerSessionThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateThreadingOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseThreadingOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetCustomMetadataMapKeys"),
        onnxruntime_c_api_h.C_POINTER.withName("AddFreeDimensionOverrideByName"),
        onnxruntime_c_api_h.C_POINTER.withName("GetAvailableProviders"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseAvailableProviders"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorElementLength"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorElement"),
        onnxruntime_c_api_h.C_POINTER.withName("FillStringTensorElement"),
        onnxruntime_c_api_h.C_POINTER.withName("AddSessionConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("RunWithBinding"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateIoBinding"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseIoBinding"),
        onnxruntime_c_api_h.C_POINTER.withName("BindInput"),
        onnxruntime_c_api_h.C_POINTER.withName("BindOutput"),
        onnxruntime_c_api_h.C_POINTER.withName("BindOutputToDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("GetBoundOutputNames"),
        onnxruntime_c_api_h.C_POINTER.withName("GetBoundOutputValues"),
        onnxruntime_c_api_h.C_POINTER.withName("ClearBoundInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("ClearBoundOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("TensorAt"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateAndRegisterAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("SetLanguageProjection"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetProfilingStartTimeNs"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalIntraOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalInterOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalSpinControl"),
        onnxruntime_c_api_h.C_POINTER.withName("AddInitializer"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnvWithCustomLoggerAndGlobalThreadPools"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CUDA"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_ROCM"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_OpenVINO"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalDenormalAsZero"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateArenaCfg"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseArenaCfg"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetGraphDescription"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_TensorRT"),
        onnxruntime_c_api_h.C_POINTER.withName("SetCurrentGpuDeviceId"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCurrentGpuDeviceId"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttributeArray_float"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttributeArray_int64"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateArenaCfgV2"),
        onnxruntime_c_api_h.C_POINTER.withName("AddRunConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("CreatePrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleasePrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionWithPrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionFromArrayWithPrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_TensorRT_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorRTProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateTensorRTProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorRTProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseTensorRTProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableOrtCustomOps"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("UnregisterAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("IsSparseTensor"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSparseTensorAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("FillSparseTensorCoo"),
        onnxruntime_c_api_h.C_POINTER.withName("FillSparseTensorCsr"),
        onnxruntime_c_api_h.C_POINTER.withName("FillSparseTensorBlockSparse"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSparseTensorWithValuesAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("UseCooIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("UseCsrIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("UseBlockSparseIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorFormat"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorValuesTypeAndShape"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorValues"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorIndicesTypeShape"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("HasValue"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetGPUComputeStream"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetExecutionProviderApi"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetCustomCreateThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetCustomThreadCreationOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetCustomJoinThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalCustomCreateThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalCustomThreadCreationOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalCustomJoinThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SynchronizeBoundInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SynchronizeBoundOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CUDA_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCUDAProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateCUDAProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCUDAProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseCUDAProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_MIGraphX"),
        onnxruntime_c_api_h.C_POINTER.withName("AddExternalInitializers"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOpAttr"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseOpAttr"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOp"),
        onnxruntime_c_api_h.C_POINTER.withName("InvokeOp"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseOp"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider"),
        onnxruntime_c_api_h.C_POINTER.withName("CopyKernelInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseKernelInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTrainingApi"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CANN"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCANNProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateCANNProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCANNProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseCANNProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetDeviceType"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateEnvWithCustomLogLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalIntraOpThreadAffinity"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterCustomOpsLibrary_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterCustomOpsUsingFunction"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetOutputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetInputName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetOutputName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetInputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetOutputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_tensor"),
        onnxruntime_c_api_h.C_POINTER.withName("HasSessionConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSessionConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_Dnnl"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateDnnlProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateDnnlProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDnnlProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseDnnlProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetNodeName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetLogger"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetLogger"),
        onnxruntime_c_api_h.C_POINTER.withName("Logger_LogMessage"),
        onnxruntime_c_api_h.C_POINTER.withName("Logger_GetLoggingSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetConstantInput_tensor"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToOptionalTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOptionalContainedTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetResizedStringTensorElementBuffer"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("GetBuildInfoString"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateROCMProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateROCMProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetROCMProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseROCMProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateAndRegisterAllocatorV2"),
        onnxruntime_c_api_h.C_POINTER.withName("RunAsync"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateTensorRTProviderOptionsWithValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorRTProviderOptionsByName"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateCUDAProviderOptionsWithValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCUDAProviderOptionsByName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetResource"),
        onnxruntime_c_api_h.C_POINTER.withName("SetUserLoggingFunction"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_GetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_GetInputTypeShape"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_GetAttribute"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_SetOutputTypeShape"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSymbolicDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReadOpAttr"),
        onnxruntime_c_api_h.C_POINTER.withName("SetDeterministicCompute"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_ParallelFor"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_OpenVINO_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_VitisAI"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetScratchBuffer"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("AddExternalInitializersFromFilesInMemory"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateLoraAdapter"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateLoraAdapterFromArray"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseLoraAdapter"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsAddActiveLoraAdapter"),
        onnxruntime_c_api_h.C_POINTER.withName("SetEpDynamicOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseValueInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseNode"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseGraph"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseModel"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValueInfoName"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValueInfoTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetModelEditorApi"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorWithDataAndDeleterAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetLoadCancellationFlag"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCompileApi"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateKeyValuePairs"),
        onnxruntime_c_api_h.C_POINTER.withName("AddKeyValuePair"),
        onnxruntime_c_api_h.C_POINTER.withName("GetKeyValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetKeyValuePairs"),
        onnxruntime_c_api_h.C_POINTER.withName("RemoveKeyValuePair"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseKeyValuePairs"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterExecutionProviderLibrary"),
        onnxruntime_c_api_h.C_POINTER.withName("UnregisterExecutionProviderLibrary"),
        onnxruntime_c_api_h.C_POINTER.withName("GetEpDevices"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetEpSelectionPolicy"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetEpSelectionPolicyDelegate"),
        onnxruntime_c_api_h.C_POINTER.withName("HardwareDevice_Type"),
        onnxruntime_c_api_h.C_POINTER.withName("HardwareDevice_VendorId"),
        onnxruntime_c_api_h.C_POINTER.withName("HardwareDevice_Vendor"),
        onnxruntime_c_api_h.C_POINTER.withName("HardwareDevice_DeviceId"),
        onnxruntime_c_api_h.C_POINTER.withName("HardwareDevice_Metadata"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_EpName"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_EpVendor"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_EpMetadata"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_EpOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_Device"),
        onnxruntime_c_api_h.C_POINTER.withName("GetEpApi"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorSizeInBytes"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorGetStats"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateMemoryInfo_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetDeviceMemType"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetVendorId"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_GetValueProducer"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_GetValueNumConsumers"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_GetValueConsumers"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_GetInitializerValue"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_GetExternalInitializerInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_IsRequiredGraphInput"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_IsOptionalGraphInput"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_IsGraphOutput"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_IsConstantInitializer"),
        onnxruntime_c_api_h.C_POINTER.withName("ValueInfo_IsFromOuterScope"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetName"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetModelPath"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetOnnxIRVersion"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetNumOperatorSets"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetOperatorSets"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetNumInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetNumOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetNumInitializers"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetInitializers"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetNumNodes"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetNodes"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetParentNode"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetGraphView"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetId"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetName"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetOperatorType"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetSinceVersion"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetNumInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetNumOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetNumImplicitInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetImplicitInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetNumAttributes"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetAttributes"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetAttributeByName"),
        onnxruntime_c_api_h.C_POINTER.withName("OpAttr_GetTensorAttributeAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("OpAttr_GetType"),
        onnxruntime_c_api_h.C_POINTER.withName("OpAttr_GetName"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetNumSubgraphs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetSubgraphs"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetGraph"),
        onnxruntime_c_api_h.C_POINTER.withName("Node_GetEpName"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseExternalInitializerInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ExternalInitializerInfo_GetFilePath"),
        onnxruntime_c_api_h.C_POINTER.withName("ExternalInitializerInfo_GetFileOffset"),
        onnxruntime_c_api_h.C_POINTER.withName("ExternalInitializerInfo_GetByteSize"),
        onnxruntime_c_api_h.C_POINTER.withName("GetRunConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_MemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSharedAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSharedAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSharedAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorData"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSessionOptionsConfigEntries"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetMemoryInfoForInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetMemoryInfoForOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetEpDeviceForInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSyncStreamForEpDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("SyncStream_GetHandle"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSyncStream"),
        onnxruntime_c_api_h.C_POINTER.withName("CopyTensors"),
        onnxruntime_c_api_h.C_POINTER.withName("Graph_GetModelMetadata"),
        onnxruntime_c_api_h.C_POINTER.withName("GetModelCompatibilityForEpDevices"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateExternalInitializerInfo")
    ).withName("OrtApi");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public final static class CreateStatus {

        private CreateStatus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateStatus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateStatus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static final AddressLayout CreateStatus$layout() {
        return CreateStatus$LAYOUT;
    }

    private static final long CreateStatus$OFFSET = $LAYOUT.byteOffset(groupElement("CreateStatus"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static final long CreateStatus$offset() {
        return CreateStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static MemorySegment CreateStatus(MemorySegment struct) {
        return struct.get(CreateStatus$LAYOUT, CreateStatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static void CreateStatus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateStatus$LAYOUT, CreateStatus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public final static class GetErrorCode {

        private GetErrorCode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetErrorCode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetErrorCode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetErrorCode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetErrorCode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static final AddressLayout GetErrorCode$layout() {
        return GetErrorCode$LAYOUT;
    }

    private static final long GetErrorCode$OFFSET = $LAYOUT.byteOffset(groupElement("GetErrorCode"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static final long GetErrorCode$offset() {
        return GetErrorCode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static MemorySegment GetErrorCode(MemorySegment struct) {
        return struct.get(GetErrorCode$LAYOUT, GetErrorCode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static void GetErrorCode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetErrorCode$LAYOUT, GetErrorCode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public final static class GetErrorMessage {

        private GetErrorMessage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetErrorMessage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetErrorMessage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetErrorMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetErrorMessage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static final AddressLayout GetErrorMessage$layout() {
        return GetErrorMessage$LAYOUT;
    }

    private static final long GetErrorMessage$OFFSET = $LAYOUT.byteOffset(groupElement("GetErrorMessage"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static final long GetErrorMessage$offset() {
        return GetErrorMessage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static MemorySegment GetErrorMessage(MemorySegment struct) {
        return struct.get(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static void GetErrorMessage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public final static class CreateEnv {

        private CreateEnv() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateEnv.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnv.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnv$layout() {
        return CreateEnv$LAYOUT;
    }

    private static final long CreateEnv$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnv"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final long CreateEnv$offset() {
        return CreateEnv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnv(MemorySegment struct) {
        return struct.get(CreateEnv$LAYOUT, CreateEnv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static void CreateEnv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnv$LAYOUT, CreateEnv$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public final static class CreateEnvWithCustomLogger {

        private CreateEnvWithCustomLogger() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateEnvWithCustomLogger.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnvWithCustomLogger.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnvWithCustomLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnvWithCustomLogger"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnvWithCustomLogger$layout() {
        return CreateEnvWithCustomLogger$LAYOUT;
    }

    private static final long CreateEnvWithCustomLogger$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnvWithCustomLogger"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final long CreateEnvWithCustomLogger$offset() {
        return CreateEnvWithCustomLogger$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithCustomLogger(MemorySegment struct) {
        return struct.get(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static void CreateEnvWithCustomLogger(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public final static class EnableTelemetryEvents {

        private EnableTelemetryEvents() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EnableTelemetryEvents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableTelemetryEvents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableTelemetryEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableTelemetryEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final AddressLayout EnableTelemetryEvents$layout() {
        return EnableTelemetryEvents$LAYOUT;
    }

    private static final long EnableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement("EnableTelemetryEvents"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final long EnableTelemetryEvents$offset() {
        return EnableTelemetryEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static MemorySegment EnableTelemetryEvents(MemorySegment struct) {
        return struct.get(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static void EnableTelemetryEvents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public final static class DisableTelemetryEvents {

        private DisableTelemetryEvents() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(DisableTelemetryEvents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableTelemetryEvents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableTelemetryEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableTelemetryEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final AddressLayout DisableTelemetryEvents$layout() {
        return DisableTelemetryEvents$LAYOUT;
    }

    private static final long DisableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement("DisableTelemetryEvents"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final long DisableTelemetryEvents$offset() {
        return DisableTelemetryEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static MemorySegment DisableTelemetryEvents(MemorySegment struct) {
        return struct.get(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static void DisableTelemetryEvents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public final static class CreateSession {

        private CreateSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSession$layout() {
        return CreateSession$LAYOUT;
    }

    private static final long CreateSession$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSession"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateSession$offset() {
        return CreateSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSession(MemorySegment struct) {
        return struct.get(CreateSession$LAYOUT, CreateSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSession$LAYOUT, CreateSession$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public final static class CreateSessionFromArray {

        private CreateSessionFromArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSessionFromArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionFromArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionFromArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionFromArray$layout() {
        return CreateSessionFromArray$LAYOUT;
    }

    private static final long CreateSessionFromArray$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionFromArray"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateSessionFromArray$offset() {
        return CreateSessionFromArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromArray(MemorySegment struct) {
        return struct.get(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateSessionFromArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public final static class Run {

        private Run() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Run.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Run.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Run$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Run"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static final AddressLayout Run$layout() {
        return Run$LAYOUT;
    }

    private static final long Run$OFFSET = $LAYOUT.byteOffset(groupElement("Run"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static final long Run$offset() {
        return Run$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment Run(MemorySegment struct) {
        return struct.get(Run$LAYOUT, Run$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static void Run(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Run$LAYOUT, Run$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public final static class CreateSessionOptions {

        private CreateSessionOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSessionOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static final AddressLayout CreateSessionOptions$layout() {
        return CreateSessionOptions$LAYOUT;
    }

    private static final long CreateSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static final long CreateSessionOptions$offset() {
        return CreateSessionOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static MemorySegment CreateSessionOptions(MemorySegment struct) {
        return struct.get(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static void CreateSessionOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public final static class SetOptimizedModelFilePath {

        private SetOptimizedModelFilePath() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetOptimizedModelFilePath.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetOptimizedModelFilePath.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetOptimizedModelFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetOptimizedModelFilePath"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout SetOptimizedModelFilePath$layout() {
        return SetOptimizedModelFilePath$LAYOUT;
    }

    private static final long SetOptimizedModelFilePath$OFFSET = $LAYOUT.byteOffset(groupElement("SetOptimizedModelFilePath"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long SetOptimizedModelFilePath$offset() {
        return SetOptimizedModelFilePath$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment SetOptimizedModelFilePath(MemorySegment struct) {
        return struct.get(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static void SetOptimizedModelFilePath(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public final static class CloneSessionOptions {

        private CloneSessionOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CloneSessionOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CloneSessionOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CloneSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CloneSessionOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static final AddressLayout CloneSessionOptions$layout() {
        return CloneSessionOptions$LAYOUT;
    }

    private static final long CloneSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CloneSessionOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static final long CloneSessionOptions$offset() {
        return CloneSessionOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static MemorySegment CloneSessionOptions(MemorySegment struct) {
        return struct.get(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static void CloneSessionOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public final static class SetSessionExecutionMode {

        private SetSessionExecutionMode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetSessionExecutionMode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionExecutionMode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionExecutionMode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionExecutionMode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static final AddressLayout SetSessionExecutionMode$layout() {
        return SetSessionExecutionMode$LAYOUT;
    }

    private static final long SetSessionExecutionMode$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionExecutionMode"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static final long SetSessionExecutionMode$offset() {
        return SetSessionExecutionMode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static MemorySegment SetSessionExecutionMode(MemorySegment struct) {
        return struct.get(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static void SetSessionExecutionMode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public final static class EnableProfiling {

        private EnableProfiling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EnableProfiling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableProfiling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableProfiling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout EnableProfiling$layout() {
        return EnableProfiling$LAYOUT;
    }

    private static final long EnableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement("EnableProfiling"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long EnableProfiling$offset() {
        return EnableProfiling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment EnableProfiling(MemorySegment struct) {
        return struct.get(EnableProfiling$LAYOUT, EnableProfiling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static void EnableProfiling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableProfiling$LAYOUT, EnableProfiling$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public final static class DisableProfiling {

        private DisableProfiling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(DisableProfiling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableProfiling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableProfiling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisableProfiling$layout() {
        return DisableProfiling$LAYOUT;
    }

    private static final long DisableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement("DisableProfiling"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static final long DisableProfiling$offset() {
        return DisableProfiling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableProfiling(MemorySegment struct) {
        return struct.get(DisableProfiling$LAYOUT, DisableProfiling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static void DisableProfiling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableProfiling$LAYOUT, DisableProfiling$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public final static class EnableMemPattern {

        private EnableMemPattern() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EnableMemPattern.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableMemPattern.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableMemPattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout EnableMemPattern$layout() {
        return EnableMemPattern$LAYOUT;
    }

    private static final long EnableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement("EnableMemPattern"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final long EnableMemPattern$offset() {
        return EnableMemPattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableMemPattern(MemorySegment struct) {
        return struct.get(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static void EnableMemPattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public final static class DisableMemPattern {

        private DisableMemPattern() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(DisableMemPattern.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableMemPattern.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableMemPattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisableMemPattern$layout() {
        return DisableMemPattern$LAYOUT;
    }

    private static final long DisableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement("DisableMemPattern"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final long DisableMemPattern$offset() {
        return DisableMemPattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableMemPattern(MemorySegment struct) {
        return struct.get(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static void DisableMemPattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public final static class EnableCpuMemArena {

        private EnableCpuMemArena() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EnableCpuMemArena.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableCpuMemArena.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableCpuMemArena"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout EnableCpuMemArena$layout() {
        return EnableCpuMemArena$LAYOUT;
    }

    private static final long EnableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement("EnableCpuMemArena"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final long EnableCpuMemArena$offset() {
        return EnableCpuMemArena$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableCpuMemArena(MemorySegment struct) {
        return struct.get(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static void EnableCpuMemArena(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public final static class DisableCpuMemArena {

        private DisableCpuMemArena() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(DisableCpuMemArena.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableCpuMemArena.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableCpuMemArena"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisableCpuMemArena$layout() {
        return DisableCpuMemArena$LAYOUT;
    }

    private static final long DisableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement("DisableCpuMemArena"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final long DisableCpuMemArena$offset() {
        return DisableCpuMemArena$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableCpuMemArena(MemorySegment struct) {
        return struct.get(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static void DisableCpuMemArena(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public final static class SetSessionLogId {

        private SetSessionLogId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetSessionLogId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionLogId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionLogId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionLogId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout SetSessionLogId$layout() {
        return SetSessionLogId$LAYOUT;
    }

    private static final long SetSessionLogId$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionLogId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long SetSessionLogId$offset() {
        return SetSessionLogId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment SetSessionLogId(MemorySegment struct) {
        return struct.get(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static void SetSessionLogId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public final static class SetSessionLogVerbosityLevel {

        private SetSessionLogVerbosityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetSessionLogVerbosityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionLogVerbosityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionLogVerbosityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetSessionLogVerbosityLevel$layout() {
        return SetSessionLogVerbosityLevel$LAYOUT;
    }

    private static final long SetSessionLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionLogVerbosityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetSessionLogVerbosityLevel$offset() {
        return SetSessionLogVerbosityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetSessionLogVerbosityLevel(MemorySegment struct) {
        return struct.get(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static void SetSessionLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public final static class SetSessionLogSeverityLevel {

        private SetSessionLogSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetSessionLogSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionLogSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionLogSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetSessionLogSeverityLevel$layout() {
        return SetSessionLogSeverityLevel$LAYOUT;
    }

    private static final long SetSessionLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionLogSeverityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetSessionLogSeverityLevel$offset() {
        return SetSessionLogSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetSessionLogSeverityLevel(MemorySegment struct) {
        return struct.get(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static void SetSessionLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public final static class SetSessionGraphOptimizationLevel {

        private SetSessionGraphOptimizationLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetSessionGraphOptimizationLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionGraphOptimizationLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionGraphOptimizationLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionGraphOptimizationLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static final AddressLayout SetSessionGraphOptimizationLevel$layout() {
        return SetSessionGraphOptimizationLevel$LAYOUT;
    }

    private static final long SetSessionGraphOptimizationLevel$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionGraphOptimizationLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static final long SetSessionGraphOptimizationLevel$offset() {
        return SetSessionGraphOptimizationLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static MemorySegment SetSessionGraphOptimizationLevel(MemorySegment struct) {
        return struct.get(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static void SetSessionGraphOptimizationLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public final static class SetIntraOpNumThreads {

        private SetIntraOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetIntraOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetIntraOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetIntraOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetIntraOpNumThreads$layout() {
        return SetIntraOpNumThreads$LAYOUT;
    }

    private static final long SetIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetIntraOpNumThreads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetIntraOpNumThreads$offset() {
        return SetIntraOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetIntraOpNumThreads(MemorySegment struct) {
        return struct.get(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static void SetIntraOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public final static class SetInterOpNumThreads {

        private SetInterOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetInterOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetInterOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetInterOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetInterOpNumThreads$layout() {
        return SetInterOpNumThreads$LAYOUT;
    }

    private static final long SetInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetInterOpNumThreads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetInterOpNumThreads$offset() {
        return SetInterOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetInterOpNumThreads(MemorySegment struct) {
        return struct.get(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static void SetInterOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public final static class CreateCustomOpDomain {

        private CreateCustomOpDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateCustomOpDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCustomOpDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCustomOpDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static final AddressLayout CreateCustomOpDomain$layout() {
        return CreateCustomOpDomain$LAYOUT;
    }

    private static final long CreateCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCustomOpDomain"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static final long CreateCustomOpDomain$offset() {
        return CreateCustomOpDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static MemorySegment CreateCustomOpDomain(MemorySegment struct) {
        return struct.get(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static void CreateCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public final static class CustomOpDomain_Add {

        private CustomOpDomain_Add() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CustomOpDomain_Add.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CustomOpDomain_Add.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CustomOpDomain_Add$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CustomOpDomain_Add"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static final AddressLayout CustomOpDomain_Add$layout() {
        return CustomOpDomain_Add$LAYOUT;
    }

    private static final long CustomOpDomain_Add$OFFSET = $LAYOUT.byteOffset(groupElement("CustomOpDomain_Add"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static final long CustomOpDomain_Add$offset() {
        return CustomOpDomain_Add$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static MemorySegment CustomOpDomain_Add(MemorySegment struct) {
        return struct.get(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static void CustomOpDomain_Add(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public final static class AddCustomOpDomain {

        private AddCustomOpDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddCustomOpDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddCustomOpDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddCustomOpDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static final AddressLayout AddCustomOpDomain$layout() {
        return AddCustomOpDomain$LAYOUT;
    }

    private static final long AddCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement("AddCustomOpDomain"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static final long AddCustomOpDomain$offset() {
        return AddCustomOpDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static MemorySegment AddCustomOpDomain(MemorySegment struct) {
        return struct.get(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static void AddCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public final static class RegisterCustomOpsLibrary {

        private RegisterCustomOpsLibrary() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RegisterCustomOpsLibrary.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterCustomOpsLibrary.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterCustomOpsLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterCustomOpsLibrary"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static final AddressLayout RegisterCustomOpsLibrary$layout() {
        return RegisterCustomOpsLibrary$LAYOUT;
    }

    private static final long RegisterCustomOpsLibrary$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterCustomOpsLibrary"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static final long RegisterCustomOpsLibrary$offset() {
        return RegisterCustomOpsLibrary$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static MemorySegment RegisterCustomOpsLibrary(MemorySegment struct) {
        return struct.get(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static void RegisterCustomOpsLibrary(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public final static class SessionGetInputCount {

        private SessionGetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final AddressLayout SessionGetInputCount$layout() {
        return SessionGetInputCount$LAYOUT;
    }

    private static final long SessionGetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetInputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final long SessionGetInputCount$offset() {
        return SessionGetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetInputCount(MemorySegment struct) {
        return struct.get(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static void SessionGetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public final static class SessionGetOutputCount {

        private SessionGetOutputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOutputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOutputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final AddressLayout SessionGetOutputCount$layout() {
        return SessionGetOutputCount$LAYOUT;
    }

    private static final long SessionGetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOutputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final long SessionGetOutputCount$offset() {
        return SessionGetOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetOutputCount(MemorySegment struct) {
        return struct.get(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static void SessionGetOutputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public final static class SessionGetOverridableInitializerCount {

        private SessionGetOverridableInitializerCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOverridableInitializerCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOverridableInitializerCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOverridableInitializerCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static final AddressLayout SessionGetOverridableInitializerCount$layout() {
        return SessionGetOverridableInitializerCount$LAYOUT;
    }

    private static final long SessionGetOverridableInitializerCount$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOverridableInitializerCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static final long SessionGetOverridableInitializerCount$offset() {
        return SessionGetOverridableInitializerCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerCount(MemorySegment struct) {
        return struct.get(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static void SessionGetOverridableInitializerCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public final static class SessionGetInputTypeInfo {

        private SessionGetInputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetInputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetInputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetInputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout SessionGetInputTypeInfo$layout() {
        return SessionGetInputTypeInfo$LAYOUT;
    }

    private static final long SessionGetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetInputTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long SessionGetInputTypeInfo$offset() {
        return SessionGetInputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetInputTypeInfo(MemorySegment struct) {
        return struct.get(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static void SessionGetInputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public final static class SessionGetOutputTypeInfo {

        private SessionGetOutputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOutputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOutputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOutputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout SessionGetOutputTypeInfo$layout() {
        return SessionGetOutputTypeInfo$LAYOUT;
    }

    private static final long SessionGetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOutputTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long SessionGetOutputTypeInfo$offset() {
        return SessionGetOutputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetOutputTypeInfo(MemorySegment struct) {
        return struct.get(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static void SessionGetOutputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public final static class SessionGetOverridableInitializerTypeInfo {

        private SessionGetOverridableInitializerTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOverridableInitializerTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOverridableInitializerTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOverridableInitializerTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout SessionGetOverridableInitializerTypeInfo$layout() {
        return SessionGetOverridableInitializerTypeInfo$LAYOUT;
    }

    private static final long SessionGetOverridableInitializerTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOverridableInitializerTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long SessionGetOverridableInitializerTypeInfo$offset() {
        return SessionGetOverridableInitializerTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerTypeInfo(MemorySegment struct) {
        return struct.get(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static void SessionGetOverridableInitializerTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public final static class SessionGetInputName {

        private SessionGetInputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetInputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetInputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetInputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionGetInputName$layout() {
        return SessionGetInputName$LAYOUT;
    }

    private static final long SessionGetInputName$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetInputName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final long SessionGetInputName$offset() {
        return SessionGetInputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetInputName(MemorySegment struct) {
        return struct.get(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static void SessionGetInputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public final static class SessionGetOutputName {

        private SessionGetOutputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOutputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOutputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOutputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionGetOutputName$layout() {
        return SessionGetOutputName$LAYOUT;
    }

    private static final long SessionGetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOutputName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final long SessionGetOutputName$offset() {
        return SessionGetOutputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetOutputName(MemorySegment struct) {
        return struct.get(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static void SessionGetOutputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public final static class SessionGetOverridableInitializerName {

        private SessionGetOverridableInitializerName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOverridableInitializerName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOverridableInitializerName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOverridableInitializerName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionGetOverridableInitializerName$layout() {
        return SessionGetOverridableInitializerName$LAYOUT;
    }

    private static final long SessionGetOverridableInitializerName$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOverridableInitializerName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final long SessionGetOverridableInitializerName$offset() {
        return SessionGetOverridableInitializerName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerName(MemorySegment struct) {
        return struct.get(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static void SessionGetOverridableInitializerName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public final static class CreateRunOptions {

        private CreateRunOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateRunOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateRunOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateRunOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static final AddressLayout CreateRunOptions$layout() {
        return CreateRunOptions$LAYOUT;
    }

    private static final long CreateRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateRunOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static final long CreateRunOptions$offset() {
        return CreateRunOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static MemorySegment CreateRunOptions(MemorySegment struct) {
        return struct.get(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static void CreateRunOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public final static class RunOptionsSetRunLogVerbosityLevel {

        private RunOptionsSetRunLogVerbosityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsSetRunLogVerbosityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetRunLogVerbosityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetRunLogVerbosityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final AddressLayout RunOptionsSetRunLogVerbosityLevel$layout() {
        return RunOptionsSetRunLogVerbosityLevel$LAYOUT;
    }

    private static final long RunOptionsSetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetRunLogVerbosityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final long RunOptionsSetRunLogVerbosityLevel$offset() {
        return RunOptionsSetRunLogVerbosityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static MemorySegment RunOptionsSetRunLogVerbosityLevel(MemorySegment struct) {
        return struct.get(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static void RunOptionsSetRunLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public final static class RunOptionsSetRunLogSeverityLevel {

        private RunOptionsSetRunLogSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsSetRunLogSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetRunLogSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetRunLogSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final AddressLayout RunOptionsSetRunLogSeverityLevel$layout() {
        return RunOptionsSetRunLogSeverityLevel$LAYOUT;
    }

    private static final long RunOptionsSetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetRunLogSeverityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final long RunOptionsSetRunLogSeverityLevel$offset() {
        return RunOptionsSetRunLogSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static MemorySegment RunOptionsSetRunLogSeverityLevel(MemorySegment struct) {
        return struct.get(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static void RunOptionsSetRunLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public final static class RunOptionsSetRunTag {

        private RunOptionsSetRunTag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsSetRunTag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetRunTag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetRunTag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static final AddressLayout RunOptionsSetRunTag$layout() {
        return RunOptionsSetRunTag$LAYOUT;
    }

    private static final long RunOptionsSetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetRunTag"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static final long RunOptionsSetRunTag$offset() {
        return RunOptionsSetRunTag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static MemorySegment RunOptionsSetRunTag(MemorySegment struct) {
        return struct.get(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static void RunOptionsSetRunTag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public final static class RunOptionsGetRunLogVerbosityLevel {

        private RunOptionsGetRunLogVerbosityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsGetRunLogVerbosityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsGetRunLogVerbosityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsGetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsGetRunLogVerbosityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final AddressLayout RunOptionsGetRunLogVerbosityLevel$layout() {
        return RunOptionsGetRunLogVerbosityLevel$LAYOUT;
    }

    private static final long RunOptionsGetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsGetRunLogVerbosityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final long RunOptionsGetRunLogVerbosityLevel$offset() {
        return RunOptionsGetRunLogVerbosityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static MemorySegment RunOptionsGetRunLogVerbosityLevel(MemorySegment struct) {
        return struct.get(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static void RunOptionsGetRunLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public final static class RunOptionsGetRunLogSeverityLevel {

        private RunOptionsGetRunLogSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsGetRunLogSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsGetRunLogSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsGetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsGetRunLogSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final AddressLayout RunOptionsGetRunLogSeverityLevel$layout() {
        return RunOptionsGetRunLogSeverityLevel$LAYOUT;
    }

    private static final long RunOptionsGetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsGetRunLogSeverityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final long RunOptionsGetRunLogSeverityLevel$offset() {
        return RunOptionsGetRunLogSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static MemorySegment RunOptionsGetRunLogSeverityLevel(MemorySegment struct) {
        return struct.get(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static void RunOptionsGetRunLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public final static class RunOptionsGetRunTag {

        private RunOptionsGetRunTag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsGetRunTag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsGetRunTag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsGetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsGetRunTag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static final AddressLayout RunOptionsGetRunTag$layout() {
        return RunOptionsGetRunTag$LAYOUT;
    }

    private static final long RunOptionsGetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsGetRunTag"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static final long RunOptionsGetRunTag$offset() {
        return RunOptionsGetRunTag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static MemorySegment RunOptionsGetRunTag(MemorySegment struct) {
        return struct.get(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static void RunOptionsGetRunTag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public final static class RunOptionsSetTerminate {

        private RunOptionsSetTerminate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsSetTerminate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetTerminate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetTerminate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static final AddressLayout RunOptionsSetTerminate$layout() {
        return RunOptionsSetTerminate$LAYOUT;
    }

    private static final long RunOptionsSetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetTerminate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static final long RunOptionsSetTerminate$offset() {
        return RunOptionsSetTerminate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static MemorySegment RunOptionsSetTerminate(MemorySegment struct) {
        return struct.get(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static void RunOptionsSetTerminate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public final static class RunOptionsUnsetTerminate {

        private RunOptionsUnsetTerminate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsUnsetTerminate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsUnsetTerminate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsUnsetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsUnsetTerminate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static final AddressLayout RunOptionsUnsetTerminate$layout() {
        return RunOptionsUnsetTerminate$LAYOUT;
    }

    private static final long RunOptionsUnsetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsUnsetTerminate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static final long RunOptionsUnsetTerminate$offset() {
        return RunOptionsUnsetTerminate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static MemorySegment RunOptionsUnsetTerminate(MemorySegment struct) {
        return struct.get(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static void RunOptionsUnsetTerminate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public final static class CreateTensorAsOrtValue {

        private CreateTensorAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateTensorAsOrtValue$layout() {
        return CreateTensorAsOrtValue$LAYOUT;
    }

    private static final long CreateTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorAsOrtValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateTensorAsOrtValue$offset() {
        return CreateTensorAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorAsOrtValue(MemorySegment struct) {
        return struct.get(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateTensorAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public final static class CreateTensorWithDataAsOrtValue {

        private CreateTensorWithDataAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorWithDataAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorWithDataAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorWithDataAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorWithDataAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateTensorWithDataAsOrtValue$layout() {
        return CreateTensorWithDataAsOrtValue$LAYOUT;
    }

    private static final long CreateTensorWithDataAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorWithDataAsOrtValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateTensorWithDataAsOrtValue$offset() {
        return CreateTensorWithDataAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorWithDataAsOrtValue(MemorySegment struct) {
        return struct.get(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateTensorWithDataAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public final static class IsTensor {

        private IsTensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(IsTensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsTensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsTensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static final AddressLayout IsTensor$layout() {
        return IsTensor$LAYOUT;
    }

    private static final long IsTensor$OFFSET = $LAYOUT.byteOffset(groupElement("IsTensor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static final long IsTensor$offset() {
        return IsTensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment IsTensor(MemorySegment struct) {
        return struct.get(IsTensor$LAYOUT, IsTensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static void IsTensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsTensor$LAYOUT, IsTensor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public final static class GetTensorMutableData {

        private GetTensorMutableData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorMutableData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorMutableData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorMutableData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorMutableData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static final AddressLayout GetTensorMutableData$layout() {
        return GetTensorMutableData$LAYOUT;
    }

    private static final long GetTensorMutableData$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorMutableData"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static final long GetTensorMutableData$offset() {
        return GetTensorMutableData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static MemorySegment GetTensorMutableData(MemorySegment struct) {
        return struct.get(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static void GetTensorMutableData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public final static class FillStringTensor {

        private FillStringTensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FillStringTensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillStringTensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillStringTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillStringTensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout FillStringTensor$layout() {
        return FillStringTensor$LAYOUT;
    }

    private static final long FillStringTensor$OFFSET = $LAYOUT.byteOffset(groupElement("FillStringTensor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static final long FillStringTensor$offset() {
        return FillStringTensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static MemorySegment FillStringTensor(MemorySegment struct) {
        return struct.get(FillStringTensor$LAYOUT, FillStringTensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static void FillStringTensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillStringTensor$LAYOUT, FillStringTensor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public final static class GetStringTensorDataLength {

        private GetStringTensorDataLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStringTensorDataLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorDataLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorDataLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorDataLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static final AddressLayout GetStringTensorDataLength$layout() {
        return GetStringTensorDataLength$LAYOUT;
    }

    private static final long GetStringTensorDataLength$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorDataLength"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static final long GetStringTensorDataLength$offset() {
        return GetStringTensorDataLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetStringTensorDataLength(MemorySegment struct) {
        return struct.get(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static void GetStringTensorDataLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public final static class GetStringTensorContent {

        private GetStringTensorContent() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStringTensorContent.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorContent.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorContent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorContent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static final AddressLayout GetStringTensorContent$layout() {
        return GetStringTensorContent$LAYOUT;
    }

    private static final long GetStringTensorContent$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorContent"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static final long GetStringTensorContent$offset() {
        return GetStringTensorContent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static MemorySegment GetStringTensorContent(MemorySegment struct) {
        return struct.get(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static void GetStringTensorContent(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public final static class CastTypeInfoToTensorInfo {

        private CastTypeInfoToTensorInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CastTypeInfoToTensorInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToTensorInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToTensorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToTensorInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToTensorInfo$layout() {
        return CastTypeInfoToTensorInfo$LAYOUT;
    }

    private static final long CastTypeInfoToTensorInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToTensorInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long CastTypeInfoToTensorInfo$offset() {
        return CastTypeInfoToTensorInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToTensorInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void CastTypeInfoToTensorInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public final static class GetOnnxTypeFromTypeInfo {

        private GetOnnxTypeFromTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOnnxTypeFromTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOnnxTypeFromTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOnnxTypeFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOnnxTypeFromTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static final AddressLayout GetOnnxTypeFromTypeInfo$layout() {
        return GetOnnxTypeFromTypeInfo$LAYOUT;
    }

    private static final long GetOnnxTypeFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetOnnxTypeFromTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static final long GetOnnxTypeFromTypeInfo$offset() {
        return GetOnnxTypeFromTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static MemorySegment GetOnnxTypeFromTypeInfo(MemorySegment struct) {
        return struct.get(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static void GetOnnxTypeFromTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public final static class CreateTensorTypeAndShapeInfo {

        private CreateTensorTypeAndShapeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorTypeAndShapeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorTypeAndShapeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorTypeAndShapeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout CreateTensorTypeAndShapeInfo$layout() {
        return CreateTensorTypeAndShapeInfo$LAYOUT;
    }

    private static final long CreateTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorTypeAndShapeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long CreateTensorTypeAndShapeInfo$offset() {
        return CreateTensorTypeAndShapeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment CreateTensorTypeAndShapeInfo(MemorySegment struct) {
        return struct.get(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void CreateTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public final static class SetTensorElementType {

        private SetTensorElementType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetTensorElementType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetTensorElementType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetTensorElementType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static final AddressLayout SetTensorElementType$layout() {
        return SetTensorElementType$LAYOUT;
    }

    private static final long SetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement("SetTensorElementType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static final long SetTensorElementType$offset() {
        return SetTensorElementType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static MemorySegment SetTensorElementType(MemorySegment struct) {
        return struct.get(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static void SetTensorElementType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public final static class SetDimensions {

        private SetDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static final AddressLayout SetDimensions$layout() {
        return SetDimensions$LAYOUT;
    }

    private static final long SetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("SetDimensions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static final long SetDimensions$offset() {
        return SetDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static MemorySegment SetDimensions(MemorySegment struct) {
        return struct.get(SetDimensions$LAYOUT, SetDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static void SetDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetDimensions$LAYOUT, SetDimensions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public final static class GetTensorElementType {

        private GetTensorElementType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorElementType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorElementType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorElementType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final AddressLayout GetTensorElementType$layout() {
        return GetTensorElementType$LAYOUT;
    }

    private static final long GetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorElementType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final long GetTensorElementType$offset() {
        return GetTensorElementType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static MemorySegment GetTensorElementType(MemorySegment struct) {
        return struct.get(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static void GetTensorElementType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public final static class GetDimensionsCount {

        private GetDimensionsCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetDimensionsCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDimensionsCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDimensionsCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDimensionsCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final AddressLayout GetDimensionsCount$layout() {
        return GetDimensionsCount$LAYOUT;
    }

    private static final long GetDimensionsCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetDimensionsCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final long GetDimensionsCount$offset() {
        return GetDimensionsCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static MemorySegment GetDimensionsCount(MemorySegment struct) {
        return struct.get(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static void GetDimensionsCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public final static class GetDimensions {

        private GetDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static final AddressLayout GetDimensions$layout() {
        return GetDimensions$LAYOUT;
    }

    private static final long GetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("GetDimensions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static final long GetDimensions$offset() {
        return GetDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static MemorySegment GetDimensions(MemorySegment struct) {
        return struct.get(GetDimensions$LAYOUT, GetDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static void GetDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDimensions$LAYOUT, GetDimensions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public final static class GetSymbolicDimensions {

        private GetSymbolicDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSymbolicDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSymbolicDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSymbolicDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final AddressLayout GetSymbolicDimensions$layout() {
        return GetSymbolicDimensions$LAYOUT;
    }

    private static final long GetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("GetSymbolicDimensions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final long GetSymbolicDimensions$offset() {
        return GetSymbolicDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static MemorySegment GetSymbolicDimensions(MemorySegment struct) {
        return struct.get(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static void GetSymbolicDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public final static class GetTensorShapeElementCount {

        private GetTensorShapeElementCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorShapeElementCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorShapeElementCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorShapeElementCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorShapeElementCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final AddressLayout GetTensorShapeElementCount$layout() {
        return GetTensorShapeElementCount$LAYOUT;
    }

    private static final long GetTensorShapeElementCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorShapeElementCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final long GetTensorShapeElementCount$offset() {
        return GetTensorShapeElementCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static MemorySegment GetTensorShapeElementCount(MemorySegment struct) {
        return struct.get(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static void GetTensorShapeElementCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public final static class GetTensorTypeAndShape {

        private GetTensorTypeAndShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorTypeAndShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorTypeAndShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorTypeAndShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout GetTensorTypeAndShape$layout() {
        return GetTensorTypeAndShape$LAYOUT;
    }

    private static final long GetTensorTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorTypeAndShape"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long GetTensorTypeAndShape$offset() {
        return GetTensorTypeAndShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetTensorTypeAndShape(MemorySegment struct) {
        return struct.get(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void GetTensorTypeAndShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public final static class GetTypeInfo {

        private GetTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetTypeInfo$layout() {
        return GetTypeInfo$LAYOUT;
    }

    private static final long GetTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static final long GetTypeInfo$offset() {
        return GetTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetTypeInfo(MemorySegment struct) {
        return struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static void GetTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public final static class GetValueType {

        private GetValueType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetValueType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValueType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValueType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static final AddressLayout GetValueType$layout() {
        return GetValueType$LAYOUT;
    }

    private static final long GetValueType$OFFSET = $LAYOUT.byteOffset(groupElement("GetValueType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static final long GetValueType$offset() {
        return GetValueType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static MemorySegment GetValueType(MemorySegment struct) {
        return struct.get(GetValueType$LAYOUT, GetValueType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static void GetValueType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValueType$LAYOUT, GetValueType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public final static class CreateMemoryInfo {

        private CreateMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout CreateMemoryInfo$layout() {
        return CreateMemoryInfo$LAYOUT;
    }

    private static final long CreateMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateMemoryInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final long CreateMemoryInfo$offset() {
        return CreateMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateMemoryInfo(MemorySegment struct) {
        return struct.get(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static void CreateMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public final static class CreateCpuMemoryInfo {

        private CreateCpuMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateCpuMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCpuMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCpuMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCpuMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout CreateCpuMemoryInfo$layout() {
        return CreateCpuMemoryInfo$LAYOUT;
    }

    private static final long CreateCpuMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCpuMemoryInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final long CreateCpuMemoryInfo$offset() {
        return CreateCpuMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateCpuMemoryInfo(MemorySegment struct) {
        return struct.get(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static void CreateCpuMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public final static class CompareMemoryInfo {

        private CompareMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CompareMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CompareMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CompareMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CompareMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static final AddressLayout CompareMemoryInfo$layout() {
        return CompareMemoryInfo$LAYOUT;
    }

    private static final long CompareMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CompareMemoryInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static final long CompareMemoryInfo$offset() {
        return CompareMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static MemorySegment CompareMemoryInfo(MemorySegment struct) {
        return struct.get(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static void CompareMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public final static class MemoryInfoGetName {

        private MemoryInfoGetName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static final AddressLayout MemoryInfoGetName$layout() {
        return MemoryInfoGetName$LAYOUT;
    }

    private static final long MemoryInfoGetName$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static final long MemoryInfoGetName$offset() {
        return MemoryInfoGetName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static MemorySegment MemoryInfoGetName(MemorySegment struct) {
        return struct.get(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static void MemoryInfoGetName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public final static class MemoryInfoGetId {

        private MemoryInfoGetId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static final AddressLayout MemoryInfoGetId$layout() {
        return MemoryInfoGetId$LAYOUT;
    }

    private static final long MemoryInfoGetId$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static final long MemoryInfoGetId$offset() {
        return MemoryInfoGetId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static MemorySegment MemoryInfoGetId(MemorySegment struct) {
        return struct.get(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static void MemoryInfoGetId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public final static class MemoryInfoGetMemType {

        private MemoryInfoGetMemType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetMemType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetMemType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetMemType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static final AddressLayout MemoryInfoGetMemType$layout() {
        return MemoryInfoGetMemType$LAYOUT;
    }

    private static final long MemoryInfoGetMemType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetMemType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static final long MemoryInfoGetMemType$offset() {
        return MemoryInfoGetMemType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static MemorySegment MemoryInfoGetMemType(MemorySegment struct) {
        return struct.get(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static void MemoryInfoGetMemType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public final static class MemoryInfoGetType {

        private MemoryInfoGetType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static final AddressLayout MemoryInfoGetType$layout() {
        return MemoryInfoGetType$LAYOUT;
    }

    private static final long MemoryInfoGetType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static final long MemoryInfoGetType$offset() {
        return MemoryInfoGetType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static MemorySegment MemoryInfoGetType(MemorySegment struct) {
        return struct.get(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static void MemoryInfoGetType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public final static class AllocatorAlloc {

        private AllocatorAlloc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AllocatorAlloc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorAlloc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorAlloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorAlloc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static final AddressLayout AllocatorAlloc$layout() {
        return AllocatorAlloc$LAYOUT;
    }

    private static final long AllocatorAlloc$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorAlloc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static final long AllocatorAlloc$offset() {
        return AllocatorAlloc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static MemorySegment AllocatorAlloc(MemorySegment struct) {
        return struct.get(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static void AllocatorAlloc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public final static class AllocatorFree {

        private AllocatorFree() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AllocatorFree.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorFree.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorFree$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorFree"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static final AddressLayout AllocatorFree$layout() {
        return AllocatorFree$LAYOUT;
    }

    private static final long AllocatorFree$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorFree"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static final long AllocatorFree$offset() {
        return AllocatorFree$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static MemorySegment AllocatorFree(MemorySegment struct) {
        return struct.get(AllocatorFree$LAYOUT, AllocatorFree$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static void AllocatorFree(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorFree$LAYOUT, AllocatorFree$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public final static class AllocatorGetInfo {

        private AllocatorGetInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AllocatorGetInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorGetInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorGetInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorGetInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout AllocatorGetInfo$layout() {
        return AllocatorGetInfo$LAYOUT;
    }

    private static final long AllocatorGetInfo$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorGetInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static final long AllocatorGetInfo$offset() {
        return AllocatorGetInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static MemorySegment AllocatorGetInfo(MemorySegment struct) {
        return struct.get(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static void AllocatorGetInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public final static class GetAllocatorWithDefaultOptions {

        private GetAllocatorWithDefaultOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetAllocatorWithDefaultOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllocatorWithDefaultOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllocatorWithDefaultOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllocatorWithDefaultOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static final AddressLayout GetAllocatorWithDefaultOptions$layout() {
        return GetAllocatorWithDefaultOptions$LAYOUT;
    }

    private static final long GetAllocatorWithDefaultOptions$OFFSET = $LAYOUT.byteOffset(groupElement("GetAllocatorWithDefaultOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static final long GetAllocatorWithDefaultOptions$offset() {
        return GetAllocatorWithDefaultOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static MemorySegment GetAllocatorWithDefaultOptions(MemorySegment struct) {
        return struct.get(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static void GetAllocatorWithDefaultOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public final static class AddFreeDimensionOverride {

        private AddFreeDimensionOverride() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddFreeDimensionOverride.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddFreeDimensionOverride.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddFreeDimensionOverride$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddFreeDimensionOverride"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final AddressLayout AddFreeDimensionOverride$layout() {
        return AddFreeDimensionOverride$LAYOUT;
    }

    private static final long AddFreeDimensionOverride$OFFSET = $LAYOUT.byteOffset(groupElement("AddFreeDimensionOverride"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final long AddFreeDimensionOverride$offset() {
        return AddFreeDimensionOverride$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static MemorySegment AddFreeDimensionOverride(MemorySegment struct) {
        return struct.get(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static void AddFreeDimensionOverride(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public final static class GetValue {

        private GetValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static final AddressLayout GetValue$layout() {
        return GetValue$LAYOUT;
    }

    private static final long GetValue$OFFSET = $LAYOUT.byteOffset(groupElement("GetValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static final long GetValue$offset() {
        return GetValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static MemorySegment GetValue(MemorySegment struct) {
        return struct.get(GetValue$LAYOUT, GetValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static void GetValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValue$LAYOUT, GetValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public final static class GetValueCount {

        private GetValueCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetValueCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValueCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValueCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValueCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static final AddressLayout GetValueCount$layout() {
        return GetValueCount$LAYOUT;
    }

    private static final long GetValueCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetValueCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static final long GetValueCount$offset() {
        return GetValueCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetValueCount(MemorySegment struct) {
        return struct.get(GetValueCount$LAYOUT, GetValueCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static void GetValueCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValueCount$LAYOUT, GetValueCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public final static class CreateValue {

        private CreateValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateValue$layout() {
        return CreateValue$LAYOUT;
    }

    private static final long CreateValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static final long CreateValue$offset() {
        return CreateValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static MemorySegment CreateValue(MemorySegment struct) {
        return struct.get(CreateValue$LAYOUT, CreateValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static void CreateValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateValue$LAYOUT, CreateValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public final static class CreateOpaqueValue {

        private CreateOpaqueValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateOpaqueValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOpaqueValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOpaqueValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static final AddressLayout CreateOpaqueValue$layout() {
        return CreateOpaqueValue$LAYOUT;
    }

    private static final long CreateOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateOpaqueValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static final long CreateOpaqueValue$offset() {
        return CreateOpaqueValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment CreateOpaqueValue(MemorySegment struct) {
        return struct.get(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static void CreateOpaqueValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public final static class GetOpaqueValue {

        private GetOpaqueValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOpaqueValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOpaqueValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOpaqueValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static final AddressLayout GetOpaqueValue$layout() {
        return GetOpaqueValue$LAYOUT;
    }

    private static final long GetOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement("GetOpaqueValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static final long GetOpaqueValue$offset() {
        return GetOpaqueValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static MemorySegment GetOpaqueValue(MemorySegment struct) {
        return struct.get(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static void GetOpaqueValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public final static class KernelInfoGetAttribute_float {

        private KernelInfoGetAttribute_float() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAttribute_float.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_float.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_float"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_float$layout() {
        return KernelInfoGetAttribute_float$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_float$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_float"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static final long KernelInfoGetAttribute_float$offset() {
        return KernelInfoGetAttribute_float$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_float(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static void KernelInfoGetAttribute_float(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public final static class KernelInfoGetAttribute_int64 {

        private KernelInfoGetAttribute_int64() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAttribute_int64.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_int64.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_int64"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_int64$layout() {
        return KernelInfoGetAttribute_int64$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_int64$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_int64"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static final long KernelInfoGetAttribute_int64$offset() {
        return KernelInfoGetAttribute_int64$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_int64(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static void KernelInfoGetAttribute_int64(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public final static class KernelInfoGetAttribute_string {

        private KernelInfoGetAttribute_string() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAttribute_string.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_string.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_string"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_string$layout() {
        return KernelInfoGetAttribute_string$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_string$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_string"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static final long KernelInfoGetAttribute_string$offset() {
        return KernelInfoGetAttribute_string$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_string(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static void KernelInfoGetAttribute_string(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public final static class KernelContext_GetInputCount {

        private KernelContext_GetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final AddressLayout KernelContext_GetInputCount$layout() {
        return KernelContext_GetInputCount$LAYOUT;
    }

    private static final long KernelContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetInputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final long KernelContext_GetInputCount$offset() {
        return KernelContext_GetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static MemorySegment KernelContext_GetInputCount(MemorySegment struct) {
        return struct.get(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static void KernelContext_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public final static class KernelContext_GetOutputCount {

        private KernelContext_GetOutputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetOutputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetOutputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final AddressLayout KernelContext_GetOutputCount$layout() {
        return KernelContext_GetOutputCount$LAYOUT;
    }

    private static final long KernelContext_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetOutputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final long KernelContext_GetOutputCount$offset() {
        return KernelContext_GetOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static MemorySegment KernelContext_GetOutputCount(MemorySegment struct) {
        return struct.get(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static void KernelContext_GetOutputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public final static class KernelContext_GetInput {

        private KernelContext_GetInput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetInput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetInput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetInput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static final AddressLayout KernelContext_GetInput$layout() {
        return KernelContext_GetInput$LAYOUT;
    }

    private static final long KernelContext_GetInput$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetInput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static final long KernelContext_GetInput$offset() {
        return KernelContext_GetInput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static MemorySegment KernelContext_GetInput(MemorySegment struct) {
        return struct.get(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static void KernelContext_GetInput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public final static class KernelContext_GetOutput {

        private KernelContext_GetOutput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetOutput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetOutput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetOutput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static final AddressLayout KernelContext_GetOutput$layout() {
        return KernelContext_GetOutput$LAYOUT;
    }

    private static final long KernelContext_GetOutput$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetOutput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static final long KernelContext_GetOutput$offset() {
        return KernelContext_GetOutput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment KernelContext_GetOutput(MemorySegment struct) {
        return struct.get(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static void KernelContext_GetOutput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public final static class ReleaseEnv {

        private ReleaseEnv() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseEnv.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseEnv.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseEnv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static final AddressLayout ReleaseEnv$layout() {
        return ReleaseEnv$LAYOUT;
    }

    private static final long ReleaseEnv$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseEnv"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static final long ReleaseEnv$offset() {
        return ReleaseEnv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static MemorySegment ReleaseEnv(MemorySegment struct) {
        return struct.get(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static void ReleaseEnv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public final static class ReleaseStatus {

        private ReleaseStatus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseStatus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseStatus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static final AddressLayout ReleaseStatus$layout() {
        return ReleaseStatus$LAYOUT;
    }

    private static final long ReleaseStatus$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseStatus"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static final long ReleaseStatus$offset() {
        return ReleaseStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static MemorySegment ReleaseStatus(MemorySegment struct) {
        return struct.get(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static void ReleaseStatus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public final static class ReleaseMemoryInfo {

        private ReleaseMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout ReleaseMemoryInfo$layout() {
        return ReleaseMemoryInfo$LAYOUT;
    }

    private static final long ReleaseMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseMemoryInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static final long ReleaseMemoryInfo$offset() {
        return ReleaseMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static MemorySegment ReleaseMemoryInfo(MemorySegment struct) {
        return struct.get(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static void ReleaseMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public final static class ReleaseSession {

        private ReleaseSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static final AddressLayout ReleaseSession$layout() {
        return ReleaseSession$LAYOUT;
    }

    private static final long ReleaseSession$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSession"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static final long ReleaseSession$offset() {
        return ReleaseSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static MemorySegment ReleaseSession(MemorySegment struct) {
        return struct.get(ReleaseSession$LAYOUT, ReleaseSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static void ReleaseSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSession$LAYOUT, ReleaseSession$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public final static class ReleaseValue {

        private ReleaseValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static final AddressLayout ReleaseValue$layout() {
        return ReleaseValue$LAYOUT;
    }

    private static final long ReleaseValue$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static final long ReleaseValue$offset() {
        return ReleaseValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static MemorySegment ReleaseValue(MemorySegment struct) {
        return struct.get(ReleaseValue$LAYOUT, ReleaseValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static void ReleaseValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseValue$LAYOUT, ReleaseValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public final static class ReleaseRunOptions {

        private ReleaseRunOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseRunOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseRunOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseRunOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static final AddressLayout ReleaseRunOptions$layout() {
        return ReleaseRunOptions$LAYOUT;
    }

    private static final long ReleaseRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseRunOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static final long ReleaseRunOptions$offset() {
        return ReleaseRunOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static MemorySegment ReleaseRunOptions(MemorySegment struct) {
        return struct.get(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static void ReleaseRunOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public final static class ReleaseTypeInfo {

        private ReleaseTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static final AddressLayout ReleaseTypeInfo$layout() {
        return ReleaseTypeInfo$LAYOUT;
    }

    private static final long ReleaseTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static final long ReleaseTypeInfo$offset() {
        return ReleaseTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static MemorySegment ReleaseTypeInfo(MemorySegment struct) {
        return struct.get(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static void ReleaseTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public final static class ReleaseTensorTypeAndShapeInfo {

        private ReleaseTensorTypeAndShapeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseTensorTypeAndShapeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTensorTypeAndShapeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTensorTypeAndShapeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final AddressLayout ReleaseTensorTypeAndShapeInfo$layout() {
        return ReleaseTensorTypeAndShapeInfo$LAYOUT;
    }

    private static final long ReleaseTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseTensorTypeAndShapeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final long ReleaseTensorTypeAndShapeInfo$offset() {
        return ReleaseTensorTypeAndShapeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static MemorySegment ReleaseTensorTypeAndShapeInfo(MemorySegment struct) {
        return struct.get(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static void ReleaseTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public final static class ReleaseSessionOptions {

        private ReleaseSessionOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseSessionOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSessionOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSessionOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout ReleaseSessionOptions$layout() {
        return ReleaseSessionOptions$LAYOUT;
    }

    private static final long ReleaseSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSessionOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static final long ReleaseSessionOptions$offset() {
        return ReleaseSessionOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment ReleaseSessionOptions(MemorySegment struct) {
        return struct.get(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static void ReleaseSessionOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public final static class ReleaseCustomOpDomain {

        private ReleaseCustomOpDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseCustomOpDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCustomOpDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCustomOpDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static final AddressLayout ReleaseCustomOpDomain$layout() {
        return ReleaseCustomOpDomain$LAYOUT;
    }

    private static final long ReleaseCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseCustomOpDomain"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static final long ReleaseCustomOpDomain$offset() {
        return ReleaseCustomOpDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static MemorySegment ReleaseCustomOpDomain(MemorySegment struct) {
        return struct.get(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static void ReleaseCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public final static class GetDenotationFromTypeInfo {

        private GetDenotationFromTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetDenotationFromTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDenotationFromTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDenotationFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDenotationFromTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static final AddressLayout GetDenotationFromTypeInfo$layout() {
        return GetDenotationFromTypeInfo$LAYOUT;
    }

    private static final long GetDenotationFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetDenotationFromTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static final long GetDenotationFromTypeInfo$offset() {
        return GetDenotationFromTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static MemorySegment GetDenotationFromTypeInfo(MemorySegment struct) {
        return struct.get(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static void GetDenotationFromTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public final static class CastTypeInfoToMapTypeInfo {

        private CastTypeInfoToMapTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CastTypeInfoToMapTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToMapTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToMapTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToMapTypeInfo$layout() {
        return CastTypeInfoToMapTypeInfo$LAYOUT;
    }

    private static final long CastTypeInfoToMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToMapTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static final long CastTypeInfoToMapTypeInfo$offset() {
        return CastTypeInfoToMapTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToMapTypeInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static void CastTypeInfoToMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public final static class CastTypeInfoToSequenceTypeInfo {

        private CastTypeInfoToSequenceTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CastTypeInfoToSequenceTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToSequenceTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToSequenceTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToSequenceTypeInfo$layout() {
        return CastTypeInfoToSequenceTypeInfo$LAYOUT;
    }

    private static final long CastTypeInfoToSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToSequenceTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static final long CastTypeInfoToSequenceTypeInfo$offset() {
        return CastTypeInfoToSequenceTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToSequenceTypeInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static void CastTypeInfoToSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public final static class GetMapKeyType {

        private GetMapKeyType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetMapKeyType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMapKeyType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMapKeyType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMapKeyType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final AddressLayout GetMapKeyType$layout() {
        return GetMapKeyType$LAYOUT;
    }

    private static final long GetMapKeyType$OFFSET = $LAYOUT.byteOffset(groupElement("GetMapKeyType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final long GetMapKeyType$offset() {
        return GetMapKeyType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static MemorySegment GetMapKeyType(MemorySegment struct) {
        return struct.get(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static void GetMapKeyType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public final static class GetMapValueType {

        private GetMapValueType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetMapValueType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMapValueType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMapValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMapValueType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetMapValueType$layout() {
        return GetMapValueType$LAYOUT;
    }

    private static final long GetMapValueType$OFFSET = $LAYOUT.byteOffset(groupElement("GetMapValueType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long GetMapValueType$offset() {
        return GetMapValueType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetMapValueType(MemorySegment struct) {
        return struct.get(GetMapValueType$LAYOUT, GetMapValueType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void GetMapValueType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMapValueType$LAYOUT, GetMapValueType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public final static class GetSequenceElementType {

        private GetSequenceElementType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSequenceElementType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSequenceElementType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSequenceElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSequenceElementType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetSequenceElementType$layout() {
        return GetSequenceElementType$LAYOUT;
    }

    private static final long GetSequenceElementType$OFFSET = $LAYOUT.byteOffset(groupElement("GetSequenceElementType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long GetSequenceElementType$offset() {
        return GetSequenceElementType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetSequenceElementType(MemorySegment struct) {
        return struct.get(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void GetSequenceElementType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public final static class ReleaseMapTypeInfo {

        private ReleaseMapTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseMapTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseMapTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseMapTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static final AddressLayout ReleaseMapTypeInfo$layout() {
        return ReleaseMapTypeInfo$LAYOUT;
    }

    private static final long ReleaseMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseMapTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static final long ReleaseMapTypeInfo$offset() {
        return ReleaseMapTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static MemorySegment ReleaseMapTypeInfo(MemorySegment struct) {
        return struct.get(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static void ReleaseMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public final static class ReleaseSequenceTypeInfo {

        private ReleaseSequenceTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseSequenceTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSequenceTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSequenceTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static final AddressLayout ReleaseSequenceTypeInfo$layout() {
        return ReleaseSequenceTypeInfo$LAYOUT;
    }

    private static final long ReleaseSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSequenceTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static final long ReleaseSequenceTypeInfo$offset() {
        return ReleaseSequenceTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static MemorySegment ReleaseSequenceTypeInfo(MemorySegment struct) {
        return struct.get(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static void ReleaseSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public final static class SessionEndProfiling {

        private SessionEndProfiling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionEndProfiling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionEndProfiling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionEndProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionEndProfiling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionEndProfiling$layout() {
        return SessionEndProfiling$LAYOUT;
    }

    private static final long SessionEndProfiling$OFFSET = $LAYOUT.byteOffset(groupElement("SessionEndProfiling"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static final long SessionEndProfiling$offset() {
        return SessionEndProfiling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionEndProfiling(MemorySegment struct) {
        return struct.get(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static void SessionEndProfiling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public final static class SessionGetModelMetadata {

        private SessionGetModelMetadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetModelMetadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetModelMetadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetModelMetadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static final AddressLayout SessionGetModelMetadata$layout() {
        return SessionGetModelMetadata$LAYOUT;
    }

    private static final long SessionGetModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetModelMetadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static final long SessionGetModelMetadata$offset() {
        return SessionGetModelMetadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static MemorySegment SessionGetModelMetadata(MemorySegment struct) {
        return struct.get(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static void SessionGetModelMetadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public final static class ModelMetadataGetProducerName {

        private ModelMetadataGetProducerName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetProducerName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetProducerName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetProducerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetProducerName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetProducerName$layout() {
        return ModelMetadataGetProducerName$LAYOUT;
    }

    private static final long ModelMetadataGetProducerName$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetProducerName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetProducerName$offset() {
        return ModelMetadataGetProducerName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetProducerName(MemorySegment struct) {
        return struct.get(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetProducerName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public final static class ModelMetadataGetGraphName {

        private ModelMetadataGetGraphName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetGraphName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetGraphName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetGraphName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetGraphName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetGraphName$layout() {
        return ModelMetadataGetGraphName$LAYOUT;
    }

    private static final long ModelMetadataGetGraphName$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetGraphName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetGraphName$offset() {
        return ModelMetadataGetGraphName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetGraphName(MemorySegment struct) {
        return struct.get(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetGraphName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public final static class ModelMetadataGetDomain {

        private ModelMetadataGetDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetDomain$layout() {
        return ModelMetadataGetDomain$LAYOUT;
    }

    private static final long ModelMetadataGetDomain$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetDomain"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetDomain$offset() {
        return ModelMetadataGetDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetDomain(MemorySegment struct) {
        return struct.get(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public final static class ModelMetadataGetDescription {

        private ModelMetadataGetDescription() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetDescription.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetDescription.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetDescription"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetDescription$layout() {
        return ModelMetadataGetDescription$LAYOUT;
    }

    private static final long ModelMetadataGetDescription$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetDescription"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetDescription$offset() {
        return ModelMetadataGetDescription$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetDescription(MemorySegment struct) {
        return struct.get(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetDescription(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public final static class ModelMetadataLookupCustomMetadataMap {

        private ModelMetadataLookupCustomMetadataMap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataLookupCustomMetadataMap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataLookupCustomMetadataMap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataLookupCustomMetadataMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataLookupCustomMetadataMap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataLookupCustomMetadataMap$layout() {
        return ModelMetadataLookupCustomMetadataMap$LAYOUT;
    }

    private static final long ModelMetadataLookupCustomMetadataMap$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataLookupCustomMetadataMap"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static final long ModelMetadataLookupCustomMetadataMap$offset() {
        return ModelMetadataLookupCustomMetadataMap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static MemorySegment ModelMetadataLookupCustomMetadataMap(MemorySegment struct) {
        return struct.get(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static void ModelMetadataLookupCustomMetadataMap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public final static class ModelMetadataGetVersion {

        private ModelMetadataGetVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static final AddressLayout ModelMetadataGetVersion$layout() {
        return ModelMetadataGetVersion$LAYOUT;
    }

    private static final long ModelMetadataGetVersion$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetVersion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static final long ModelMetadataGetVersion$offset() {
        return ModelMetadataGetVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static MemorySegment ModelMetadataGetVersion(MemorySegment struct) {
        return struct.get(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static void ModelMetadataGetVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public final static class ReleaseModelMetadata {

        private ReleaseModelMetadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseModelMetadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseModelMetadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseModelMetadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static final AddressLayout ReleaseModelMetadata$layout() {
        return ReleaseModelMetadata$LAYOUT;
    }

    private static final long ReleaseModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseModelMetadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static final long ReleaseModelMetadata$offset() {
        return ReleaseModelMetadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static MemorySegment ReleaseModelMetadata(MemorySegment struct) {
        return struct.get(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static void ReleaseModelMetadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public final static class CreateEnvWithGlobalThreadPools {

        private CreateEnvWithGlobalThreadPools() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateEnvWithGlobalThreadPools.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnvWithGlobalThreadPools.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnvWithGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnvWithGlobalThreadPools"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnvWithGlobalThreadPools$layout() {
        return CreateEnvWithGlobalThreadPools$LAYOUT;
    }

    private static final long CreateEnvWithGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnvWithGlobalThreadPools"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final long CreateEnvWithGlobalThreadPools$offset() {
        return CreateEnvWithGlobalThreadPools$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithGlobalThreadPools(MemorySegment struct) {
        return struct.get(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static void CreateEnvWithGlobalThreadPools(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public final static class DisablePerSessionThreads {

        private DisablePerSessionThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(DisablePerSessionThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisablePerSessionThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisablePerSessionThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisablePerSessionThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisablePerSessionThreads$layout() {
        return DisablePerSessionThreads$LAYOUT;
    }

    private static final long DisablePerSessionThreads$OFFSET = $LAYOUT.byteOffset(groupElement("DisablePerSessionThreads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static final long DisablePerSessionThreads$offset() {
        return DisablePerSessionThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisablePerSessionThreads(MemorySegment struct) {
        return struct.get(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static void DisablePerSessionThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public final static class CreateThreadingOptions {

        private CreateThreadingOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateThreadingOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateThreadingOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateThreadingOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static final AddressLayout CreateThreadingOptions$layout() {
        return CreateThreadingOptions$LAYOUT;
    }

    private static final long CreateThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateThreadingOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static final long CreateThreadingOptions$offset() {
        return CreateThreadingOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static MemorySegment CreateThreadingOptions(MemorySegment struct) {
        return struct.get(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static void CreateThreadingOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public final static class ReleaseThreadingOptions {

        private ReleaseThreadingOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseThreadingOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseThreadingOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseThreadingOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static final AddressLayout ReleaseThreadingOptions$layout() {
        return ReleaseThreadingOptions$LAYOUT;
    }

    private static final long ReleaseThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseThreadingOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static final long ReleaseThreadingOptions$offset() {
        return ReleaseThreadingOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static MemorySegment ReleaseThreadingOptions(MemorySegment struct) {
        return struct.get(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static void ReleaseThreadingOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public final static class ModelMetadataGetCustomMetadataMapKeys {

        private ModelMetadataGetCustomMetadataMapKeys() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetCustomMetadataMapKeys.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetCustomMetadataMapKeys.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetCustomMetadataMapKeys"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$layout() {
        return ModelMetadataGetCustomMetadataMapKeys$LAYOUT;
    }

    private static final long ModelMetadataGetCustomMetadataMapKeys$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetCustomMetadataMapKeys"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static final long ModelMetadataGetCustomMetadataMapKeys$offset() {
        return ModelMetadataGetCustomMetadataMapKeys$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static MemorySegment ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct) {
        return struct.get(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static void ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public final static class AddFreeDimensionOverrideByName {

        private AddFreeDimensionOverrideByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddFreeDimensionOverrideByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddFreeDimensionOverrideByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddFreeDimensionOverrideByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddFreeDimensionOverrideByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final AddressLayout AddFreeDimensionOverrideByName$layout() {
        return AddFreeDimensionOverrideByName$LAYOUT;
    }

    private static final long AddFreeDimensionOverrideByName$OFFSET = $LAYOUT.byteOffset(groupElement("AddFreeDimensionOverrideByName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final long AddFreeDimensionOverrideByName$offset() {
        return AddFreeDimensionOverrideByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static MemorySegment AddFreeDimensionOverrideByName(MemorySegment struct) {
        return struct.get(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static void AddFreeDimensionOverrideByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public final static class GetAvailableProviders {

        private GetAvailableProviders() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetAvailableProviders.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAvailableProviders.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAvailableProviders"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static final AddressLayout GetAvailableProviders$layout() {
        return GetAvailableProviders$LAYOUT;
    }

    private static final long GetAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement("GetAvailableProviders"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static final long GetAvailableProviders$offset() {
        return GetAvailableProviders$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static MemorySegment GetAvailableProviders(MemorySegment struct) {
        return struct.get(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static void GetAvailableProviders(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public final static class ReleaseAvailableProviders {

        private ReleaseAvailableProviders() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseAvailableProviders.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseAvailableProviders.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseAvailableProviders"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static final AddressLayout ReleaseAvailableProviders$layout() {
        return ReleaseAvailableProviders$LAYOUT;
    }

    private static final long ReleaseAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseAvailableProviders"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static final long ReleaseAvailableProviders$offset() {
        return ReleaseAvailableProviders$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static MemorySegment ReleaseAvailableProviders(MemorySegment struct) {
        return struct.get(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static void ReleaseAvailableProviders(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public final static class GetStringTensorElementLength {

        private GetStringTensorElementLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStringTensorElementLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorElementLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorElementLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorElementLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static final AddressLayout GetStringTensorElementLength$layout() {
        return GetStringTensorElementLength$LAYOUT;
    }

    private static final long GetStringTensorElementLength$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorElementLength"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static final long GetStringTensorElementLength$offset() {
        return GetStringTensorElementLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static MemorySegment GetStringTensorElementLength(MemorySegment struct) {
        return struct.get(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static void GetStringTensorElementLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public final static class GetStringTensorElement {

        private GetStringTensorElement() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStringTensorElement.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorElement.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorElement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static final AddressLayout GetStringTensorElement$layout() {
        return GetStringTensorElement$LAYOUT;
    }

    private static final long GetStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorElement"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static final long GetStringTensorElement$offset() {
        return GetStringTensorElement$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static MemorySegment GetStringTensorElement(MemorySegment struct) {
        return struct.get(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static void GetStringTensorElement(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public final static class FillStringTensorElement {

        private FillStringTensorElement() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FillStringTensorElement.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillStringTensorElement.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillStringTensorElement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static final AddressLayout FillStringTensorElement$layout() {
        return FillStringTensorElement$LAYOUT;
    }

    private static final long FillStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement("FillStringTensorElement"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static final long FillStringTensorElement$offset() {
        return FillStringTensorElement$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static MemorySegment FillStringTensorElement(MemorySegment struct) {
        return struct.get(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static void FillStringTensorElement(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public final static class AddSessionConfigEntry {

        private AddSessionConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddSessionConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddSessionConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddSessionConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static final AddressLayout AddSessionConfigEntry$layout() {
        return AddSessionConfigEntry$LAYOUT;
    }

    private static final long AddSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("AddSessionConfigEntry"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static final long AddSessionConfigEntry$offset() {
        return AddSessionConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static MemorySegment AddSessionConfigEntry(MemorySegment struct) {
        return struct.get(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static void AddSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public final static class CreateAllocator {

        private CreateAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final AddressLayout CreateAllocator$layout() {
        return CreateAllocator$LAYOUT;
    }

    private static final long CreateAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("CreateAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final long CreateAllocator$offset() {
        return CreateAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment CreateAllocator(MemorySegment struct) {
        return struct.get(CreateAllocator$LAYOUT, CreateAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static void CreateAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateAllocator$LAYOUT, CreateAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public final static class ReleaseAllocator {

        private ReleaseAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static final AddressLayout ReleaseAllocator$layout() {
        return ReleaseAllocator$LAYOUT;
    }

    private static final long ReleaseAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static final long ReleaseAllocator$offset() {
        return ReleaseAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static MemorySegment ReleaseAllocator(MemorySegment struct) {
        return struct.get(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static void ReleaseAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public final static class RunWithBinding {

        private RunWithBinding() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunWithBinding.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunWithBinding.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunWithBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunWithBinding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static final AddressLayout RunWithBinding$layout() {
        return RunWithBinding$LAYOUT;
    }

    private static final long RunWithBinding$OFFSET = $LAYOUT.byteOffset(groupElement("RunWithBinding"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static final long RunWithBinding$offset() {
        return RunWithBinding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static MemorySegment RunWithBinding(MemorySegment struct) {
        return struct.get(RunWithBinding$LAYOUT, RunWithBinding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static void RunWithBinding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunWithBinding$LAYOUT, RunWithBinding$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public final static class CreateIoBinding {

        private CreateIoBinding() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateIoBinding.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateIoBinding.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateIoBinding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static final AddressLayout CreateIoBinding$layout() {
        return CreateIoBinding$LAYOUT;
    }

    private static final long CreateIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement("CreateIoBinding"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static final long CreateIoBinding$offset() {
        return CreateIoBinding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static MemorySegment CreateIoBinding(MemorySegment struct) {
        return struct.get(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static void CreateIoBinding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public final static class ReleaseIoBinding {

        private ReleaseIoBinding() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseIoBinding.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseIoBinding.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseIoBinding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout ReleaseIoBinding$layout() {
        return ReleaseIoBinding$LAYOUT;
    }

    private static final long ReleaseIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseIoBinding"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static final long ReleaseIoBinding$offset() {
        return ReleaseIoBinding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static MemorySegment ReleaseIoBinding(MemorySegment struct) {
        return struct.get(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static void ReleaseIoBinding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public final static class BindInput {

        private BindInput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(BindInput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(BindInput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout BindInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("BindInput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final AddressLayout BindInput$layout() {
        return BindInput$LAYOUT;
    }

    private static final long BindInput$OFFSET = $LAYOUT.byteOffset(groupElement("BindInput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final long BindInput$offset() {
        return BindInput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment BindInput(MemorySegment struct) {
        return struct.get(BindInput$LAYOUT, BindInput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static void BindInput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(BindInput$LAYOUT, BindInput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public final static class BindOutput {

        private BindOutput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(BindOutput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(BindOutput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout BindOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("BindOutput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final AddressLayout BindOutput$layout() {
        return BindOutput$LAYOUT;
    }

    private static final long BindOutput$OFFSET = $LAYOUT.byteOffset(groupElement("BindOutput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final long BindOutput$offset() {
        return BindOutput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment BindOutput(MemorySegment struct) {
        return struct.get(BindOutput$LAYOUT, BindOutput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static void BindOutput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(BindOutput$LAYOUT, BindOutput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public final static class BindOutputToDevice {

        private BindOutputToDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(BindOutputToDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(BindOutputToDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout BindOutputToDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("BindOutputToDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout BindOutputToDevice$layout() {
        return BindOutputToDevice$LAYOUT;
    }

    private static final long BindOutputToDevice$OFFSET = $LAYOUT.byteOffset(groupElement("BindOutputToDevice"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static final long BindOutputToDevice$offset() {
        return BindOutputToDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment BindOutputToDevice(MemorySegment struct) {
        return struct.get(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static void BindOutputToDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public final static class GetBoundOutputNames {

        private GetBoundOutputNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetBoundOutputNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBoundOutputNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBoundOutputNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBoundOutputNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static final AddressLayout GetBoundOutputNames$layout() {
        return GetBoundOutputNames$LAYOUT;
    }

    private static final long GetBoundOutputNames$OFFSET = $LAYOUT.byteOffset(groupElement("GetBoundOutputNames"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static final long GetBoundOutputNames$offset() {
        return GetBoundOutputNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static MemorySegment GetBoundOutputNames(MemorySegment struct) {
        return struct.get(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static void GetBoundOutputNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public final static class GetBoundOutputValues {

        private GetBoundOutputValues() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetBoundOutputValues.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBoundOutputValues.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBoundOutputValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBoundOutputValues"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static final AddressLayout GetBoundOutputValues$layout() {
        return GetBoundOutputValues$LAYOUT;
    }

    private static final long GetBoundOutputValues$OFFSET = $LAYOUT.byteOffset(groupElement("GetBoundOutputValues"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static final long GetBoundOutputValues$offset() {
        return GetBoundOutputValues$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static MemorySegment GetBoundOutputValues(MemorySegment struct) {
        return struct.get(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static void GetBoundOutputValues(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public final static class ClearBoundInputs {

        private ClearBoundInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ClearBoundInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearBoundInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearBoundInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout ClearBoundInputs$layout() {
        return ClearBoundInputs$LAYOUT;
    }

    private static final long ClearBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement("ClearBoundInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final long ClearBoundInputs$offset() {
        return ClearBoundInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment ClearBoundInputs(MemorySegment struct) {
        return struct.get(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static void ClearBoundInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public final static class ClearBoundOutputs {

        private ClearBoundOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ClearBoundOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearBoundOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearBoundOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout ClearBoundOutputs$layout() {
        return ClearBoundOutputs$LAYOUT;
    }

    private static final long ClearBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("ClearBoundOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final long ClearBoundOutputs$offset() {
        return ClearBoundOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment ClearBoundOutputs(MemorySegment struct) {
        return struct.get(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static void ClearBoundOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public final static class TensorAt {

        private TensorAt() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(TensorAt.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(TensorAt.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout TensorAt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("TensorAt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static final AddressLayout TensorAt$layout() {
        return TensorAt$LAYOUT;
    }

    private static final long TensorAt$OFFSET = $LAYOUT.byteOffset(groupElement("TensorAt"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static final long TensorAt$offset() {
        return TensorAt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static MemorySegment TensorAt(MemorySegment struct) {
        return struct.get(TensorAt$LAYOUT, TensorAt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static void TensorAt(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(TensorAt$LAYOUT, TensorAt$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public final static class CreateAndRegisterAllocator {

        private CreateAndRegisterAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateAndRegisterAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateAndRegisterAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateAndRegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateAndRegisterAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static final AddressLayout CreateAndRegisterAllocator$layout() {
        return CreateAndRegisterAllocator$LAYOUT;
    }

    private static final long CreateAndRegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("CreateAndRegisterAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static final long CreateAndRegisterAllocator$offset() {
        return CreateAndRegisterAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static MemorySegment CreateAndRegisterAllocator(MemorySegment struct) {
        return struct.get(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static void CreateAndRegisterAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public final static class SetLanguageProjection {

        private SetLanguageProjection() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetLanguageProjection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLanguageProjection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLanguageProjection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLanguageProjection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static final AddressLayout SetLanguageProjection$layout() {
        return SetLanguageProjection$LAYOUT;
    }

    private static final long SetLanguageProjection$OFFSET = $LAYOUT.byteOffset(groupElement("SetLanguageProjection"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static final long SetLanguageProjection$offset() {
        return SetLanguageProjection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static MemorySegment SetLanguageProjection(MemorySegment struct) {
        return struct.get(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static void SetLanguageProjection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public final static class SessionGetProfilingStartTimeNs {

        private SessionGetProfilingStartTimeNs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetProfilingStartTimeNs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetProfilingStartTimeNs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetProfilingStartTimeNs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetProfilingStartTimeNs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static final AddressLayout SessionGetProfilingStartTimeNs$layout() {
        return SessionGetProfilingStartTimeNs$LAYOUT;
    }

    private static final long SessionGetProfilingStartTimeNs$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetProfilingStartTimeNs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static final long SessionGetProfilingStartTimeNs$offset() {
        return SessionGetProfilingStartTimeNs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static MemorySegment SessionGetProfilingStartTimeNs(MemorySegment struct) {
        return struct.get(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static void SessionGetProfilingStartTimeNs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public final static class SetGlobalIntraOpNumThreads {

        private SetGlobalIntraOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalIntraOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalIntraOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalIntraOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final AddressLayout SetGlobalIntraOpNumThreads$layout() {
        return SetGlobalIntraOpNumThreads$LAYOUT;
    }

    private static final long SetGlobalIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalIntraOpNumThreads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final long SetGlobalIntraOpNumThreads$offset() {
        return SetGlobalIntraOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalIntraOpNumThreads(MemorySegment struct) {
        return struct.get(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static void SetGlobalIntraOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public final static class SetGlobalInterOpNumThreads {

        private SetGlobalInterOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalInterOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalInterOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalInterOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final AddressLayout SetGlobalInterOpNumThreads$layout() {
        return SetGlobalInterOpNumThreads$LAYOUT;
    }

    private static final long SetGlobalInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalInterOpNumThreads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final long SetGlobalInterOpNumThreads$offset() {
        return SetGlobalInterOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalInterOpNumThreads(MemorySegment struct) {
        return struct.get(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static void SetGlobalInterOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public final static class SetGlobalSpinControl {

        private SetGlobalSpinControl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalSpinControl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalSpinControl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalSpinControl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalSpinControl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static final AddressLayout SetGlobalSpinControl$layout() {
        return SetGlobalSpinControl$LAYOUT;
    }

    private static final long SetGlobalSpinControl$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalSpinControl"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static final long SetGlobalSpinControl$offset() {
        return SetGlobalSpinControl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalSpinControl(MemorySegment struct) {
        return struct.get(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static void SetGlobalSpinControl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public final static class AddInitializer {

        private AddInitializer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddInitializer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddInitializer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddInitializer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static final AddressLayout AddInitializer$layout() {
        return AddInitializer$LAYOUT;
    }

    private static final long AddInitializer$OFFSET = $LAYOUT.byteOffset(groupElement("AddInitializer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static final long AddInitializer$offset() {
        return AddInitializer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment AddInitializer(MemorySegment struct) {
        return struct.get(AddInitializer$LAYOUT, AddInitializer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static void AddInitializer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddInitializer$LAYOUT, AddInitializer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public final static class CreateEnvWithCustomLoggerAndGlobalThreadPools {

        private CreateEnvWithCustomLoggerAndGlobalThreadPools() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateEnvWithCustomLoggerAndGlobalThreadPools.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnvWithCustomLoggerAndGlobalThreadPools.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnvWithCustomLoggerAndGlobalThreadPools"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$layout() {
        return CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT;
    }

    private static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnvWithCustomLoggerAndGlobalThreadPools"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$offset() {
        return CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct) {
        return struct.get(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static void CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_CUDA {

        private SessionOptionsAppendExecutionProvider_CUDA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_CUDA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CUDA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CUDA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$layout() {
        return SessionOptionsAppendExecutionProvider_CUDA$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_CUDA$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_CUDA"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_CUDA$offset() {
        return SessionOptionsAppendExecutionProvider_CUDA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_ROCM {

        private SessionOptionsAppendExecutionProvider_ROCM() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_ROCM.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_ROCM.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_ROCM"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$layout() {
        return SessionOptionsAppendExecutionProvider_ROCM$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_ROCM$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_ROCM"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_ROCM$offset() {
        return SessionOptionsAppendExecutionProvider_ROCM$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_OpenVINO {

        private SessionOptionsAppendExecutionProvider_OpenVINO() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_OpenVINO.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_OpenVINO.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$layout() {
        return SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_OpenVINO$offset() {
        return SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public final static class SetGlobalDenormalAsZero {

        private SetGlobalDenormalAsZero() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalDenormalAsZero.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalDenormalAsZero.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalDenormalAsZero$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalDenormalAsZero"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static final AddressLayout SetGlobalDenormalAsZero$layout() {
        return SetGlobalDenormalAsZero$LAYOUT;
    }

    private static final long SetGlobalDenormalAsZero$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalDenormalAsZero"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static final long SetGlobalDenormalAsZero$offset() {
        return SetGlobalDenormalAsZero$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static MemorySegment SetGlobalDenormalAsZero(MemorySegment struct) {
        return struct.get(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static void SetGlobalDenormalAsZero(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public final static class CreateArenaCfg {

        private CreateArenaCfg() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(long _x0, int _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateArenaCfg.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateArenaCfg.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateArenaCfg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static final AddressLayout CreateArenaCfg$layout() {
        return CreateArenaCfg$LAYOUT;
    }

    private static final long CreateArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement("CreateArenaCfg"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static final long CreateArenaCfg$offset() {
        return CreateArenaCfg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static MemorySegment CreateArenaCfg(MemorySegment struct) {
        return struct.get(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static void CreateArenaCfg(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public final static class ReleaseArenaCfg {

        private ReleaseArenaCfg() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseArenaCfg.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseArenaCfg.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseArenaCfg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static final AddressLayout ReleaseArenaCfg$layout() {
        return ReleaseArenaCfg$LAYOUT;
    }

    private static final long ReleaseArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseArenaCfg"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static final long ReleaseArenaCfg$offset() {
        return ReleaseArenaCfg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static MemorySegment ReleaseArenaCfg(MemorySegment struct) {
        return struct.get(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static void ReleaseArenaCfg(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public final static class ModelMetadataGetGraphDescription {

        private ModelMetadataGetGraphDescription() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelMetadataGetGraphDescription.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetGraphDescription.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetGraphDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetGraphDescription"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetGraphDescription$layout() {
        return ModelMetadataGetGraphDescription$LAYOUT;
    }

    private static final long ModelMetadataGetGraphDescription$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetGraphDescription"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetGraphDescription$offset() {
        return ModelMetadataGetGraphDescription$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetGraphDescription(MemorySegment struct) {
        return struct.get(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetGraphDescription(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_TensorRT {

        private SessionOptionsAppendExecutionProvider_TensorRT() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_TensorRT.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_TensorRT.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_TensorRT"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$layout() {
        return SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_TensorRT$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_TensorRT"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_TensorRT$offset() {
        return SessionOptionsAppendExecutionProvider_TensorRT$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public final static class SetCurrentGpuDeviceId {

        private SetCurrentGpuDeviceId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetCurrentGpuDeviceId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetCurrentGpuDeviceId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetCurrentGpuDeviceId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static final AddressLayout SetCurrentGpuDeviceId$layout() {
        return SetCurrentGpuDeviceId$LAYOUT;
    }

    private static final long SetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement("SetCurrentGpuDeviceId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static final long SetCurrentGpuDeviceId$offset() {
        return SetCurrentGpuDeviceId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static MemorySegment SetCurrentGpuDeviceId(MemorySegment struct) {
        return struct.get(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static void SetCurrentGpuDeviceId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public final static class GetCurrentGpuDeviceId {

        private GetCurrentGpuDeviceId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetCurrentGpuDeviceId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCurrentGpuDeviceId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCurrentGpuDeviceId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static final AddressLayout GetCurrentGpuDeviceId$layout() {
        return GetCurrentGpuDeviceId$LAYOUT;
    }

    private static final long GetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement("GetCurrentGpuDeviceId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static final long GetCurrentGpuDeviceId$offset() {
        return GetCurrentGpuDeviceId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static MemorySegment GetCurrentGpuDeviceId(MemorySegment struct) {
        return struct.get(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static void GetCurrentGpuDeviceId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public final static class KernelInfoGetAttributeArray_float {

        private KernelInfoGetAttributeArray_float() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAttributeArray_float.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttributeArray_float.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttributeArray_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttributeArray_float"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttributeArray_float$layout() {
        return KernelInfoGetAttributeArray_float$LAYOUT;
    }

    private static final long KernelInfoGetAttributeArray_float$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttributeArray_float"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static final long KernelInfoGetAttributeArray_float$offset() {
        return KernelInfoGetAttributeArray_float$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttributeArray_float(MemorySegment struct) {
        return struct.get(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static void KernelInfoGetAttributeArray_float(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public final static class KernelInfoGetAttributeArray_int64 {

        private KernelInfoGetAttributeArray_int64() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAttributeArray_int64.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttributeArray_int64.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttributeArray_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttributeArray_int64"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttributeArray_int64$layout() {
        return KernelInfoGetAttributeArray_int64$LAYOUT;
    }

    private static final long KernelInfoGetAttributeArray_int64$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttributeArray_int64"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static final long KernelInfoGetAttributeArray_int64$offset() {
        return KernelInfoGetAttributeArray_int64$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttributeArray_int64(MemorySegment struct) {
        return struct.get(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static void KernelInfoGetAttributeArray_int64(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public final static class CreateArenaCfgV2 {

        private CreateArenaCfgV2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateArenaCfgV2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateArenaCfgV2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateArenaCfgV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateArenaCfgV2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static final AddressLayout CreateArenaCfgV2$layout() {
        return CreateArenaCfgV2$LAYOUT;
    }

    private static final long CreateArenaCfgV2$OFFSET = $LAYOUT.byteOffset(groupElement("CreateArenaCfgV2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static final long CreateArenaCfgV2$offset() {
        return CreateArenaCfgV2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static MemorySegment CreateArenaCfgV2(MemorySegment struct) {
        return struct.get(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static void CreateArenaCfgV2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public final static class AddRunConfigEntry {

        private AddRunConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddRunConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddRunConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddRunConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static final AddressLayout AddRunConfigEntry$layout() {
        return AddRunConfigEntry$LAYOUT;
    }

    private static final long AddRunConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("AddRunConfigEntry"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static final long AddRunConfigEntry$offset() {
        return AddRunConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static MemorySegment AddRunConfigEntry(MemorySegment struct) {
        return struct.get(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static void AddRunConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public final static class CreatePrepackedWeightsContainer {

        private CreatePrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreatePrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreatePrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreatePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreatePrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static final AddressLayout CreatePrepackedWeightsContainer$layout() {
        return CreatePrepackedWeightsContainer$LAYOUT;
    }

    private static final long CreatePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("CreatePrepackedWeightsContainer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static final long CreatePrepackedWeightsContainer$offset() {
        return CreatePrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static MemorySegment CreatePrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static void CreatePrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public final static class ReleasePrepackedWeightsContainer {

        private ReleasePrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleasePrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleasePrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleasePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleasePrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static final AddressLayout ReleasePrepackedWeightsContainer$layout() {
        return ReleasePrepackedWeightsContainer$LAYOUT;
    }

    private static final long ReleasePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("ReleasePrepackedWeightsContainer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static final long ReleasePrepackedWeightsContainer$offset() {
        return ReleasePrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static MemorySegment ReleasePrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static void ReleasePrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public final static class CreateSessionWithPrepackedWeightsContainer {

        private CreateSessionWithPrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSessionWithPrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionWithPrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionWithPrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionWithPrepackedWeightsContainer$layout() {
        return CreateSessionWithPrepackedWeightsContainer$LAYOUT;
    }

    private static final long CreateSessionWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionWithPrepackedWeightsContainer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final long CreateSessionWithPrepackedWeightsContainer$offset() {
        return CreateSessionWithPrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionWithPrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static void CreateSessionWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public final static class CreateSessionFromArrayWithPrepackedWeightsContainer {

        private CreateSessionFromArrayWithPrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSessionFromArrayWithPrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionFromArrayWithPrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionFromArrayWithPrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$layout() {
        return CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT;
    }

    private static final long CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionFromArrayWithPrepackedWeightsContainer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final long CreateSessionFromArrayWithPrepackedWeightsContainer$offset() {
        return CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static void CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_TensorRT_V2 {

        private SessionOptionsAppendExecutionProvider_TensorRT_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_TensorRT_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_TensorRT_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_TensorRT_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$layout() {
        return SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_TensorRT_V2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$offset() {
        return SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public final static class CreateTensorRTProviderOptions {

        private CreateTensorRTProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorRTProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorRTProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorRTProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static final AddressLayout CreateTensorRTProviderOptions$layout() {
        return CreateTensorRTProviderOptions$LAYOUT;
    }

    private static final long CreateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorRTProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static final long CreateTensorRTProviderOptions$offset() {
        return CreateTensorRTProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static MemorySegment CreateTensorRTProviderOptions(MemorySegment struct) {
        return struct.get(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static void CreateTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class UpdateTensorRTProviderOptions {

        private UpdateTensorRTProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateTensorRTProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateTensorRTProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateTensorRTProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateTensorRTProviderOptions$layout() {
        return UpdateTensorRTProviderOptions$LAYOUT;
    }

    private static final long UpdateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateTensorRTProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateTensorRTProviderOptions$offset() {
        return UpdateTensorRTProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateTensorRTProviderOptions(MemorySegment struct) {
        return struct.get(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public final static class GetTensorRTProviderOptionsAsString {

        private GetTensorRTProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorRTProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorRTProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorRTProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorRTProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetTensorRTProviderOptionsAsString$layout() {
        return GetTensorRTProviderOptionsAsString$LAYOUT;
    }

    private static final long GetTensorRTProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorRTProviderOptionsAsString"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final long GetTensorRTProviderOptionsAsString$offset() {
        return GetTensorRTProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetTensorRTProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static void GetTensorRTProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public final static class ReleaseTensorRTProviderOptions {

        private ReleaseTensorRTProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseTensorRTProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTensorRTProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTensorRTProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout ReleaseTensorRTProviderOptions$layout() {
        return ReleaseTensorRTProviderOptions$LAYOUT;
    }

    private static final long ReleaseTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseTensorRTProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final long ReleaseTensorRTProviderOptions$offset() {
        return ReleaseTensorRTProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static MemorySegment ReleaseTensorRTProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static void ReleaseTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public final static class EnableOrtCustomOps {

        private EnableOrtCustomOps() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EnableOrtCustomOps.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableOrtCustomOps.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableOrtCustomOps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableOrtCustomOps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout EnableOrtCustomOps$layout() {
        return EnableOrtCustomOps$LAYOUT;
    }

    private static final long EnableOrtCustomOps$OFFSET = $LAYOUT.byteOffset(groupElement("EnableOrtCustomOps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static final long EnableOrtCustomOps$offset() {
        return EnableOrtCustomOps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableOrtCustomOps(MemorySegment struct) {
        return struct.get(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static void EnableOrtCustomOps(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public final static class RegisterAllocator {

        private RegisterAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RegisterAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static final AddressLayout RegisterAllocator$layout() {
        return RegisterAllocator$LAYOUT;
    }

    private static final long RegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static final long RegisterAllocator$offset() {
        return RegisterAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static MemorySegment RegisterAllocator(MemorySegment struct) {
        return struct.get(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static void RegisterAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public final static class UnregisterAllocator {

        private UnregisterAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UnregisterAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UnregisterAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UnregisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UnregisterAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout UnregisterAllocator$layout() {
        return UnregisterAllocator$LAYOUT;
    }

    private static final long UnregisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("UnregisterAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static final long UnregisterAllocator$offset() {
        return UnregisterAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment UnregisterAllocator(MemorySegment struct) {
        return struct.get(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static void UnregisterAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public final static class IsSparseTensor {

        private IsSparseTensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(IsSparseTensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsSparseTensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsSparseTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsSparseTensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static final AddressLayout IsSparseTensor$layout() {
        return IsSparseTensor$LAYOUT;
    }

    private static final long IsSparseTensor$OFFSET = $LAYOUT.byteOffset(groupElement("IsSparseTensor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static final long IsSparseTensor$offset() {
        return IsSparseTensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment IsSparseTensor(MemorySegment struct) {
        return struct.get(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static void IsSparseTensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public final static class CreateSparseTensorAsOrtValue {

        private CreateSparseTensorAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSparseTensorAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSparseTensorAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSparseTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSparseTensorAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateSparseTensorAsOrtValue$layout() {
        return CreateSparseTensorAsOrtValue$LAYOUT;
    }

    private static final long CreateSparseTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSparseTensorAsOrtValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateSparseTensorAsOrtValue$offset() {
        return CreateSparseTensorAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateSparseTensorAsOrtValue(MemorySegment struct) {
        return struct.get(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateSparseTensorAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public final static class FillSparseTensorCoo {

        private FillSparseTensorCoo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FillSparseTensorCoo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillSparseTensorCoo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillSparseTensorCoo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillSparseTensorCoo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static final AddressLayout FillSparseTensorCoo$layout() {
        return FillSparseTensorCoo$LAYOUT;
    }

    private static final long FillSparseTensorCoo$OFFSET = $LAYOUT.byteOffset(groupElement("FillSparseTensorCoo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static final long FillSparseTensorCoo$offset() {
        return FillSparseTensorCoo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static MemorySegment FillSparseTensorCoo(MemorySegment struct) {
        return struct.get(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static void FillSparseTensorCoo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public final static class FillSparseTensorCsr {

        private FillSparseTensorCsr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FillSparseTensorCsr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillSparseTensorCsr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillSparseTensorCsr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillSparseTensorCsr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static final AddressLayout FillSparseTensorCsr$layout() {
        return FillSparseTensorCsr$LAYOUT;
    }

    private static final long FillSparseTensorCsr$OFFSET = $LAYOUT.byteOffset(groupElement("FillSparseTensorCsr"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static final long FillSparseTensorCsr$offset() {
        return FillSparseTensorCsr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static MemorySegment FillSparseTensorCsr(MemorySegment struct) {
        return struct.get(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static void FillSparseTensorCsr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public final static class FillSparseTensorBlockSparse {

        private FillSparseTensorBlockSparse() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FillSparseTensorBlockSparse.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillSparseTensorBlockSparse.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillSparseTensorBlockSparse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillSparseTensorBlockSparse"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static final AddressLayout FillSparseTensorBlockSparse$layout() {
        return FillSparseTensorBlockSparse$LAYOUT;
    }

    private static final long FillSparseTensorBlockSparse$OFFSET = $LAYOUT.byteOffset(groupElement("FillSparseTensorBlockSparse"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static final long FillSparseTensorBlockSparse$offset() {
        return FillSparseTensorBlockSparse$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static MemorySegment FillSparseTensorBlockSparse(MemorySegment struct) {
        return struct.get(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static void FillSparseTensorBlockSparse(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public final static class CreateSparseTensorWithValuesAsOrtValue {

        private CreateSparseTensorWithValuesAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSparseTensorWithValuesAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSparseTensorWithValuesAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSparseTensorWithValuesAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$layout() {
        return CreateSparseTensorWithValuesAsOrtValue$LAYOUT;
    }

    private static final long CreateSparseTensorWithValuesAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSparseTensorWithValuesAsOrtValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateSparseTensorWithValuesAsOrtValue$offset() {
        return CreateSparseTensorWithValuesAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct) {
        return struct.get(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public final static class UseCooIndices {

        private UseCooIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UseCooIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UseCooIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UseCooIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UseCooIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static final AddressLayout UseCooIndices$layout() {
        return UseCooIndices$LAYOUT;
    }

    private static final long UseCooIndices$OFFSET = $LAYOUT.byteOffset(groupElement("UseCooIndices"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static final long UseCooIndices$offset() {
        return UseCooIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static MemorySegment UseCooIndices(MemorySegment struct) {
        return struct.get(UseCooIndices$LAYOUT, UseCooIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static void UseCooIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UseCooIndices$LAYOUT, UseCooIndices$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public final static class UseCsrIndices {

        private UseCsrIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UseCsrIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UseCsrIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UseCsrIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UseCsrIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static final AddressLayout UseCsrIndices$layout() {
        return UseCsrIndices$LAYOUT;
    }

    private static final long UseCsrIndices$OFFSET = $LAYOUT.byteOffset(groupElement("UseCsrIndices"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static final long UseCsrIndices$offset() {
        return UseCsrIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static MemorySegment UseCsrIndices(MemorySegment struct) {
        return struct.get(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static void UseCsrIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public final static class UseBlockSparseIndices {

        private UseBlockSparseIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UseBlockSparseIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UseBlockSparseIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UseBlockSparseIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UseBlockSparseIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static final AddressLayout UseBlockSparseIndices$layout() {
        return UseBlockSparseIndices$LAYOUT;
    }

    private static final long UseBlockSparseIndices$OFFSET = $LAYOUT.byteOffset(groupElement("UseBlockSparseIndices"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static final long UseBlockSparseIndices$offset() {
        return UseBlockSparseIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static MemorySegment UseBlockSparseIndices(MemorySegment struct) {
        return struct.get(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static void UseBlockSparseIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public final static class GetSparseTensorFormat {

        private GetSparseTensorFormat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSparseTensorFormat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorFormat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorFormat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorFormat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static final AddressLayout GetSparseTensorFormat$layout() {
        return GetSparseTensorFormat$LAYOUT;
    }

    private static final long GetSparseTensorFormat$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorFormat"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static final long GetSparseTensorFormat$offset() {
        return GetSparseTensorFormat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static MemorySegment GetSparseTensorFormat(MemorySegment struct) {
        return struct.get(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static void GetSparseTensorFormat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public final static class GetSparseTensorValuesTypeAndShape {

        private GetSparseTensorValuesTypeAndShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSparseTensorValuesTypeAndShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorValuesTypeAndShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorValuesTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorValuesTypeAndShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout GetSparseTensorValuesTypeAndShape$layout() {
        return GetSparseTensorValuesTypeAndShape$LAYOUT;
    }

    private static final long GetSparseTensorValuesTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorValuesTypeAndShape"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long GetSparseTensorValuesTypeAndShape$offset() {
        return GetSparseTensorValuesTypeAndShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetSparseTensorValuesTypeAndShape(MemorySegment struct) {
        return struct.get(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void GetSparseTensorValuesTypeAndShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public final static class GetSparseTensorValues {

        private GetSparseTensorValues() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSparseTensorValues.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorValues.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorValues"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static final AddressLayout GetSparseTensorValues$layout() {
        return GetSparseTensorValues$LAYOUT;
    }

    private static final long GetSparseTensorValues$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorValues"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static final long GetSparseTensorValues$offset() {
        return GetSparseTensorValues$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static MemorySegment GetSparseTensorValues(MemorySegment struct) {
        return struct.get(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static void GetSparseTensorValues(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public final static class GetSparseTensorIndicesTypeShape {

        private GetSparseTensorIndicesTypeShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSparseTensorIndicesTypeShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorIndicesTypeShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorIndicesTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorIndicesTypeShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout GetSparseTensorIndicesTypeShape$layout() {
        return GetSparseTensorIndicesTypeShape$LAYOUT;
    }

    private static final long GetSparseTensorIndicesTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorIndicesTypeShape"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long GetSparseTensorIndicesTypeShape$offset() {
        return GetSparseTensorIndicesTypeShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetSparseTensorIndicesTypeShape(MemorySegment struct) {
        return struct.get(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void GetSparseTensorIndicesTypeShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public final static class GetSparseTensorIndices {

        private GetSparseTensorIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSparseTensorIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static final AddressLayout GetSparseTensorIndices$layout() {
        return GetSparseTensorIndices$LAYOUT;
    }

    private static final long GetSparseTensorIndices$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorIndices"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static final long GetSparseTensorIndices$offset() {
        return GetSparseTensorIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static MemorySegment GetSparseTensorIndices(MemorySegment struct) {
        return struct.get(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static void GetSparseTensorIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public final static class HasValue {

        private HasValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HasValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HasValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HasValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HasValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static final AddressLayout HasValue$layout() {
        return HasValue$LAYOUT;
    }

    private static final long HasValue$OFFSET = $LAYOUT.byteOffset(groupElement("HasValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static final long HasValue$offset() {
        return HasValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment HasValue(MemorySegment struct) {
        return struct.get(HasValue$LAYOUT, HasValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static void HasValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HasValue$LAYOUT, HasValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public final static class KernelContext_GetGPUComputeStream {

        private KernelContext_GetGPUComputeStream() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetGPUComputeStream.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetGPUComputeStream.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetGPUComputeStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetGPUComputeStream"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static final AddressLayout KernelContext_GetGPUComputeStream$layout() {
        return KernelContext_GetGPUComputeStream$LAYOUT;
    }

    private static final long KernelContext_GetGPUComputeStream$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetGPUComputeStream"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static final long KernelContext_GetGPUComputeStream$offset() {
        return KernelContext_GetGPUComputeStream$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static MemorySegment KernelContext_GetGPUComputeStream(MemorySegment struct) {
        return struct.get(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static void KernelContext_GetGPUComputeStream(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public final static class GetTensorMemoryInfo {

        private GetTensorMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout GetTensorMemoryInfo$layout() {
        return GetTensorMemoryInfo$LAYOUT;
    }

    private static final long GetTensorMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorMemoryInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static final long GetTensorMemoryInfo$offset() {
        return GetTensorMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static MemorySegment GetTensorMemoryInfo(MemorySegment struct) {
        return struct.get(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static void GetTensorMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public final static class GetExecutionProviderApi {

        private GetExecutionProviderApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetExecutionProviderApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetExecutionProviderApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetExecutionProviderApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetExecutionProviderApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static final AddressLayout GetExecutionProviderApi$layout() {
        return GetExecutionProviderApi$LAYOUT;
    }

    private static final long GetExecutionProviderApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetExecutionProviderApi"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static final long GetExecutionProviderApi$offset() {
        return GetExecutionProviderApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static MemorySegment GetExecutionProviderApi(MemorySegment struct) {
        return struct.get(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static void GetExecutionProviderApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public final static class SessionOptionsSetCustomCreateThreadFn {

        private SessionOptionsSetCustomCreateThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsSetCustomCreateThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetCustomCreateThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetCustomCreateThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final AddressLayout SessionOptionsSetCustomCreateThreadFn$layout() {
        return SessionOptionsSetCustomCreateThreadFn$LAYOUT;
    }

    private static final long SessionOptionsSetCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetCustomCreateThreadFn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final long SessionOptionsSetCustomCreateThreadFn$offset() {
        return SessionOptionsSetCustomCreateThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomCreateThreadFn(MemorySegment struct) {
        return struct.get(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static void SessionOptionsSetCustomCreateThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public final static class SessionOptionsSetCustomThreadCreationOptions {

        private SessionOptionsSetCustomThreadCreationOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsSetCustomThreadCreationOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetCustomThreadCreationOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetCustomThreadCreationOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$layout() {
        return SessionOptionsSetCustomThreadCreationOptions$LAYOUT;
    }

    private static final long SessionOptionsSetCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetCustomThreadCreationOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static final long SessionOptionsSetCustomThreadCreationOptions$offset() {
        return SessionOptionsSetCustomThreadCreationOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct) {
        return struct.get(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static void SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public final static class SessionOptionsSetCustomJoinThreadFn {

        private SessionOptionsSetCustomJoinThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsSetCustomJoinThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetCustomJoinThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetCustomJoinThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final AddressLayout SessionOptionsSetCustomJoinThreadFn$layout() {
        return SessionOptionsSetCustomJoinThreadFn$LAYOUT;
    }

    private static final long SessionOptionsSetCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetCustomJoinThreadFn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final long SessionOptionsSetCustomJoinThreadFn$offset() {
        return SessionOptionsSetCustomJoinThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomJoinThreadFn(MemorySegment struct) {
        return struct.get(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static void SessionOptionsSetCustomJoinThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public final static class SetGlobalCustomCreateThreadFn {

        private SetGlobalCustomCreateThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalCustomCreateThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalCustomCreateThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalCustomCreateThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final AddressLayout SetGlobalCustomCreateThreadFn$layout() {
        return SetGlobalCustomCreateThreadFn$LAYOUT;
    }

    private static final long SetGlobalCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalCustomCreateThreadFn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final long SetGlobalCustomCreateThreadFn$offset() {
        return SetGlobalCustomCreateThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static MemorySegment SetGlobalCustomCreateThreadFn(MemorySegment struct) {
        return struct.get(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static void SetGlobalCustomCreateThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public final static class SetGlobalCustomThreadCreationOptions {

        private SetGlobalCustomThreadCreationOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalCustomThreadCreationOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalCustomThreadCreationOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalCustomThreadCreationOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static final AddressLayout SetGlobalCustomThreadCreationOptions$layout() {
        return SetGlobalCustomThreadCreationOptions$LAYOUT;
    }

    private static final long SetGlobalCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalCustomThreadCreationOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static final long SetGlobalCustomThreadCreationOptions$offset() {
        return SetGlobalCustomThreadCreationOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static MemorySegment SetGlobalCustomThreadCreationOptions(MemorySegment struct) {
        return struct.get(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static void SetGlobalCustomThreadCreationOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public final static class SetGlobalCustomJoinThreadFn {

        private SetGlobalCustomJoinThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalCustomJoinThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalCustomJoinThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalCustomJoinThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final AddressLayout SetGlobalCustomJoinThreadFn$layout() {
        return SetGlobalCustomJoinThreadFn$LAYOUT;
    }

    private static final long SetGlobalCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalCustomJoinThreadFn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final long SetGlobalCustomJoinThreadFn$offset() {
        return SetGlobalCustomJoinThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static MemorySegment SetGlobalCustomJoinThreadFn(MemorySegment struct) {
        return struct.get(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static void SetGlobalCustomJoinThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public final static class SynchronizeBoundInputs {

        private SynchronizeBoundInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SynchronizeBoundInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SynchronizeBoundInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SynchronizeBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SynchronizeBoundInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout SynchronizeBoundInputs$layout() {
        return SynchronizeBoundInputs$LAYOUT;
    }

    private static final long SynchronizeBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement("SynchronizeBoundInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final long SynchronizeBoundInputs$offset() {
        return SynchronizeBoundInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment SynchronizeBoundInputs(MemorySegment struct) {
        return struct.get(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static void SynchronizeBoundInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public final static class SynchronizeBoundOutputs {

        private SynchronizeBoundOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SynchronizeBoundOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SynchronizeBoundOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SynchronizeBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SynchronizeBoundOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout SynchronizeBoundOutputs$layout() {
        return SynchronizeBoundOutputs$LAYOUT;
    }

    private static final long SynchronizeBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("SynchronizeBoundOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final long SynchronizeBoundOutputs$offset() {
        return SynchronizeBoundOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment SynchronizeBoundOutputs(MemorySegment struct) {
        return struct.get(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static void SynchronizeBoundOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_CUDA_V2 {

        private SessionOptionsAppendExecutionProvider_CUDA_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_CUDA_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CUDA_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CUDA_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$layout() {
        return SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_CUDA_V2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_CUDA_V2$offset() {
        return SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public final static class CreateCUDAProviderOptions {

        private CreateCUDAProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateCUDAProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCUDAProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCUDAProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static final AddressLayout CreateCUDAProviderOptions$layout() {
        return CreateCUDAProviderOptions$LAYOUT;
    }

    private static final long CreateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCUDAProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static final long CreateCUDAProviderOptions$offset() {
        return CreateCUDAProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static MemorySegment CreateCUDAProviderOptions(MemorySegment struct) {
        return struct.get(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static void CreateCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class UpdateCUDAProviderOptions {

        private UpdateCUDAProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateCUDAProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateCUDAProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateCUDAProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateCUDAProviderOptions$layout() {
        return UpdateCUDAProviderOptions$LAYOUT;
    }

    private static final long UpdateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateCUDAProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateCUDAProviderOptions$offset() {
        return UpdateCUDAProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateCUDAProviderOptions(MemorySegment struct) {
        return struct.get(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public final static class GetCUDAProviderOptionsAsString {

        private GetCUDAProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetCUDAProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCUDAProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCUDAProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCUDAProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetCUDAProviderOptionsAsString$layout() {
        return GetCUDAProviderOptionsAsString$LAYOUT;
    }

    private static final long GetCUDAProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetCUDAProviderOptionsAsString"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final long GetCUDAProviderOptionsAsString$offset() {
        return GetCUDAProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetCUDAProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static void GetCUDAProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public final static class ReleaseCUDAProviderOptions {

        private ReleaseCUDAProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseCUDAProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCUDAProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCUDAProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout ReleaseCUDAProviderOptions$layout() {
        return ReleaseCUDAProviderOptions$LAYOUT;
    }

    private static final long ReleaseCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseCUDAProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final long ReleaseCUDAProviderOptions$offset() {
        return ReleaseCUDAProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static MemorySegment ReleaseCUDAProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static void ReleaseCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_MIGraphX {

        private SessionOptionsAppendExecutionProvider_MIGraphX() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_MIGraphX.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_MIGraphX.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_MIGraphX"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$layout() {
        return SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_MIGraphX"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_MIGraphX$offset() {
        return SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public final static class AddExternalInitializers {

        private AddExternalInitializers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddExternalInitializers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddExternalInitializers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddExternalInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddExternalInitializers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static final AddressLayout AddExternalInitializers$layout() {
        return AddExternalInitializers$LAYOUT;
    }

    private static final long AddExternalInitializers$OFFSET = $LAYOUT.byteOffset(groupElement("AddExternalInitializers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static final long AddExternalInitializers$offset() {
        return AddExternalInitializers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static MemorySegment AddExternalInitializers(MemorySegment struct) {
        return struct.get(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static void AddExternalInitializers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public final static class CreateOpAttr {

        private CreateOpAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateOpAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOpAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOpAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static final AddressLayout CreateOpAttr$layout() {
        return CreateOpAttr$LAYOUT;
    }

    private static final long CreateOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement("CreateOpAttr"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static final long CreateOpAttr$offset() {
        return CreateOpAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static MemorySegment CreateOpAttr(MemorySegment struct) {
        return struct.get(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static void CreateOpAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public final static class ReleaseOpAttr {

        private ReleaseOpAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseOpAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseOpAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseOpAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static final AddressLayout ReleaseOpAttr$layout() {
        return ReleaseOpAttr$LAYOUT;
    }

    private static final long ReleaseOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseOpAttr"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static final long ReleaseOpAttr$offset() {
        return ReleaseOpAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static MemorySegment ReleaseOpAttr(MemorySegment struct) {
        return struct.get(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static void ReleaseOpAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public final static class CreateOp {

        private CreateOp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateOp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static final AddressLayout CreateOp$layout() {
        return CreateOp$LAYOUT;
    }

    private static final long CreateOp$OFFSET = $LAYOUT.byteOffset(groupElement("CreateOp"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static final long CreateOp$offset() {
        return CreateOp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static MemorySegment CreateOp(MemorySegment struct) {
        return struct.get(CreateOp$LAYOUT, CreateOp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static void CreateOp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOp$LAYOUT, CreateOp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public final static class InvokeOp {

        private InvokeOp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(InvokeOp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(InvokeOp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout InvokeOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("InvokeOp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static final AddressLayout InvokeOp$layout() {
        return InvokeOp$LAYOUT;
    }

    private static final long InvokeOp$OFFSET = $LAYOUT.byteOffset(groupElement("InvokeOp"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static final long InvokeOp$offset() {
        return InvokeOp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static MemorySegment InvokeOp(MemorySegment struct) {
        return struct.get(InvokeOp$LAYOUT, InvokeOp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static void InvokeOp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(InvokeOp$LAYOUT, InvokeOp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public final static class ReleaseOp {

        private ReleaseOp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseOp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseOp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseOp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static final AddressLayout ReleaseOp$layout() {
        return ReleaseOp$LAYOUT;
    }

    private static final long ReleaseOp$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseOp"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static final long ReleaseOp$offset() {
        return ReleaseOp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static MemorySegment ReleaseOp(MemorySegment struct) {
        return struct.get(ReleaseOp$LAYOUT, ReleaseOp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static void ReleaseOp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseOp$LAYOUT, ReleaseOp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider {

        private SessionOptionsAppendExecutionProvider() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider$layout() {
        return SessionOptionsAppendExecutionProvider$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider$offset() {
        return SessionOptionsAppendExecutionProvider$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public final static class CopyKernelInfo {

        private CopyKernelInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CopyKernelInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CopyKernelInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CopyKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CopyKernelInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static final AddressLayout CopyKernelInfo$layout() {
        return CopyKernelInfo$LAYOUT;
    }

    private static final long CopyKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CopyKernelInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static final long CopyKernelInfo$offset() {
        return CopyKernelInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static MemorySegment CopyKernelInfo(MemorySegment struct) {
        return struct.get(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static void CopyKernelInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public final static class ReleaseKernelInfo {

        private ReleaseKernelInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseKernelInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseKernelInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseKernelInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static final AddressLayout ReleaseKernelInfo$layout() {
        return ReleaseKernelInfo$LAYOUT;
    }

    private static final long ReleaseKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseKernelInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static final long ReleaseKernelInfo$offset() {
        return ReleaseKernelInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static MemorySegment ReleaseKernelInfo(MemorySegment struct) {
        return struct.get(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static void ReleaseKernelInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public final static class GetTrainingApi {

        private GetTrainingApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTrainingApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTrainingApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTrainingApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTrainingApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static final AddressLayout GetTrainingApi$layout() {
        return GetTrainingApi$LAYOUT;
    }

    private static final long GetTrainingApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetTrainingApi"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static final long GetTrainingApi$offset() {
        return GetTrainingApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static MemorySegment GetTrainingApi(MemorySegment struct) {
        return struct.get(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static void GetTrainingApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_CANN {

        private SessionOptionsAppendExecutionProvider_CANN() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_CANN.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CANN.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CANN"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$layout() {
        return SessionOptionsAppendExecutionProvider_CANN$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_CANN$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_CANN"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_CANN$offset() {
        return SessionOptionsAppendExecutionProvider_CANN$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public final static class CreateCANNProviderOptions {

        private CreateCANNProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateCANNProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCANNProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCANNProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static final AddressLayout CreateCANNProviderOptions$layout() {
        return CreateCANNProviderOptions$LAYOUT;
    }

    private static final long CreateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCANNProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static final long CreateCANNProviderOptions$offset() {
        return CreateCANNProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static MemorySegment CreateCANNProviderOptions(MemorySegment struct) {
        return struct.get(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static void CreateCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class UpdateCANNProviderOptions {

        private UpdateCANNProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateCANNProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateCANNProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateCANNProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateCANNProviderOptions$layout() {
        return UpdateCANNProviderOptions$LAYOUT;
    }

    private static final long UpdateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateCANNProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateCANNProviderOptions$offset() {
        return UpdateCANNProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateCANNProviderOptions(MemorySegment struct) {
        return struct.get(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public final static class GetCANNProviderOptionsAsString {

        private GetCANNProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetCANNProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCANNProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCANNProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCANNProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetCANNProviderOptionsAsString$layout() {
        return GetCANNProviderOptionsAsString$LAYOUT;
    }

    private static final long GetCANNProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetCANNProviderOptionsAsString"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final long GetCANNProviderOptionsAsString$offset() {
        return GetCANNProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetCANNProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static void GetCANNProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public final static class ReleaseCANNProviderOptions {

        private ReleaseCANNProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseCANNProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCANNProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCANNProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static final AddressLayout ReleaseCANNProviderOptions$layout() {
        return ReleaseCANNProviderOptions$LAYOUT;
    }

    private static final long ReleaseCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseCANNProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static final long ReleaseCANNProviderOptions$offset() {
        return ReleaseCANNProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static MemorySegment ReleaseCANNProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static void ReleaseCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public final static class MemoryInfoGetDeviceType {

        private MemoryInfoGetDeviceType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetDeviceType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetDeviceType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetDeviceType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetDeviceType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static final AddressLayout MemoryInfoGetDeviceType$layout() {
        return MemoryInfoGetDeviceType$LAYOUT;
    }

    private static final long MemoryInfoGetDeviceType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetDeviceType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static final long MemoryInfoGetDeviceType$offset() {
        return MemoryInfoGetDeviceType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static MemorySegment MemoryInfoGetDeviceType(MemorySegment struct) {
        return struct.get(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static void MemoryInfoGetDeviceType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public final static class UpdateEnvWithCustomLogLevel {

        private UpdateEnvWithCustomLogLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateEnvWithCustomLogLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateEnvWithCustomLogLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateEnvWithCustomLogLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateEnvWithCustomLogLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static final AddressLayout UpdateEnvWithCustomLogLevel$layout() {
        return UpdateEnvWithCustomLogLevel$LAYOUT;
    }

    private static final long UpdateEnvWithCustomLogLevel$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateEnvWithCustomLogLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static final long UpdateEnvWithCustomLogLevel$offset() {
        return UpdateEnvWithCustomLogLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static MemorySegment UpdateEnvWithCustomLogLevel(MemorySegment struct) {
        return struct.get(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static void UpdateEnvWithCustomLogLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public final static class SetGlobalIntraOpThreadAffinity {

        private SetGlobalIntraOpThreadAffinity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGlobalIntraOpThreadAffinity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalIntraOpThreadAffinity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalIntraOpThreadAffinity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalIntraOpThreadAffinity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static final AddressLayout SetGlobalIntraOpThreadAffinity$layout() {
        return SetGlobalIntraOpThreadAffinity$LAYOUT;
    }

    private static final long SetGlobalIntraOpThreadAffinity$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalIntraOpThreadAffinity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static final long SetGlobalIntraOpThreadAffinity$offset() {
        return SetGlobalIntraOpThreadAffinity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static MemorySegment SetGlobalIntraOpThreadAffinity(MemorySegment struct) {
        return struct.get(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static void SetGlobalIntraOpThreadAffinity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public final static class RegisterCustomOpsLibrary_V2 {

        private RegisterCustomOpsLibrary_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RegisterCustomOpsLibrary_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterCustomOpsLibrary_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterCustomOpsLibrary_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterCustomOpsLibrary_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout RegisterCustomOpsLibrary_V2$layout() {
        return RegisterCustomOpsLibrary_V2$LAYOUT;
    }

    private static final long RegisterCustomOpsLibrary_V2$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterCustomOpsLibrary_V2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long RegisterCustomOpsLibrary_V2$offset() {
        return RegisterCustomOpsLibrary_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment RegisterCustomOpsLibrary_V2(MemorySegment struct) {
        return struct.get(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static void RegisterCustomOpsLibrary_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public final static class RegisterCustomOpsUsingFunction {

        private RegisterCustomOpsUsingFunction() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RegisterCustomOpsUsingFunction.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterCustomOpsUsingFunction.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterCustomOpsUsingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterCustomOpsUsingFunction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout RegisterCustomOpsUsingFunction$layout() {
        return RegisterCustomOpsUsingFunction$LAYOUT;
    }

    private static final long RegisterCustomOpsUsingFunction$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterCustomOpsUsingFunction"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long RegisterCustomOpsUsingFunction$offset() {
        return RegisterCustomOpsUsingFunction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment RegisterCustomOpsUsingFunction(MemorySegment struct) {
        return struct.get(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static void RegisterCustomOpsUsingFunction(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public final static class KernelInfo_GetInputCount {

        private KernelInfo_GetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetInputCount$layout() {
        return KernelInfo_GetInputCount$LAYOUT;
    }

    private static final long KernelInfo_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetInputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final long KernelInfo_GetInputCount$offset() {
        return KernelInfo_GetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetInputCount(MemorySegment struct) {
        return struct.get(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static void KernelInfo_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public final static class KernelInfo_GetOutputCount {

        private KernelInfo_GetOutputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetOutputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetOutputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetOutputCount$layout() {
        return KernelInfo_GetOutputCount$LAYOUT;
    }

    private static final long KernelInfo_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetOutputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final long KernelInfo_GetOutputCount$offset() {
        return KernelInfo_GetOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputCount(MemorySegment struct) {
        return struct.get(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static void KernelInfo_GetOutputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public final static class KernelInfo_GetInputName {

        private KernelInfo_GetInputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetInputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetInputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetInputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetInputName$layout() {
        return KernelInfo_GetInputName$LAYOUT;
    }

    private static final long KernelInfo_GetInputName$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetInputName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final long KernelInfo_GetInputName$offset() {
        return KernelInfo_GetInputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetInputName(MemorySegment struct) {
        return struct.get(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static void KernelInfo_GetInputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public final static class KernelInfo_GetOutputName {

        private KernelInfo_GetOutputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetOutputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetOutputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetOutputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetOutputName$layout() {
        return KernelInfo_GetOutputName$LAYOUT;
    }

    private static final long KernelInfo_GetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetOutputName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final long KernelInfo_GetOutputName$offset() {
        return KernelInfo_GetOutputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputName(MemorySegment struct) {
        return struct.get(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static void KernelInfo_GetOutputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public final static class KernelInfo_GetInputTypeInfo {

        private KernelInfo_GetInputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetInputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetInputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetInputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout KernelInfo_GetInputTypeInfo$layout() {
        return KernelInfo_GetInputTypeInfo$LAYOUT;
    }

    private static final long KernelInfo_GetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetInputTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long KernelInfo_GetInputTypeInfo$offset() {
        return KernelInfo_GetInputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment KernelInfo_GetInputTypeInfo(MemorySegment struct) {
        return struct.get(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static void KernelInfo_GetInputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public final static class KernelInfo_GetOutputTypeInfo {

        private KernelInfo_GetOutputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetOutputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetOutputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetOutputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout KernelInfo_GetOutputTypeInfo$layout() {
        return KernelInfo_GetOutputTypeInfo$LAYOUT;
    }

    private static final long KernelInfo_GetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetOutputTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long KernelInfo_GetOutputTypeInfo$offset() {
        return KernelInfo_GetOutputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputTypeInfo(MemorySegment struct) {
        return struct.get(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static void KernelInfo_GetOutputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public final static class KernelInfoGetAttribute_tensor {

        private KernelInfoGetAttribute_tensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAttribute_tensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_tensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_tensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_tensor$layout() {
        return KernelInfoGetAttribute_tensor$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_tensor$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_tensor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static final long KernelInfoGetAttribute_tensor$offset() {
        return KernelInfoGetAttribute_tensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_tensor(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static void KernelInfoGetAttribute_tensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public final static class HasSessionConfigEntry {

        private HasSessionConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HasSessionConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HasSessionConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HasSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HasSessionConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static final AddressLayout HasSessionConfigEntry$layout() {
        return HasSessionConfigEntry$LAYOUT;
    }

    private static final long HasSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("HasSessionConfigEntry"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static final long HasSessionConfigEntry$offset() {
        return HasSessionConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static MemorySegment HasSessionConfigEntry(MemorySegment struct) {
        return struct.get(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static void HasSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public final static class GetSessionConfigEntry {

        private GetSessionConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSessionConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSessionConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSessionConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static final AddressLayout GetSessionConfigEntry$layout() {
        return GetSessionConfigEntry$LAYOUT;
    }

    private static final long GetSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("GetSessionConfigEntry"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static final long GetSessionConfigEntry$offset() {
        return GetSessionConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static MemorySegment GetSessionConfigEntry(MemorySegment struct) {
        return struct.get(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static void GetSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_Dnnl {

        private SessionOptionsAppendExecutionProvider_Dnnl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_Dnnl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_Dnnl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_Dnnl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$layout() {
        return SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_Dnnl$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_Dnnl"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_Dnnl$offset() {
        return SessionOptionsAppendExecutionProvider_Dnnl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public final static class CreateDnnlProviderOptions {

        private CreateDnnlProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateDnnlProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateDnnlProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateDnnlProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static final AddressLayout CreateDnnlProviderOptions$layout() {
        return CreateDnnlProviderOptions$LAYOUT;
    }

    private static final long CreateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateDnnlProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static final long CreateDnnlProviderOptions$offset() {
        return CreateDnnlProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static MemorySegment CreateDnnlProviderOptions(MemorySegment struct) {
        return struct.get(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static void CreateDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class UpdateDnnlProviderOptions {

        private UpdateDnnlProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateDnnlProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateDnnlProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateDnnlProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateDnnlProviderOptions$layout() {
        return UpdateDnnlProviderOptions$LAYOUT;
    }

    private static final long UpdateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateDnnlProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateDnnlProviderOptions$offset() {
        return UpdateDnnlProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateDnnlProviderOptions(MemorySegment struct) {
        return struct.get(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public final static class GetDnnlProviderOptionsAsString {

        private GetDnnlProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetDnnlProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDnnlProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDnnlProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDnnlProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetDnnlProviderOptionsAsString$layout() {
        return GetDnnlProviderOptionsAsString$LAYOUT;
    }

    private static final long GetDnnlProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetDnnlProviderOptionsAsString"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final long GetDnnlProviderOptionsAsString$offset() {
        return GetDnnlProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetDnnlProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static void GetDnnlProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public final static class ReleaseDnnlProviderOptions {

        private ReleaseDnnlProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseDnnlProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseDnnlProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseDnnlProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static final AddressLayout ReleaseDnnlProviderOptions$layout() {
        return ReleaseDnnlProviderOptions$LAYOUT;
    }

    private static final long ReleaseDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseDnnlProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static final long ReleaseDnnlProviderOptions$offset() {
        return ReleaseDnnlProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static MemorySegment ReleaseDnnlProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static void ReleaseDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public final static class KernelInfo_GetNodeName {

        private KernelInfo_GetNodeName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetNodeName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetNodeName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetNodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetNodeName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetNodeName$layout() {
        return KernelInfo_GetNodeName$LAYOUT;
    }

    private static final long KernelInfo_GetNodeName$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetNodeName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static final long KernelInfo_GetNodeName$offset() {
        return KernelInfo_GetNodeName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetNodeName(MemorySegment struct) {
        return struct.get(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static void KernelInfo_GetNodeName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public final static class KernelInfo_GetLogger {

        private KernelInfo_GetLogger() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfo_GetLogger.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetLogger.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetLogger"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static final AddressLayout KernelInfo_GetLogger$layout() {
        return KernelInfo_GetLogger$LAYOUT;
    }

    private static final long KernelInfo_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetLogger"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static final long KernelInfo_GetLogger$offset() {
        return KernelInfo_GetLogger$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static MemorySegment KernelInfo_GetLogger(MemorySegment struct) {
        return struct.get(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static void KernelInfo_GetLogger(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public final static class KernelContext_GetLogger {

        private KernelContext_GetLogger() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetLogger.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetLogger.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetLogger"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static final AddressLayout KernelContext_GetLogger$layout() {
        return KernelContext_GetLogger$LAYOUT;
    }

    private static final long KernelContext_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetLogger"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static final long KernelContext_GetLogger$offset() {
        return KernelContext_GetLogger$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static MemorySegment KernelContext_GetLogger(MemorySegment struct) {
        return struct.get(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static void KernelContext_GetLogger(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public final static class Logger_LogMessage {

        private Logger_LogMessage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Logger_LogMessage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Logger_LogMessage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Logger_LogMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Logger_LogMessage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static final AddressLayout Logger_LogMessage$layout() {
        return Logger_LogMessage$LAYOUT;
    }

    private static final long Logger_LogMessage$OFFSET = $LAYOUT.byteOffset(groupElement("Logger_LogMessage"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static final long Logger_LogMessage$offset() {
        return Logger_LogMessage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static MemorySegment Logger_LogMessage(MemorySegment struct) {
        return struct.get(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static void Logger_LogMessage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public final static class Logger_GetLoggingSeverityLevel {

        private Logger_GetLoggingSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Logger_GetLoggingSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Logger_GetLoggingSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Logger_GetLoggingSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Logger_GetLoggingSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static final AddressLayout Logger_GetLoggingSeverityLevel$layout() {
        return Logger_GetLoggingSeverityLevel$LAYOUT;
    }

    private static final long Logger_GetLoggingSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("Logger_GetLoggingSeverityLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static final long Logger_GetLoggingSeverityLevel$offset() {
        return Logger_GetLoggingSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static MemorySegment Logger_GetLoggingSeverityLevel(MemorySegment struct) {
        return struct.get(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static void Logger_GetLoggingSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public final static class KernelInfoGetConstantInput_tensor {

        private KernelInfoGetConstantInput_tensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetConstantInput_tensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetConstantInput_tensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetConstantInput_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetConstantInput_tensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static final AddressLayout KernelInfoGetConstantInput_tensor$layout() {
        return KernelInfoGetConstantInput_tensor$LAYOUT;
    }

    private static final long KernelInfoGetConstantInput_tensor$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetConstantInput_tensor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static final long KernelInfoGetConstantInput_tensor$offset() {
        return KernelInfoGetConstantInput_tensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static MemorySegment KernelInfoGetConstantInput_tensor(MemorySegment struct) {
        return struct.get(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static void KernelInfoGetConstantInput_tensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public final static class CastTypeInfoToOptionalTypeInfo {

        private CastTypeInfoToOptionalTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CastTypeInfoToOptionalTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToOptionalTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToOptionalTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToOptionalTypeInfo$layout() {
        return CastTypeInfoToOptionalTypeInfo$LAYOUT;
    }

    private static final long CastTypeInfoToOptionalTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToOptionalTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static final long CastTypeInfoToOptionalTypeInfo$offset() {
        return CastTypeInfoToOptionalTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToOptionalTypeInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static void CastTypeInfoToOptionalTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public final static class GetOptionalContainedTypeInfo {

        private GetOptionalContainedTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOptionalContainedTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOptionalContainedTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOptionalContainedTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOptionalContainedTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetOptionalContainedTypeInfo$layout() {
        return GetOptionalContainedTypeInfo$LAYOUT;
    }

    private static final long GetOptionalContainedTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetOptionalContainedTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long GetOptionalContainedTypeInfo$offset() {
        return GetOptionalContainedTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetOptionalContainedTypeInfo(MemorySegment struct) {
        return struct.get(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void GetOptionalContainedTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public final static class GetResizedStringTensorElementBuffer {

        private GetResizedStringTensorElementBuffer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetResizedStringTensorElementBuffer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetResizedStringTensorElementBuffer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetResizedStringTensorElementBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetResizedStringTensorElementBuffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static final AddressLayout GetResizedStringTensorElementBuffer$layout() {
        return GetResizedStringTensorElementBuffer$LAYOUT;
    }

    private static final long GetResizedStringTensorElementBuffer$OFFSET = $LAYOUT.byteOffset(groupElement("GetResizedStringTensorElementBuffer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static final long GetResizedStringTensorElementBuffer$offset() {
        return GetResizedStringTensorElementBuffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static MemorySegment GetResizedStringTensorElementBuffer(MemorySegment struct) {
        return struct.get(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static void GetResizedStringTensorElementBuffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public final static class KernelContext_GetAllocator {

        private KernelContext_GetAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final AddressLayout KernelContext_GetAllocator$layout() {
        return KernelContext_GetAllocator$LAYOUT;
    }

    private static final long KernelContext_GetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final long KernelContext_GetAllocator$offset() {
        return KernelContext_GetAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment KernelContext_GetAllocator(MemorySegment struct) {
        return struct.get(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static void KernelContext_GetAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public final static class GetBuildInfoString {

        private GetBuildInfoString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetBuildInfoString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBuildInfoString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBuildInfoString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBuildInfoString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static final AddressLayout GetBuildInfoString$layout() {
        return GetBuildInfoString$LAYOUT;
    }

    private static final long GetBuildInfoString$OFFSET = $LAYOUT.byteOffset(groupElement("GetBuildInfoString"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static final long GetBuildInfoString$offset() {
        return GetBuildInfoString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static MemorySegment GetBuildInfoString(MemorySegment struct) {
        return struct.get(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static void GetBuildInfoString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public final static class CreateROCMProviderOptions {

        private CreateROCMProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateROCMProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateROCMProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateROCMProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static final AddressLayout CreateROCMProviderOptions$layout() {
        return CreateROCMProviderOptions$LAYOUT;
    }

    private static final long CreateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateROCMProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static final long CreateROCMProviderOptions$offset() {
        return CreateROCMProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static MemorySegment CreateROCMProviderOptions(MemorySegment struct) {
        return struct.get(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static void CreateROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class UpdateROCMProviderOptions {

        private UpdateROCMProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateROCMProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateROCMProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateROCMProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateROCMProviderOptions$layout() {
        return UpdateROCMProviderOptions$LAYOUT;
    }

    private static final long UpdateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateROCMProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateROCMProviderOptions$offset() {
        return UpdateROCMProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateROCMProviderOptions(MemorySegment struct) {
        return struct.get(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public final static class GetROCMProviderOptionsAsString {

        private GetROCMProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetROCMProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetROCMProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetROCMProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetROCMProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetROCMProviderOptionsAsString$layout() {
        return GetROCMProviderOptionsAsString$LAYOUT;
    }

    private static final long GetROCMProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetROCMProviderOptionsAsString"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final long GetROCMProviderOptionsAsString$offset() {
        return GetROCMProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetROCMProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static void GetROCMProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public final static class ReleaseROCMProviderOptions {

        private ReleaseROCMProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseROCMProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseROCMProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseROCMProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static final AddressLayout ReleaseROCMProviderOptions$layout() {
        return ReleaseROCMProviderOptions$LAYOUT;
    }

    private static final long ReleaseROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseROCMProviderOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static final long ReleaseROCMProviderOptions$offset() {
        return ReleaseROCMProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static MemorySegment ReleaseROCMProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static void ReleaseROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class CreateAndRegisterAllocatorV2 {

        private CreateAndRegisterAllocatorV2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateAndRegisterAllocatorV2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateAndRegisterAllocatorV2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateAndRegisterAllocatorV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateAndRegisterAllocatorV2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout CreateAndRegisterAllocatorV2$layout() {
        return CreateAndRegisterAllocatorV2$LAYOUT;
    }

    private static final long CreateAndRegisterAllocatorV2$OFFSET = $LAYOUT.byteOffset(groupElement("CreateAndRegisterAllocatorV2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long CreateAndRegisterAllocatorV2$offset() {
        return CreateAndRegisterAllocatorV2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment CreateAndRegisterAllocatorV2(MemorySegment struct) {
        return struct.get(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void CreateAndRegisterAllocatorV2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public final static class RunAsync {

        private RunAsync() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunAsync.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunAsync.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunAsync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunAsync"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static final AddressLayout RunAsync$layout() {
        return RunAsync$LAYOUT;
    }

    private static final long RunAsync$OFFSET = $LAYOUT.byteOffset(groupElement("RunAsync"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static final long RunAsync$offset() {
        return RunAsync$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static MemorySegment RunAsync(MemorySegment struct) {
        return struct.get(RunAsync$LAYOUT, RunAsync$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static void RunAsync(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunAsync$LAYOUT, RunAsync$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public final static class UpdateTensorRTProviderOptionsWithValue {

        private UpdateTensorRTProviderOptionsWithValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateTensorRTProviderOptionsWithValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateTensorRTProviderOptionsWithValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateTensorRTProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateTensorRTProviderOptionsWithValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final AddressLayout UpdateTensorRTProviderOptionsWithValue$layout() {
        return UpdateTensorRTProviderOptionsWithValue$LAYOUT;
    }

    private static final long UpdateTensorRTProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateTensorRTProviderOptionsWithValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final long UpdateTensorRTProviderOptionsWithValue$offset() {
        return UpdateTensorRTProviderOptionsWithValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static MemorySegment UpdateTensorRTProviderOptionsWithValue(MemorySegment struct) {
        return struct.get(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static void UpdateTensorRTProviderOptionsWithValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public final static class GetTensorRTProviderOptionsByName {

        private GetTensorRTProviderOptionsByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorRTProviderOptionsByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorRTProviderOptionsByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorRTProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorRTProviderOptionsByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final AddressLayout GetTensorRTProviderOptionsByName$layout() {
        return GetTensorRTProviderOptionsByName$LAYOUT;
    }

    private static final long GetTensorRTProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorRTProviderOptionsByName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final long GetTensorRTProviderOptionsByName$offset() {
        return GetTensorRTProviderOptionsByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static MemorySegment GetTensorRTProviderOptionsByName(MemorySegment struct) {
        return struct.get(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static void GetTensorRTProviderOptionsByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public final static class UpdateCUDAProviderOptionsWithValue {

        private UpdateCUDAProviderOptionsWithValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UpdateCUDAProviderOptionsWithValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateCUDAProviderOptionsWithValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateCUDAProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateCUDAProviderOptionsWithValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final AddressLayout UpdateCUDAProviderOptionsWithValue$layout() {
        return UpdateCUDAProviderOptionsWithValue$LAYOUT;
    }

    private static final long UpdateCUDAProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateCUDAProviderOptionsWithValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final long UpdateCUDAProviderOptionsWithValue$offset() {
        return UpdateCUDAProviderOptionsWithValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static MemorySegment UpdateCUDAProviderOptionsWithValue(MemorySegment struct) {
        return struct.get(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static void UpdateCUDAProviderOptionsWithValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public final static class GetCUDAProviderOptionsByName {

        private GetCUDAProviderOptionsByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetCUDAProviderOptionsByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCUDAProviderOptionsByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCUDAProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCUDAProviderOptionsByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final AddressLayout GetCUDAProviderOptionsByName$layout() {
        return GetCUDAProviderOptionsByName$LAYOUT;
    }

    private static final long GetCUDAProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement("GetCUDAProviderOptionsByName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final long GetCUDAProviderOptionsByName$offset() {
        return GetCUDAProviderOptionsByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static MemorySegment GetCUDAProviderOptionsByName(MemorySegment struct) {
        return struct.get(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static void GetCUDAProviderOptionsByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public final static class KernelContext_GetResource {

        private KernelContext_GetResource() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetResource.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetResource.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetResource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetResource"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static final AddressLayout KernelContext_GetResource$layout() {
        return KernelContext_GetResource$LAYOUT;
    }

    private static final long KernelContext_GetResource$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetResource"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static final long KernelContext_GetResource$offset() {
        return KernelContext_GetResource$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static MemorySegment KernelContext_GetResource(MemorySegment struct) {
        return struct.get(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static void KernelContext_GetResource(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public final static class SetUserLoggingFunction {

        private SetUserLoggingFunction() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetUserLoggingFunction.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetUserLoggingFunction.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetUserLoggingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetUserLoggingFunction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static final AddressLayout SetUserLoggingFunction$layout() {
        return SetUserLoggingFunction$LAYOUT;
    }

    private static final long SetUserLoggingFunction$OFFSET = $LAYOUT.byteOffset(groupElement("SetUserLoggingFunction"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static final long SetUserLoggingFunction$offset() {
        return SetUserLoggingFunction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static MemorySegment SetUserLoggingFunction(MemorySegment struct) {
        return struct.get(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static void SetUserLoggingFunction(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public final static class ShapeInferContext_GetInputCount {

        private ShapeInferContext_GetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ShapeInferContext_GetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_GetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_GetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static final AddressLayout ShapeInferContext_GetInputCount$layout() {
        return ShapeInferContext_GetInputCount$LAYOUT;
    }

    private static final long ShapeInferContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_GetInputCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static final long ShapeInferContext_GetInputCount$offset() {
        return ShapeInferContext_GetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static MemorySegment ShapeInferContext_GetInputCount(MemorySegment struct) {
        return struct.get(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static void ShapeInferContext_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public final static class ShapeInferContext_GetInputTypeShape {

        private ShapeInferContext_GetInputTypeShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ShapeInferContext_GetInputTypeShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_GetInputTypeShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_GetInputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_GetInputTypeShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout ShapeInferContext_GetInputTypeShape$layout() {
        return ShapeInferContext_GetInputTypeShape$LAYOUT;
    }

    private static final long ShapeInferContext_GetInputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_GetInputTypeShape"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long ShapeInferContext_GetInputTypeShape$offset() {
        return ShapeInferContext_GetInputTypeShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment ShapeInferContext_GetInputTypeShape(MemorySegment struct) {
        return struct.get(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void ShapeInferContext_GetInputTypeShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public final static class ShapeInferContext_GetAttribute {

        private ShapeInferContext_GetAttribute() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ShapeInferContext_GetAttribute.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_GetAttribute.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_GetAttribute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_GetAttribute"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static final AddressLayout ShapeInferContext_GetAttribute$layout() {
        return ShapeInferContext_GetAttribute$LAYOUT;
    }

    private static final long ShapeInferContext_GetAttribute$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_GetAttribute"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static final long ShapeInferContext_GetAttribute$offset() {
        return ShapeInferContext_GetAttribute$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static MemorySegment ShapeInferContext_GetAttribute(MemorySegment struct) {
        return struct.get(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static void ShapeInferContext_GetAttribute(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public final static class ShapeInferContext_SetOutputTypeShape {

        private ShapeInferContext_SetOutputTypeShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ShapeInferContext_SetOutputTypeShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_SetOutputTypeShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_SetOutputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_SetOutputTypeShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final AddressLayout ShapeInferContext_SetOutputTypeShape$layout() {
        return ShapeInferContext_SetOutputTypeShape$LAYOUT;
    }

    private static final long ShapeInferContext_SetOutputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_SetOutputTypeShape"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final long ShapeInferContext_SetOutputTypeShape$offset() {
        return ShapeInferContext_SetOutputTypeShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static MemorySegment ShapeInferContext_SetOutputTypeShape(MemorySegment struct) {
        return struct.get(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static void ShapeInferContext_SetOutputTypeShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public final static class SetSymbolicDimensions {

        private SetSymbolicDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetSymbolicDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSymbolicDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSymbolicDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final AddressLayout SetSymbolicDimensions$layout() {
        return SetSymbolicDimensions$LAYOUT;
    }

    private static final long SetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("SetSymbolicDimensions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final long SetSymbolicDimensions$offset() {
        return SetSymbolicDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static MemorySegment SetSymbolicDimensions(MemorySegment struct) {
        return struct.get(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static void SetSymbolicDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public final static class ReadOpAttr {

        private ReadOpAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReadOpAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReadOpAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReadOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReadOpAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static final AddressLayout ReadOpAttr$layout() {
        return ReadOpAttr$LAYOUT;
    }

    private static final long ReadOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement("ReadOpAttr"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static final long ReadOpAttr$offset() {
        return ReadOpAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static MemorySegment ReadOpAttr(MemorySegment struct) {
        return struct.get(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static void ReadOpAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public final static class SetDeterministicCompute {

        private SetDeterministicCompute() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, boolean _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetDeterministicCompute.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetDeterministicCompute.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, boolean _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetDeterministicCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetDeterministicCompute"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static final AddressLayout SetDeterministicCompute$layout() {
        return SetDeterministicCompute$LAYOUT;
    }

    private static final long SetDeterministicCompute$OFFSET = $LAYOUT.byteOffset(groupElement("SetDeterministicCompute"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static final long SetDeterministicCompute$offset() {
        return SetDeterministicCompute$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static MemorySegment SetDeterministicCompute(MemorySegment struct) {
        return struct.get(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static void SetDeterministicCompute(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public final static class KernelContext_ParallelFor {

        private KernelContext_ParallelFor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_ParallelFor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_ParallelFor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_ParallelFor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_ParallelFor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static final AddressLayout KernelContext_ParallelFor$layout() {
        return KernelContext_ParallelFor$LAYOUT;
    }

    private static final long KernelContext_ParallelFor$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_ParallelFor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static final long KernelContext_ParallelFor$offset() {
        return KernelContext_ParallelFor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static MemorySegment KernelContext_ParallelFor(MemorySegment struct) {
        return struct.get(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static void KernelContext_ParallelFor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_OpenVINO_V2 {

        private SessionOptionsAppendExecutionProvider_OpenVINO_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$layout() {
        return SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO_V2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$offset() {
        return SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_VitisAI {

        private SessionOptionsAppendExecutionProvider_VitisAI() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_VitisAI.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_VitisAI.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_VitisAI"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$layout() {
        return SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_VitisAI$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_VitisAI"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_VitisAI$offset() {
        return SessionOptionsAppendExecutionProvider_VitisAI$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public final static class KernelContext_GetScratchBuffer {

        private KernelContext_GetScratchBuffer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelContext_GetScratchBuffer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetScratchBuffer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetScratchBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetScratchBuffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static final AddressLayout KernelContext_GetScratchBuffer$layout() {
        return KernelContext_GetScratchBuffer$LAYOUT;
    }

    private static final long KernelContext_GetScratchBuffer$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetScratchBuffer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static final long KernelContext_GetScratchBuffer$offset() {
        return KernelContext_GetScratchBuffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static MemorySegment KernelContext_GetScratchBuffer(MemorySegment struct) {
        return struct.get(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static void KernelContext_GetScratchBuffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public final static class KernelInfoGetAllocator {

        private KernelInfoGetAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelInfoGetAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static final AddressLayout KernelInfoGetAllocator$layout() {
        return KernelInfoGetAllocator$LAYOUT;
    }

    private static final long KernelInfoGetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static final long KernelInfoGetAllocator$offset() {
        return KernelInfoGetAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static MemorySegment KernelInfoGetAllocator(MemorySegment struct) {
        return struct.get(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static void KernelInfoGetAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public final static class AddExternalInitializersFromFilesInMemory {

        private AddExternalInitializersFromFilesInMemory() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddExternalInitializersFromFilesInMemory.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddExternalInitializersFromFilesInMemory.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddExternalInitializersFromFilesInMemory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddExternalInitializersFromFilesInMemory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static final AddressLayout AddExternalInitializersFromFilesInMemory$layout() {
        return AddExternalInitializersFromFilesInMemory$LAYOUT;
    }

    private static final long AddExternalInitializersFromFilesInMemory$OFFSET = $LAYOUT.byteOffset(groupElement("AddExternalInitializersFromFilesInMemory"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static final long AddExternalInitializersFromFilesInMemory$offset() {
        return AddExternalInitializersFromFilesInMemory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static MemorySegment AddExternalInitializersFromFilesInMemory(MemorySegment struct) {
        return struct.get(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static void AddExternalInitializersFromFilesInMemory(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public final static class CreateLoraAdapter {

        private CreateLoraAdapter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateLoraAdapter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateLoraAdapter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateLoraAdapter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final AddressLayout CreateLoraAdapter$layout() {
        return CreateLoraAdapter$LAYOUT;
    }

    private static final long CreateLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement("CreateLoraAdapter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final long CreateLoraAdapter$offset() {
        return CreateLoraAdapter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static MemorySegment CreateLoraAdapter(MemorySegment struct) {
        return struct.get(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static void CreateLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public final static class CreateLoraAdapterFromArray {

        private CreateLoraAdapterFromArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateLoraAdapterFromArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateLoraAdapterFromArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateLoraAdapterFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateLoraAdapterFromArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final AddressLayout CreateLoraAdapterFromArray$layout() {
        return CreateLoraAdapterFromArray$LAYOUT;
    }

    private static final long CreateLoraAdapterFromArray$OFFSET = $LAYOUT.byteOffset(groupElement("CreateLoraAdapterFromArray"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final long CreateLoraAdapterFromArray$offset() {
        return CreateLoraAdapterFromArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static MemorySegment CreateLoraAdapterFromArray(MemorySegment struct) {
        return struct.get(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static void CreateLoraAdapterFromArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public final static class ReleaseLoraAdapter {

        private ReleaseLoraAdapter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseLoraAdapter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseLoraAdapter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseLoraAdapter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static final AddressLayout ReleaseLoraAdapter$layout() {
        return ReleaseLoraAdapter$LAYOUT;
    }

    private static final long ReleaseLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseLoraAdapter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static final long ReleaseLoraAdapter$offset() {
        return ReleaseLoraAdapter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static MemorySegment ReleaseLoraAdapter(MemorySegment struct) {
        return struct.get(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static void ReleaseLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public final static class RunOptionsAddActiveLoraAdapter {

        private RunOptionsAddActiveLoraAdapter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunOptionsAddActiveLoraAdapter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsAddActiveLoraAdapter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsAddActiveLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsAddActiveLoraAdapter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static final AddressLayout RunOptionsAddActiveLoraAdapter$layout() {
        return RunOptionsAddActiveLoraAdapter$LAYOUT;
    }

    private static final long RunOptionsAddActiveLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsAddActiveLoraAdapter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static final long RunOptionsAddActiveLoraAdapter$offset() {
        return RunOptionsAddActiveLoraAdapter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static MemorySegment RunOptionsAddActiveLoraAdapter(MemorySegment struct) {
        return struct.get(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static void RunOptionsAddActiveLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class SetEpDynamicOptions {

        private SetEpDynamicOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetEpDynamicOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetEpDynamicOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetEpDynamicOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetEpDynamicOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SetEpDynamicOptions$layout() {
        return SetEpDynamicOptions$LAYOUT;
    }

    private static final long SetEpDynamicOptions$OFFSET = $LAYOUT.byteOffset(groupElement("SetEpDynamicOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SetEpDynamicOptions$offset() {
        return SetEpDynamicOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SetEpDynamicOptions(MemorySegment struct) {
        return struct.get(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SetEpDynamicOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseValueInfo)(OrtValueInfo *)
     * }
     */
    public final static class ReleaseValueInfo {

        private ReleaseValueInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseValueInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseValueInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseValueInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseValueInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseValueInfo)(OrtValueInfo *)
     * }
     */
    public static final AddressLayout ReleaseValueInfo$layout() {
        return ReleaseValueInfo$LAYOUT;
    }

    private static final long ReleaseValueInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseValueInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseValueInfo)(OrtValueInfo *)
     * }
     */
    public static final long ReleaseValueInfo$offset() {
        return ReleaseValueInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseValueInfo)(OrtValueInfo *)
     * }
     */
    public static MemorySegment ReleaseValueInfo(MemorySegment struct) {
        return struct.get(ReleaseValueInfo$LAYOUT, ReleaseValueInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseValueInfo)(OrtValueInfo *)
     * }
     */
    public static void ReleaseValueInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseValueInfo$LAYOUT, ReleaseValueInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseNode)(OrtNode *)
     * }
     */
    public final static class ReleaseNode {

        private ReleaseNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseNode)(OrtNode *)
     * }
     */
    public static final AddressLayout ReleaseNode$layout() {
        return ReleaseNode$LAYOUT;
    }

    private static final long ReleaseNode$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseNode"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseNode)(OrtNode *)
     * }
     */
    public static final long ReleaseNode$offset() {
        return ReleaseNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseNode)(OrtNode *)
     * }
     */
    public static MemorySegment ReleaseNode(MemorySegment struct) {
        return struct.get(ReleaseNode$LAYOUT, ReleaseNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseNode)(OrtNode *)
     * }
     */
    public static void ReleaseNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseNode$LAYOUT, ReleaseNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseGraph)(OrtGraph *)
     * }
     */
    public final static class ReleaseGraph {

        private ReleaseGraph() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseGraph.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseGraph.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseGraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseGraph)(OrtGraph *)
     * }
     */
    public static final AddressLayout ReleaseGraph$layout() {
        return ReleaseGraph$LAYOUT;
    }

    private static final long ReleaseGraph$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseGraph"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseGraph)(OrtGraph *)
     * }
     */
    public static final long ReleaseGraph$offset() {
        return ReleaseGraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseGraph)(OrtGraph *)
     * }
     */
    public static MemorySegment ReleaseGraph(MemorySegment struct) {
        return struct.get(ReleaseGraph$LAYOUT, ReleaseGraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseGraph)(OrtGraph *)
     * }
     */
    public static void ReleaseGraph(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseGraph$LAYOUT, ReleaseGraph$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseModel)(OrtModel *)
     * }
     */
    public final static class ReleaseModel {

        private ReleaseModel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseModel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseModel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseModel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseModel)(OrtModel *)
     * }
     */
    public static final AddressLayout ReleaseModel$layout() {
        return ReleaseModel$LAYOUT;
    }

    private static final long ReleaseModel$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseModel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseModel)(OrtModel *)
     * }
     */
    public static final long ReleaseModel$offset() {
        return ReleaseModel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseModel)(OrtModel *)
     * }
     */
    public static MemorySegment ReleaseModel(MemorySegment struct) {
        return struct.get(ReleaseModel$LAYOUT, ReleaseModel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseModel)(OrtModel *)
     * }
     */
    public static void ReleaseModel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseModel$LAYOUT, ReleaseModel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)
     * }
     */
    public final static class GetValueInfoName {

        private GetValueInfoName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetValueInfoName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValueInfoName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValueInfoName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValueInfoName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)
     * }
     */
    public static final AddressLayout GetValueInfoName$layout() {
        return GetValueInfoName$LAYOUT;
    }

    private static final long GetValueInfoName$OFFSET = $LAYOUT.byteOffset(groupElement("GetValueInfoName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)
     * }
     */
    public static final long GetValueInfoName$offset() {
        return GetValueInfoName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)
     * }
     */
    public static MemorySegment GetValueInfoName(MemorySegment struct) {
        return struct.get(GetValueInfoName$LAYOUT, GetValueInfoName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)
     * }
     */
    public static void GetValueInfoName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValueInfoName$LAYOUT, GetValueInfoName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)
     * }
     */
    public final static class GetValueInfoTypeInfo {

        private GetValueInfoTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetValueInfoTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValueInfoTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValueInfoTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValueInfoTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetValueInfoTypeInfo$layout() {
        return GetValueInfoTypeInfo$LAYOUT;
    }

    private static final long GetValueInfoTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetValueInfoTypeInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)
     * }
     */
    public static final long GetValueInfoTypeInfo$offset() {
        return GetValueInfoTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetValueInfoTypeInfo(MemorySegment struct) {
        return struct.get(GetValueInfoTypeInfo$LAYOUT, GetValueInfoTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)
     * }
     */
    public static void GetValueInfoTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValueInfoTypeInfo$LAYOUT, GetValueInfoTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtModelEditorApi *(*GetModelEditorApi)()
     * }
     */
    public final static class GetModelEditorApi {

        private GetModelEditorApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetModelEditorApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetModelEditorApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetModelEditorApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetModelEditorApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtModelEditorApi *(*GetModelEditorApi)()
     * }
     */
    public static final AddressLayout GetModelEditorApi$layout() {
        return GetModelEditorApi$LAYOUT;
    }

    private static final long GetModelEditorApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetModelEditorApi"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtModelEditorApi *(*GetModelEditorApi)()
     * }
     */
    public static final long GetModelEditorApi$offset() {
        return GetModelEditorApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtModelEditorApi *(*GetModelEditorApi)()
     * }
     */
    public static MemorySegment GetModelEditorApi(MemorySegment struct) {
        return struct.get(GetModelEditorApi$LAYOUT, GetModelEditorApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtModelEditorApi *(*GetModelEditorApi)()
     * }
     */
    public static void GetModelEditorApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetModelEditorApi$LAYOUT, GetModelEditorApi$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public final static class CreateTensorWithDataAndDeleterAsOrtValue {

        private CreateTensorWithDataAndDeleterAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorWithDataAndDeleterAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorWithDataAndDeleterAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorWithDataAndDeleterAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateTensorWithDataAndDeleterAsOrtValue$layout() {
        return CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT;
    }

    private static final long CreateTensorWithDataAndDeleterAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorWithDataAndDeleterAsOrtValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateTensorWithDataAndDeleterAsOrtValue$offset() {
        return CreateTensorWithDataAndDeleterAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorWithDataAndDeleterAsOrtValue(MemorySegment struct) {
        return struct.get(CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT, CreateTensorWithDataAndDeleterAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateTensorWithDataAndDeleterAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT, CreateTensorWithDataAndDeleterAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)
     * }
     */
    public final static class SessionOptionsSetLoadCancellationFlag {

        private SessionOptionsSetLoadCancellationFlag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, boolean _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsSetLoadCancellationFlag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetLoadCancellationFlag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, boolean _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetLoadCancellationFlag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetLoadCancellationFlag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)
     * }
     */
    public static final AddressLayout SessionOptionsSetLoadCancellationFlag$layout() {
        return SessionOptionsSetLoadCancellationFlag$LAYOUT;
    }

    private static final long SessionOptionsSetLoadCancellationFlag$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetLoadCancellationFlag"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)
     * }
     */
    public static final long SessionOptionsSetLoadCancellationFlag$offset() {
        return SessionOptionsSetLoadCancellationFlag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)
     * }
     */
    public static MemorySegment SessionOptionsSetLoadCancellationFlag(MemorySegment struct) {
        return struct.get(SessionOptionsSetLoadCancellationFlag$LAYOUT, SessionOptionsSetLoadCancellationFlag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)
     * }
     */
    public static void SessionOptionsSetLoadCancellationFlag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetLoadCancellationFlag$LAYOUT, SessionOptionsSetLoadCancellationFlag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtCompileApi *(*GetCompileApi)()
     * }
     */
    public final static class GetCompileApi {

        private GetCompileApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetCompileApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCompileApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCompileApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCompileApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtCompileApi *(*GetCompileApi)()
     * }
     */
    public static final AddressLayout GetCompileApi$layout() {
        return GetCompileApi$LAYOUT;
    }

    private static final long GetCompileApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetCompileApi"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtCompileApi *(*GetCompileApi)()
     * }
     */
    public static final long GetCompileApi$offset() {
        return GetCompileApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtCompileApi *(*GetCompileApi)()
     * }
     */
    public static MemorySegment GetCompileApi(MemorySegment struct) {
        return struct.get(GetCompileApi$LAYOUT, GetCompileApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtCompileApi *(*GetCompileApi)()
     * }
     */
    public static void GetCompileApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCompileApi$LAYOUT, GetCompileApi$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)
     * }
     */
    public final static class CreateKeyValuePairs {

        private CreateKeyValuePairs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateKeyValuePairs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateKeyValuePairs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateKeyValuePairs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateKeyValuePairs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)
     * }
     */
    public static final AddressLayout CreateKeyValuePairs$layout() {
        return CreateKeyValuePairs$LAYOUT;
    }

    private static final long CreateKeyValuePairs$OFFSET = $LAYOUT.byteOffset(groupElement("CreateKeyValuePairs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)
     * }
     */
    public static final long CreateKeyValuePairs$offset() {
        return CreateKeyValuePairs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)
     * }
     */
    public static MemorySegment CreateKeyValuePairs(MemorySegment struct) {
        return struct.get(CreateKeyValuePairs$LAYOUT, CreateKeyValuePairs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)
     * }
     */
    public static void CreateKeyValuePairs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateKeyValuePairs$LAYOUT, CreateKeyValuePairs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)
     * }
     */
    public final static class AddKeyValuePair {

        private AddKeyValuePair() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddKeyValuePair.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddKeyValuePair.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddKeyValuePair$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddKeyValuePair"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)
     * }
     */
    public static final AddressLayout AddKeyValuePair$layout() {
        return AddKeyValuePair$LAYOUT;
    }

    private static final long AddKeyValuePair$OFFSET = $LAYOUT.byteOffset(groupElement("AddKeyValuePair"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)
     * }
     */
    public static final long AddKeyValuePair$offset() {
        return AddKeyValuePair$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)
     * }
     */
    public static MemorySegment AddKeyValuePair(MemorySegment struct) {
        return struct.get(AddKeyValuePair$LAYOUT, AddKeyValuePair$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)
     * }
     */
    public static void AddKeyValuePair(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddKeyValuePair$LAYOUT, AddKeyValuePair$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)
     * }
     */
    public final static class GetKeyValue {

        private GetKeyValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetKeyValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetKeyValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetKeyValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetKeyValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)
     * }
     */
    public static final AddressLayout GetKeyValue$layout() {
        return GetKeyValue$LAYOUT;
    }

    private static final long GetKeyValue$OFFSET = $LAYOUT.byteOffset(groupElement("GetKeyValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)
     * }
     */
    public static final long GetKeyValue$offset() {
        return GetKeyValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)
     * }
     */
    public static MemorySegment GetKeyValue(MemorySegment struct) {
        return struct.get(GetKeyValue$LAYOUT, GetKeyValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)
     * }
     */
    public static void GetKeyValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetKeyValue$LAYOUT, GetKeyValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)
     * }
     */
    public final static class GetKeyValuePairs {

        private GetKeyValuePairs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetKeyValuePairs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetKeyValuePairs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetKeyValuePairs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetKeyValuePairs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)
     * }
     */
    public static final AddressLayout GetKeyValuePairs$layout() {
        return GetKeyValuePairs$LAYOUT;
    }

    private static final long GetKeyValuePairs$OFFSET = $LAYOUT.byteOffset(groupElement("GetKeyValuePairs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)
     * }
     */
    public static final long GetKeyValuePairs$offset() {
        return GetKeyValuePairs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)
     * }
     */
    public static MemorySegment GetKeyValuePairs(MemorySegment struct) {
        return struct.get(GetKeyValuePairs$LAYOUT, GetKeyValuePairs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)
     * }
     */
    public static void GetKeyValuePairs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetKeyValuePairs$LAYOUT, GetKeyValuePairs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)
     * }
     */
    public final static class RemoveKeyValuePair {

        private RemoveKeyValuePair() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RemoveKeyValuePair.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RemoveKeyValuePair.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RemoveKeyValuePair$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RemoveKeyValuePair"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)
     * }
     */
    public static final AddressLayout RemoveKeyValuePair$layout() {
        return RemoveKeyValuePair$LAYOUT;
    }

    private static final long RemoveKeyValuePair$OFFSET = $LAYOUT.byteOffset(groupElement("RemoveKeyValuePair"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)
     * }
     */
    public static final long RemoveKeyValuePair$offset() {
        return RemoveKeyValuePair$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)
     * }
     */
    public static MemorySegment RemoveKeyValuePair(MemorySegment struct) {
        return struct.get(RemoveKeyValuePair$LAYOUT, RemoveKeyValuePair$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)
     * }
     */
    public static void RemoveKeyValuePair(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RemoveKeyValuePair$LAYOUT, RemoveKeyValuePair$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)
     * }
     */
    public final static class ReleaseKeyValuePairs {

        private ReleaseKeyValuePairs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseKeyValuePairs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseKeyValuePairs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseKeyValuePairs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseKeyValuePairs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)
     * }
     */
    public static final AddressLayout ReleaseKeyValuePairs$layout() {
        return ReleaseKeyValuePairs$LAYOUT;
    }

    private static final long ReleaseKeyValuePairs$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseKeyValuePairs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)
     * }
     */
    public static final long ReleaseKeyValuePairs$offset() {
        return ReleaseKeyValuePairs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)
     * }
     */
    public static MemorySegment ReleaseKeyValuePairs(MemorySegment struct) {
        return struct.get(ReleaseKeyValuePairs$LAYOUT, ReleaseKeyValuePairs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)
     * }
     */
    public static void ReleaseKeyValuePairs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseKeyValuePairs$LAYOUT, ReleaseKeyValuePairs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)
     * }
     */
    public final static class RegisterExecutionProviderLibrary {

        private RegisterExecutionProviderLibrary() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RegisterExecutionProviderLibrary.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterExecutionProviderLibrary.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterExecutionProviderLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterExecutionProviderLibrary"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)
     * }
     */
    public static final AddressLayout RegisterExecutionProviderLibrary$layout() {
        return RegisterExecutionProviderLibrary$LAYOUT;
    }

    private static final long RegisterExecutionProviderLibrary$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterExecutionProviderLibrary"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)
     * }
     */
    public static final long RegisterExecutionProviderLibrary$offset() {
        return RegisterExecutionProviderLibrary$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)
     * }
     */
    public static MemorySegment RegisterExecutionProviderLibrary(MemorySegment struct) {
        return struct.get(RegisterExecutionProviderLibrary$LAYOUT, RegisterExecutionProviderLibrary$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)
     * }
     */
    public static void RegisterExecutionProviderLibrary(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterExecutionProviderLibrary$LAYOUT, RegisterExecutionProviderLibrary$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)
     * }
     */
    public final static class UnregisterExecutionProviderLibrary {

        private UnregisterExecutionProviderLibrary() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(UnregisterExecutionProviderLibrary.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UnregisterExecutionProviderLibrary.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UnregisterExecutionProviderLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UnregisterExecutionProviderLibrary"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)
     * }
     */
    public static final AddressLayout UnregisterExecutionProviderLibrary$layout() {
        return UnregisterExecutionProviderLibrary$LAYOUT;
    }

    private static final long UnregisterExecutionProviderLibrary$OFFSET = $LAYOUT.byteOffset(groupElement("UnregisterExecutionProviderLibrary"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)
     * }
     */
    public static final long UnregisterExecutionProviderLibrary$offset() {
        return UnregisterExecutionProviderLibrary$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)
     * }
     */
    public static MemorySegment UnregisterExecutionProviderLibrary(MemorySegment struct) {
        return struct.get(UnregisterExecutionProviderLibrary$LAYOUT, UnregisterExecutionProviderLibrary$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)
     * }
     */
    public static void UnregisterExecutionProviderLibrary(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UnregisterExecutionProviderLibrary$LAYOUT, UnregisterExecutionProviderLibrary$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)
     * }
     */
    public final static class GetEpDevices {

        private GetEpDevices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetEpDevices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetEpDevices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetEpDevices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetEpDevices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)
     * }
     */
    public static final AddressLayout GetEpDevices$layout() {
        return GetEpDevices$LAYOUT;
    }

    private static final long GetEpDevices$OFFSET = $LAYOUT.byteOffset(groupElement("GetEpDevices"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)
     * }
     */
    public static final long GetEpDevices$offset() {
        return GetEpDevices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)
     * }
     */
    public static MemorySegment GetEpDevices(MemorySegment struct) {
        return struct.get(GetEpDevices$LAYOUT, GetEpDevices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)
     * }
     */
    public static void GetEpDevices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetEpDevices$LAYOUT, GetEpDevices$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)
     * }
     */
    public final static class SessionOptionsAppendExecutionProvider_V2 {

        private SessionOptionsAppendExecutionProvider_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsAppendExecutionProvider_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_V2$layout() {
        return SessionOptionsAppendExecutionProvider_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_V2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_V2$offset() {
        return SessionOptionsAppendExecutionProvider_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_V2(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider_V2$LAYOUT, SessionOptionsAppendExecutionProvider_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsAppendExecutionProvider_V2$LAYOUT, SessionOptionsAppendExecutionProvider_V2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)
     * }
     */
    public final static class SessionOptionsSetEpSelectionPolicy {

        private SessionOptionsSetEpSelectionPolicy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsSetEpSelectionPolicy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetEpSelectionPolicy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetEpSelectionPolicy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetEpSelectionPolicy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)
     * }
     */
    public static final AddressLayout SessionOptionsSetEpSelectionPolicy$layout() {
        return SessionOptionsSetEpSelectionPolicy$LAYOUT;
    }

    private static final long SessionOptionsSetEpSelectionPolicy$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetEpSelectionPolicy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)
     * }
     */
    public static final long SessionOptionsSetEpSelectionPolicy$offset() {
        return SessionOptionsSetEpSelectionPolicy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)
     * }
     */
    public static MemorySegment SessionOptionsSetEpSelectionPolicy(MemorySegment struct) {
        return struct.get(SessionOptionsSetEpSelectionPolicy$LAYOUT, SessionOptionsSetEpSelectionPolicy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)
     * }
     */
    public static void SessionOptionsSetEpSelectionPolicy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetEpSelectionPolicy$LAYOUT, SessionOptionsSetEpSelectionPolicy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)
     * }
     */
    public final static class SessionOptionsSetEpSelectionPolicyDelegate {

        private SessionOptionsSetEpSelectionPolicyDelegate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionOptionsSetEpSelectionPolicyDelegate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetEpSelectionPolicyDelegate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetEpSelectionPolicyDelegate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)
     * }
     */
    public static final AddressLayout SessionOptionsSetEpSelectionPolicyDelegate$layout() {
        return SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT;
    }

    private static final long SessionOptionsSetEpSelectionPolicyDelegate$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetEpSelectionPolicyDelegate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)
     * }
     */
    public static final long SessionOptionsSetEpSelectionPolicyDelegate$offset() {
        return SessionOptionsSetEpSelectionPolicyDelegate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)
     * }
     */
    public static MemorySegment SessionOptionsSetEpSelectionPolicyDelegate(MemorySegment struct) {
        return struct.get(SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT, SessionOptionsSetEpSelectionPolicyDelegate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)
     * }
     */
    public static void SessionOptionsSetEpSelectionPolicyDelegate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT, SessionOptionsSetEpSelectionPolicyDelegate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)
     * }
     */
    public final static class HardwareDevice_Type {

        private HardwareDevice_Type() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HardwareDevice_Type.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HardwareDevice_Type.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HardwareDevice_Type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HardwareDevice_Type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)
     * }
     */
    public static final AddressLayout HardwareDevice_Type$layout() {
        return HardwareDevice_Type$LAYOUT;
    }

    private static final long HardwareDevice_Type$OFFSET = $LAYOUT.byteOffset(groupElement("HardwareDevice_Type"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)
     * }
     */
    public static final long HardwareDevice_Type$offset() {
        return HardwareDevice_Type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)
     * }
     */
    public static MemorySegment HardwareDevice_Type(MemorySegment struct) {
        return struct.get(HardwareDevice_Type$LAYOUT, HardwareDevice_Type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)
     * }
     */
    public static void HardwareDevice_Type(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HardwareDevice_Type$LAYOUT, HardwareDevice_Type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)
     * }
     */
    public final static class HardwareDevice_VendorId {

        private HardwareDevice_VendorId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HardwareDevice_VendorId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HardwareDevice_VendorId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HardwareDevice_VendorId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HardwareDevice_VendorId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)
     * }
     */
    public static final AddressLayout HardwareDevice_VendorId$layout() {
        return HardwareDevice_VendorId$LAYOUT;
    }

    private static final long HardwareDevice_VendorId$OFFSET = $LAYOUT.byteOffset(groupElement("HardwareDevice_VendorId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)
     * }
     */
    public static final long HardwareDevice_VendorId$offset() {
        return HardwareDevice_VendorId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)
     * }
     */
    public static MemorySegment HardwareDevice_VendorId(MemorySegment struct) {
        return struct.get(HardwareDevice_VendorId$LAYOUT, HardwareDevice_VendorId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)
     * }
     */
    public static void HardwareDevice_VendorId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HardwareDevice_VendorId$LAYOUT, HardwareDevice_VendorId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)
     * }
     */
    public final static class HardwareDevice_Vendor {

        private HardwareDevice_Vendor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HardwareDevice_Vendor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HardwareDevice_Vendor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HardwareDevice_Vendor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HardwareDevice_Vendor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)
     * }
     */
    public static final AddressLayout HardwareDevice_Vendor$layout() {
        return HardwareDevice_Vendor$LAYOUT;
    }

    private static final long HardwareDevice_Vendor$OFFSET = $LAYOUT.byteOffset(groupElement("HardwareDevice_Vendor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)
     * }
     */
    public static final long HardwareDevice_Vendor$offset() {
        return HardwareDevice_Vendor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)
     * }
     */
    public static MemorySegment HardwareDevice_Vendor(MemorySegment struct) {
        return struct.get(HardwareDevice_Vendor$LAYOUT, HardwareDevice_Vendor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)
     * }
     */
    public static void HardwareDevice_Vendor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HardwareDevice_Vendor$LAYOUT, HardwareDevice_Vendor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)
     * }
     */
    public final static class HardwareDevice_DeviceId {

        private HardwareDevice_DeviceId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HardwareDevice_DeviceId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HardwareDevice_DeviceId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HardwareDevice_DeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HardwareDevice_DeviceId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)
     * }
     */
    public static final AddressLayout HardwareDevice_DeviceId$layout() {
        return HardwareDevice_DeviceId$LAYOUT;
    }

    private static final long HardwareDevice_DeviceId$OFFSET = $LAYOUT.byteOffset(groupElement("HardwareDevice_DeviceId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)
     * }
     */
    public static final long HardwareDevice_DeviceId$offset() {
        return HardwareDevice_DeviceId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)
     * }
     */
    public static MemorySegment HardwareDevice_DeviceId(MemorySegment struct) {
        return struct.get(HardwareDevice_DeviceId$LAYOUT, HardwareDevice_DeviceId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)
     * }
     */
    public static void HardwareDevice_DeviceId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HardwareDevice_DeviceId$LAYOUT, HardwareDevice_DeviceId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)
     * }
     */
    public final static class HardwareDevice_Metadata {

        private HardwareDevice_Metadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(HardwareDevice_Metadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HardwareDevice_Metadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HardwareDevice_Metadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HardwareDevice_Metadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)
     * }
     */
    public static final AddressLayout HardwareDevice_Metadata$layout() {
        return HardwareDevice_Metadata$LAYOUT;
    }

    private static final long HardwareDevice_Metadata$OFFSET = $LAYOUT.byteOffset(groupElement("HardwareDevice_Metadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)
     * }
     */
    public static final long HardwareDevice_Metadata$offset() {
        return HardwareDevice_Metadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)
     * }
     */
    public static MemorySegment HardwareDevice_Metadata(MemorySegment struct) {
        return struct.get(HardwareDevice_Metadata$LAYOUT, HardwareDevice_Metadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)
     * }
     */
    public static void HardwareDevice_Metadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HardwareDevice_Metadata$LAYOUT, HardwareDevice_Metadata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*EpDevice_EpName)(const OrtEpDevice *)
     * }
     */
    public final static class EpDevice_EpName {

        private EpDevice_EpName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_EpName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_EpName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_EpName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_EpName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpName)(const OrtEpDevice *)
     * }
     */
    public static final AddressLayout EpDevice_EpName$layout() {
        return EpDevice_EpName$LAYOUT;
    }

    private static final long EpDevice_EpName$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_EpName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpName)(const OrtEpDevice *)
     * }
     */
    public static final long EpDevice_EpName$offset() {
        return EpDevice_EpName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpName)(const OrtEpDevice *)
     * }
     */
    public static MemorySegment EpDevice_EpName(MemorySegment struct) {
        return struct.get(EpDevice_EpName$LAYOUT, EpDevice_EpName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpName)(const OrtEpDevice *)
     * }
     */
    public static void EpDevice_EpName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_EpName$LAYOUT, EpDevice_EpName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)
     * }
     */
    public final static class EpDevice_EpVendor {

        private EpDevice_EpVendor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_EpVendor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_EpVendor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_EpVendor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_EpVendor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)
     * }
     */
    public static final AddressLayout EpDevice_EpVendor$layout() {
        return EpDevice_EpVendor$LAYOUT;
    }

    private static final long EpDevice_EpVendor$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_EpVendor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)
     * }
     */
    public static final long EpDevice_EpVendor$offset() {
        return EpDevice_EpVendor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)
     * }
     */
    public static MemorySegment EpDevice_EpVendor(MemorySegment struct) {
        return struct.get(EpDevice_EpVendor$LAYOUT, EpDevice_EpVendor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)
     * }
     */
    public static void EpDevice_EpVendor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_EpVendor$LAYOUT, EpDevice_EpVendor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)
     * }
     */
    public final static class EpDevice_EpMetadata {

        private EpDevice_EpMetadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_EpMetadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_EpMetadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_EpMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_EpMetadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)
     * }
     */
    public static final AddressLayout EpDevice_EpMetadata$layout() {
        return EpDevice_EpMetadata$LAYOUT;
    }

    private static final long EpDevice_EpMetadata$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_EpMetadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)
     * }
     */
    public static final long EpDevice_EpMetadata$offset() {
        return EpDevice_EpMetadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)
     * }
     */
    public static MemorySegment EpDevice_EpMetadata(MemorySegment struct) {
        return struct.get(EpDevice_EpMetadata$LAYOUT, EpDevice_EpMetadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)
     * }
     */
    public static void EpDevice_EpMetadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_EpMetadata$LAYOUT, EpDevice_EpMetadata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)
     * }
     */
    public final static class EpDevice_EpOptions {

        private EpDevice_EpOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_EpOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_EpOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_EpOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_EpOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)
     * }
     */
    public static final AddressLayout EpDevice_EpOptions$layout() {
        return EpDevice_EpOptions$LAYOUT;
    }

    private static final long EpDevice_EpOptions$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_EpOptions"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)
     * }
     */
    public static final long EpDevice_EpOptions$offset() {
        return EpDevice_EpOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)
     * }
     */
    public static MemorySegment EpDevice_EpOptions(MemorySegment struct) {
        return struct.get(EpDevice_EpOptions$LAYOUT, EpDevice_EpOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)
     * }
     */
    public static void EpDevice_EpOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_EpOptions$LAYOUT, EpDevice_EpOptions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)
     * }
     */
    public final static class EpDevice_Device {

        private EpDevice_Device() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_Device.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_Device.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_Device$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_Device"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)
     * }
     */
    public static final AddressLayout EpDevice_Device$layout() {
        return EpDevice_Device$LAYOUT;
    }

    private static final long EpDevice_Device$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_Device"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)
     * }
     */
    public static final long EpDevice_Device$offset() {
        return EpDevice_Device$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)
     * }
     */
    public static MemorySegment EpDevice_Device(MemorySegment struct) {
        return struct.get(EpDevice_Device$LAYOUT, EpDevice_Device$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)
     * }
     */
    public static void EpDevice_Device(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_Device$LAYOUT, EpDevice_Device$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtEpApi *(*GetEpApi)()
     * }
     */
    public final static class GetEpApi {

        private GetEpApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetEpApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetEpApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetEpApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetEpApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtEpApi *(*GetEpApi)()
     * }
     */
    public static final AddressLayout GetEpApi$layout() {
        return GetEpApi$LAYOUT;
    }

    private static final long GetEpApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetEpApi"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtEpApi *(*GetEpApi)()
     * }
     */
    public static final long GetEpApi$offset() {
        return GetEpApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtEpApi *(*GetEpApi)()
     * }
     */
    public static MemorySegment GetEpApi(MemorySegment struct) {
        return struct.get(GetEpApi$LAYOUT, GetEpApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtEpApi *(*GetEpApi)()
     * }
     */
    public static void GetEpApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetEpApi$LAYOUT, GetEpApi$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)
     * }
     */
    public final static class GetTensorSizeInBytes {

        private GetTensorSizeInBytes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorSizeInBytes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorSizeInBytes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorSizeInBytes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorSizeInBytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)
     * }
     */
    public static final AddressLayout GetTensorSizeInBytes$layout() {
        return GetTensorSizeInBytes$LAYOUT;
    }

    private static final long GetTensorSizeInBytes$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorSizeInBytes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)
     * }
     */
    public static final long GetTensorSizeInBytes$offset() {
        return GetTensorSizeInBytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetTensorSizeInBytes(MemorySegment struct) {
        return struct.get(GetTensorSizeInBytes$LAYOUT, GetTensorSizeInBytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)
     * }
     */
    public static void GetTensorSizeInBytes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorSizeInBytes$LAYOUT, GetTensorSizeInBytes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)
     * }
     */
    public final static class AllocatorGetStats {

        private AllocatorGetStats() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AllocatorGetStats.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorGetStats.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorGetStats$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorGetStats"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)
     * }
     */
    public static final AddressLayout AllocatorGetStats$layout() {
        return AllocatorGetStats$LAYOUT;
    }

    private static final long AllocatorGetStats$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorGetStats"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)
     * }
     */
    public static final long AllocatorGetStats$offset() {
        return AllocatorGetStats$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)
     * }
     */
    public static MemorySegment AllocatorGetStats(MemorySegment struct) {
        return struct.get(AllocatorGetStats$LAYOUT, AllocatorGetStats$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)
     * }
     */
    public static void AllocatorGetStats(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorGetStats$LAYOUT, AllocatorGetStats$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)
     * }
     */
    public final static class CreateMemoryInfo_V2 {

        private CreateMemoryInfo_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, long _x5, int _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateMemoryInfo_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateMemoryInfo_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, long _x5, int _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateMemoryInfo_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateMemoryInfo_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout CreateMemoryInfo_V2$layout() {
        return CreateMemoryInfo_V2$LAYOUT;
    }

    private static final long CreateMemoryInfo_V2$OFFSET = $LAYOUT.byteOffset(groupElement("CreateMemoryInfo_V2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)
     * }
     */
    public static final long CreateMemoryInfo_V2$offset() {
        return CreateMemoryInfo_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateMemoryInfo_V2(MemorySegment struct) {
        return struct.get(CreateMemoryInfo_V2$LAYOUT, CreateMemoryInfo_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)
     * }
     */
    public static void CreateMemoryInfo_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateMemoryInfo_V2$LAYOUT, CreateMemoryInfo_V2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)
     * }
     */
    public final static class MemoryInfoGetDeviceMemType {

        private MemoryInfoGetDeviceMemType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetDeviceMemType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetDeviceMemType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetDeviceMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetDeviceMemType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout MemoryInfoGetDeviceMemType$layout() {
        return MemoryInfoGetDeviceMemType$LAYOUT;
    }

    private static final long MemoryInfoGetDeviceMemType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetDeviceMemType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)
     * }
     */
    public static final long MemoryInfoGetDeviceMemType$offset() {
        return MemoryInfoGetDeviceMemType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment MemoryInfoGetDeviceMemType(MemorySegment struct) {
        return struct.get(MemoryInfoGetDeviceMemType$LAYOUT, MemoryInfoGetDeviceMemType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)
     * }
     */
    public static void MemoryInfoGetDeviceMemType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetDeviceMemType$LAYOUT, MemoryInfoGetDeviceMemType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)
     * }
     */
    public final static class MemoryInfoGetVendorId {

        private MemoryInfoGetVendorId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfoGetVendorId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetVendorId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetVendorId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetVendorId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout MemoryInfoGetVendorId$layout() {
        return MemoryInfoGetVendorId$LAYOUT;
    }

    private static final long MemoryInfoGetVendorId$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetVendorId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)
     * }
     */
    public static final long MemoryInfoGetVendorId$offset() {
        return MemoryInfoGetVendorId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment MemoryInfoGetVendorId(MemorySegment struct) {
        return struct.get(MemoryInfoGetVendorId$LAYOUT, MemoryInfoGetVendorId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)
     * }
     */
    public static void MemoryInfoGetVendorId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetVendorId$LAYOUT, MemoryInfoGetVendorId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)
     * }
     */
    public final static class ValueInfo_GetValueProducer {

        private ValueInfo_GetValueProducer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_GetValueProducer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_GetValueProducer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_GetValueProducer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_GetValueProducer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)
     * }
     */
    public static final AddressLayout ValueInfo_GetValueProducer$layout() {
        return ValueInfo_GetValueProducer$LAYOUT;
    }

    private static final long ValueInfo_GetValueProducer$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_GetValueProducer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)
     * }
     */
    public static final long ValueInfo_GetValueProducer$offset() {
        return ValueInfo_GetValueProducer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)
     * }
     */
    public static MemorySegment ValueInfo_GetValueProducer(MemorySegment struct) {
        return struct.get(ValueInfo_GetValueProducer$LAYOUT, ValueInfo_GetValueProducer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)
     * }
     */
    public static void ValueInfo_GetValueProducer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_GetValueProducer$LAYOUT, ValueInfo_GetValueProducer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)
     * }
     */
    public final static class ValueInfo_GetValueNumConsumers {

        private ValueInfo_GetValueNumConsumers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_GetValueNumConsumers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_GetValueNumConsumers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_GetValueNumConsumers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_GetValueNumConsumers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)
     * }
     */
    public static final AddressLayout ValueInfo_GetValueNumConsumers$layout() {
        return ValueInfo_GetValueNumConsumers$LAYOUT;
    }

    private static final long ValueInfo_GetValueNumConsumers$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_GetValueNumConsumers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)
     * }
     */
    public static final long ValueInfo_GetValueNumConsumers$offset() {
        return ValueInfo_GetValueNumConsumers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)
     * }
     */
    public static MemorySegment ValueInfo_GetValueNumConsumers(MemorySegment struct) {
        return struct.get(ValueInfo_GetValueNumConsumers$LAYOUT, ValueInfo_GetValueNumConsumers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)
     * }
     */
    public static void ValueInfo_GetValueNumConsumers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_GetValueNumConsumers$LAYOUT, ValueInfo_GetValueNumConsumers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)
     * }
     */
    public final static class ValueInfo_GetValueConsumers {

        private ValueInfo_GetValueConsumers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_GetValueConsumers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_GetValueConsumers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_GetValueConsumers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_GetValueConsumers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)
     * }
     */
    public static final AddressLayout ValueInfo_GetValueConsumers$layout() {
        return ValueInfo_GetValueConsumers$LAYOUT;
    }

    private static final long ValueInfo_GetValueConsumers$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_GetValueConsumers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)
     * }
     */
    public static final long ValueInfo_GetValueConsumers$offset() {
        return ValueInfo_GetValueConsumers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)
     * }
     */
    public static MemorySegment ValueInfo_GetValueConsumers(MemorySegment struct) {
        return struct.get(ValueInfo_GetValueConsumers$LAYOUT, ValueInfo_GetValueConsumers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)
     * }
     */
    public static void ValueInfo_GetValueConsumers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_GetValueConsumers$LAYOUT, ValueInfo_GetValueConsumers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)
     * }
     */
    public final static class ValueInfo_GetInitializerValue {

        private ValueInfo_GetInitializerValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_GetInitializerValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_GetInitializerValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_GetInitializerValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_GetInitializerValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)
     * }
     */
    public static final AddressLayout ValueInfo_GetInitializerValue$layout() {
        return ValueInfo_GetInitializerValue$LAYOUT;
    }

    private static final long ValueInfo_GetInitializerValue$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_GetInitializerValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)
     * }
     */
    public static final long ValueInfo_GetInitializerValue$offset() {
        return ValueInfo_GetInitializerValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)
     * }
     */
    public static MemorySegment ValueInfo_GetInitializerValue(MemorySegment struct) {
        return struct.get(ValueInfo_GetInitializerValue$LAYOUT, ValueInfo_GetInitializerValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)
     * }
     */
    public static void ValueInfo_GetInitializerValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_GetInitializerValue$LAYOUT, ValueInfo_GetInitializerValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)
     * }
     */
    public final static class ValueInfo_GetExternalInitializerInfo {

        private ValueInfo_GetExternalInitializerInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_GetExternalInitializerInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_GetExternalInitializerInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_GetExternalInitializerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_GetExternalInitializerInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)
     * }
     */
    public static final AddressLayout ValueInfo_GetExternalInitializerInfo$layout() {
        return ValueInfo_GetExternalInitializerInfo$LAYOUT;
    }

    private static final long ValueInfo_GetExternalInitializerInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_GetExternalInitializerInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)
     * }
     */
    public static final long ValueInfo_GetExternalInitializerInfo$offset() {
        return ValueInfo_GetExternalInitializerInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)
     * }
     */
    public static MemorySegment ValueInfo_GetExternalInitializerInfo(MemorySegment struct) {
        return struct.get(ValueInfo_GetExternalInitializerInfo$LAYOUT, ValueInfo_GetExternalInitializerInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)
     * }
     */
    public static void ValueInfo_GetExternalInitializerInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_GetExternalInitializerInfo$LAYOUT, ValueInfo_GetExternalInitializerInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public final static class ValueInfo_IsRequiredGraphInput {

        private ValueInfo_IsRequiredGraphInput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_IsRequiredGraphInput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_IsRequiredGraphInput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_IsRequiredGraphInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_IsRequiredGraphInput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static final AddressLayout ValueInfo_IsRequiredGraphInput$layout() {
        return ValueInfo_IsRequiredGraphInput$LAYOUT;
    }

    private static final long ValueInfo_IsRequiredGraphInput$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_IsRequiredGraphInput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static final long ValueInfo_IsRequiredGraphInput$offset() {
        return ValueInfo_IsRequiredGraphInput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static MemorySegment ValueInfo_IsRequiredGraphInput(MemorySegment struct) {
        return struct.get(ValueInfo_IsRequiredGraphInput$LAYOUT, ValueInfo_IsRequiredGraphInput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static void ValueInfo_IsRequiredGraphInput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_IsRequiredGraphInput$LAYOUT, ValueInfo_IsRequiredGraphInput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public final static class ValueInfo_IsOptionalGraphInput {

        private ValueInfo_IsOptionalGraphInput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_IsOptionalGraphInput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_IsOptionalGraphInput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_IsOptionalGraphInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_IsOptionalGraphInput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static final AddressLayout ValueInfo_IsOptionalGraphInput$layout() {
        return ValueInfo_IsOptionalGraphInput$LAYOUT;
    }

    private static final long ValueInfo_IsOptionalGraphInput$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_IsOptionalGraphInput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static final long ValueInfo_IsOptionalGraphInput$offset() {
        return ValueInfo_IsOptionalGraphInput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static MemorySegment ValueInfo_IsOptionalGraphInput(MemorySegment struct) {
        return struct.get(ValueInfo_IsOptionalGraphInput$LAYOUT, ValueInfo_IsOptionalGraphInput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)
     * }
     */
    public static void ValueInfo_IsOptionalGraphInput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_IsOptionalGraphInput$LAYOUT, ValueInfo_IsOptionalGraphInput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)
     * }
     */
    public final static class ValueInfo_IsGraphOutput {

        private ValueInfo_IsGraphOutput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_IsGraphOutput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_IsGraphOutput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_IsGraphOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_IsGraphOutput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)
     * }
     */
    public static final AddressLayout ValueInfo_IsGraphOutput$layout() {
        return ValueInfo_IsGraphOutput$LAYOUT;
    }

    private static final long ValueInfo_IsGraphOutput$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_IsGraphOutput"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)
     * }
     */
    public static final long ValueInfo_IsGraphOutput$offset() {
        return ValueInfo_IsGraphOutput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)
     * }
     */
    public static MemorySegment ValueInfo_IsGraphOutput(MemorySegment struct) {
        return struct.get(ValueInfo_IsGraphOutput$LAYOUT, ValueInfo_IsGraphOutput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)
     * }
     */
    public static void ValueInfo_IsGraphOutput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_IsGraphOutput$LAYOUT, ValueInfo_IsGraphOutput$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)
     * }
     */
    public final static class ValueInfo_IsConstantInitializer {

        private ValueInfo_IsConstantInitializer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_IsConstantInitializer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_IsConstantInitializer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_IsConstantInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_IsConstantInitializer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)
     * }
     */
    public static final AddressLayout ValueInfo_IsConstantInitializer$layout() {
        return ValueInfo_IsConstantInitializer$LAYOUT;
    }

    private static final long ValueInfo_IsConstantInitializer$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_IsConstantInitializer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)
     * }
     */
    public static final long ValueInfo_IsConstantInitializer$offset() {
        return ValueInfo_IsConstantInitializer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)
     * }
     */
    public static MemorySegment ValueInfo_IsConstantInitializer(MemorySegment struct) {
        return struct.get(ValueInfo_IsConstantInitializer$LAYOUT, ValueInfo_IsConstantInitializer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)
     * }
     */
    public static void ValueInfo_IsConstantInitializer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_IsConstantInitializer$LAYOUT, ValueInfo_IsConstantInitializer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)
     * }
     */
    public final static class ValueInfo_IsFromOuterScope {

        private ValueInfo_IsFromOuterScope() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ValueInfo_IsFromOuterScope.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ValueInfo_IsFromOuterScope.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ValueInfo_IsFromOuterScope$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ValueInfo_IsFromOuterScope"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)
     * }
     */
    public static final AddressLayout ValueInfo_IsFromOuterScope$layout() {
        return ValueInfo_IsFromOuterScope$LAYOUT;
    }

    private static final long ValueInfo_IsFromOuterScope$OFFSET = $LAYOUT.byteOffset(groupElement("ValueInfo_IsFromOuterScope"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)
     * }
     */
    public static final long ValueInfo_IsFromOuterScope$offset() {
        return ValueInfo_IsFromOuterScope$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)
     * }
     */
    public static MemorySegment ValueInfo_IsFromOuterScope(MemorySegment struct) {
        return struct.get(ValueInfo_IsFromOuterScope$LAYOUT, ValueInfo_IsFromOuterScope$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)
     * }
     */
    public static void ValueInfo_IsFromOuterScope(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ValueInfo_IsFromOuterScope$LAYOUT, ValueInfo_IsFromOuterScope$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)
     * }
     */
    public final static class Graph_GetName {

        private Graph_GetName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)
     * }
     */
    public static final AddressLayout Graph_GetName$layout() {
        return Graph_GetName$LAYOUT;
    }

    private static final long Graph_GetName$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)
     * }
     */
    public static final long Graph_GetName$offset() {
        return Graph_GetName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)
     * }
     */
    public static MemorySegment Graph_GetName(MemorySegment struct) {
        return struct.get(Graph_GetName$LAYOUT, Graph_GetName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)
     * }
     */
    public static void Graph_GetName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetName$LAYOUT, Graph_GetName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)
     * }
     */
    public final static class Graph_GetModelPath {

        private Graph_GetModelPath() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetModelPath.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetModelPath.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetModelPath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetModelPath"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)
     * }
     */
    public static final AddressLayout Graph_GetModelPath$layout() {
        return Graph_GetModelPath$LAYOUT;
    }

    private static final long Graph_GetModelPath$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetModelPath"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)
     * }
     */
    public static final long Graph_GetModelPath$offset() {
        return Graph_GetModelPath$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)
     * }
     */
    public static MemorySegment Graph_GetModelPath(MemorySegment struct) {
        return struct.get(Graph_GetModelPath$LAYOUT, Graph_GetModelPath$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)
     * }
     */
    public static void Graph_GetModelPath(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetModelPath$LAYOUT, Graph_GetModelPath$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)
     * }
     */
    public final static class Graph_GetOnnxIRVersion {

        private Graph_GetOnnxIRVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetOnnxIRVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetOnnxIRVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetOnnxIRVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetOnnxIRVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)
     * }
     */
    public static final AddressLayout Graph_GetOnnxIRVersion$layout() {
        return Graph_GetOnnxIRVersion$LAYOUT;
    }

    private static final long Graph_GetOnnxIRVersion$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetOnnxIRVersion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)
     * }
     */
    public static final long Graph_GetOnnxIRVersion$offset() {
        return Graph_GetOnnxIRVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)
     * }
     */
    public static MemorySegment Graph_GetOnnxIRVersion(MemorySegment struct) {
        return struct.get(Graph_GetOnnxIRVersion$LAYOUT, Graph_GetOnnxIRVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)
     * }
     */
    public static void Graph_GetOnnxIRVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetOnnxIRVersion$LAYOUT, Graph_GetOnnxIRVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)
     * }
     */
    public final static class Graph_GetNumOperatorSets {

        private Graph_GetNumOperatorSets() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetNumOperatorSets.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetNumOperatorSets.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetNumOperatorSets$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetNumOperatorSets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)
     * }
     */
    public static final AddressLayout Graph_GetNumOperatorSets$layout() {
        return Graph_GetNumOperatorSets$LAYOUT;
    }

    private static final long Graph_GetNumOperatorSets$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetNumOperatorSets"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)
     * }
     */
    public static final long Graph_GetNumOperatorSets$offset() {
        return Graph_GetNumOperatorSets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)
     * }
     */
    public static MemorySegment Graph_GetNumOperatorSets(MemorySegment struct) {
        return struct.get(Graph_GetNumOperatorSets$LAYOUT, Graph_GetNumOperatorSets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)
     * }
     */
    public static void Graph_GetNumOperatorSets(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetNumOperatorSets$LAYOUT, Graph_GetNumOperatorSets$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)
     * }
     */
    public final static class Graph_GetOperatorSets {

        private Graph_GetOperatorSets() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetOperatorSets.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetOperatorSets.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetOperatorSets$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetOperatorSets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)
     * }
     */
    public static final AddressLayout Graph_GetOperatorSets$layout() {
        return Graph_GetOperatorSets$LAYOUT;
    }

    private static final long Graph_GetOperatorSets$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetOperatorSets"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)
     * }
     */
    public static final long Graph_GetOperatorSets$offset() {
        return Graph_GetOperatorSets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)
     * }
     */
    public static MemorySegment Graph_GetOperatorSets(MemorySegment struct) {
        return struct.get(Graph_GetOperatorSets$LAYOUT, Graph_GetOperatorSets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)
     * }
     */
    public static void Graph_GetOperatorSets(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetOperatorSets$LAYOUT, Graph_GetOperatorSets$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)
     * }
     */
    public final static class Graph_GetNumInputs {

        private Graph_GetNumInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetNumInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetNumInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetNumInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetNumInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)
     * }
     */
    public static final AddressLayout Graph_GetNumInputs$layout() {
        return Graph_GetNumInputs$LAYOUT;
    }

    private static final long Graph_GetNumInputs$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetNumInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)
     * }
     */
    public static final long Graph_GetNumInputs$offset() {
        return Graph_GetNumInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)
     * }
     */
    public static MemorySegment Graph_GetNumInputs(MemorySegment struct) {
        return struct.get(Graph_GetNumInputs$LAYOUT, Graph_GetNumInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)
     * }
     */
    public static void Graph_GetNumInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetNumInputs$LAYOUT, Graph_GetNumInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public final static class Graph_GetInputs {

        private Graph_GetInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout Graph_GetInputs$layout() {
        return Graph_GetInputs$LAYOUT;
    }

    private static final long Graph_GetInputs$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static final long Graph_GetInputs$offset() {
        return Graph_GetInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment Graph_GetInputs(MemorySegment struct) {
        return struct.get(Graph_GetInputs$LAYOUT, Graph_GetInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static void Graph_GetInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetInputs$LAYOUT, Graph_GetInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)
     * }
     */
    public final static class Graph_GetNumOutputs {

        private Graph_GetNumOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetNumOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetNumOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetNumOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetNumOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)
     * }
     */
    public static final AddressLayout Graph_GetNumOutputs$layout() {
        return Graph_GetNumOutputs$LAYOUT;
    }

    private static final long Graph_GetNumOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetNumOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)
     * }
     */
    public static final long Graph_GetNumOutputs$offset() {
        return Graph_GetNumOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)
     * }
     */
    public static MemorySegment Graph_GetNumOutputs(MemorySegment struct) {
        return struct.get(Graph_GetNumOutputs$LAYOUT, Graph_GetNumOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)
     * }
     */
    public static void Graph_GetNumOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetNumOutputs$LAYOUT, Graph_GetNumOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public final static class Graph_GetOutputs {

        private Graph_GetOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout Graph_GetOutputs$layout() {
        return Graph_GetOutputs$LAYOUT;
    }

    private static final long Graph_GetOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static final long Graph_GetOutputs$offset() {
        return Graph_GetOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment Graph_GetOutputs(MemorySegment struct) {
        return struct.get(Graph_GetOutputs$LAYOUT, Graph_GetOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static void Graph_GetOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetOutputs$LAYOUT, Graph_GetOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)
     * }
     */
    public final static class Graph_GetNumInitializers {

        private Graph_GetNumInitializers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetNumInitializers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetNumInitializers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetNumInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetNumInitializers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)
     * }
     */
    public static final AddressLayout Graph_GetNumInitializers$layout() {
        return Graph_GetNumInitializers$LAYOUT;
    }

    private static final long Graph_GetNumInitializers$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetNumInitializers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)
     * }
     */
    public static final long Graph_GetNumInitializers$offset() {
        return Graph_GetNumInitializers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)
     * }
     */
    public static MemorySegment Graph_GetNumInitializers(MemorySegment struct) {
        return struct.get(Graph_GetNumInitializers$LAYOUT, Graph_GetNumInitializers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)
     * }
     */
    public static void Graph_GetNumInitializers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetNumInitializers$LAYOUT, Graph_GetNumInitializers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public final static class Graph_GetInitializers {

        private Graph_GetInitializers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetInitializers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetInitializers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetInitializers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout Graph_GetInitializers$layout() {
        return Graph_GetInitializers$LAYOUT;
    }

    private static final long Graph_GetInitializers$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetInitializers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static final long Graph_GetInitializers$offset() {
        return Graph_GetInitializers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment Graph_GetInitializers(MemorySegment struct) {
        return struct.get(Graph_GetInitializers$LAYOUT, Graph_GetInitializers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)
     * }
     */
    public static void Graph_GetInitializers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetInitializers$LAYOUT, Graph_GetInitializers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)
     * }
     */
    public final static class Graph_GetNumNodes {

        private Graph_GetNumNodes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetNumNodes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetNumNodes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetNumNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetNumNodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)
     * }
     */
    public static final AddressLayout Graph_GetNumNodes$layout() {
        return Graph_GetNumNodes$LAYOUT;
    }

    private static final long Graph_GetNumNodes$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetNumNodes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)
     * }
     */
    public static final long Graph_GetNumNodes$offset() {
        return Graph_GetNumNodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)
     * }
     */
    public static MemorySegment Graph_GetNumNodes(MemorySegment struct) {
        return struct.get(Graph_GetNumNodes$LAYOUT, Graph_GetNumNodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)
     * }
     */
    public static void Graph_GetNumNodes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetNumNodes$LAYOUT, Graph_GetNumNodes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)
     * }
     */
    public final static class Graph_GetNodes {

        private Graph_GetNodes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetNodes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetNodes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetNodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)
     * }
     */
    public static final AddressLayout Graph_GetNodes$layout() {
        return Graph_GetNodes$LAYOUT;
    }

    private static final long Graph_GetNodes$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetNodes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)
     * }
     */
    public static final long Graph_GetNodes$offset() {
        return Graph_GetNodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)
     * }
     */
    public static MemorySegment Graph_GetNodes(MemorySegment struct) {
        return struct.get(Graph_GetNodes$LAYOUT, Graph_GetNodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)
     * }
     */
    public static void Graph_GetNodes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetNodes$LAYOUT, Graph_GetNodes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)
     * }
     */
    public final static class Graph_GetParentNode {

        private Graph_GetParentNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetParentNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetParentNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetParentNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetParentNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)
     * }
     */
    public static final AddressLayout Graph_GetParentNode$layout() {
        return Graph_GetParentNode$LAYOUT;
    }

    private static final long Graph_GetParentNode$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetParentNode"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)
     * }
     */
    public static final long Graph_GetParentNode$offset() {
        return Graph_GetParentNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)
     * }
     */
    public static MemorySegment Graph_GetParentNode(MemorySegment struct) {
        return struct.get(Graph_GetParentNode$LAYOUT, Graph_GetParentNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)
     * }
     */
    public static void Graph_GetParentNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetParentNode$LAYOUT, Graph_GetParentNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)
     * }
     */
    public final static class Graph_GetGraphView {

        private Graph_GetGraphView() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetGraphView.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetGraphView.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetGraphView$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetGraphView"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)
     * }
     */
    public static final AddressLayout Graph_GetGraphView$layout() {
        return Graph_GetGraphView$LAYOUT;
    }

    private static final long Graph_GetGraphView$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetGraphView"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)
     * }
     */
    public static final long Graph_GetGraphView$offset() {
        return Graph_GetGraphView$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)
     * }
     */
    public static MemorySegment Graph_GetGraphView(MemorySegment struct) {
        return struct.get(Graph_GetGraphView$LAYOUT, Graph_GetGraphView$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)
     * }
     */
    public static void Graph_GetGraphView(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetGraphView$LAYOUT, Graph_GetGraphView$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)
     * }
     */
    public final static class Node_GetId {

        private Node_GetId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)
     * }
     */
    public static final AddressLayout Node_GetId$layout() {
        return Node_GetId$LAYOUT;
    }

    private static final long Node_GetId$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)
     * }
     */
    public static final long Node_GetId$offset() {
        return Node_GetId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)
     * }
     */
    public static MemorySegment Node_GetId(MemorySegment struct) {
        return struct.get(Node_GetId$LAYOUT, Node_GetId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)
     * }
     */
    public static void Node_GetId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetId$LAYOUT, Node_GetId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)
     * }
     */
    public final static class Node_GetName {

        private Node_GetName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)
     * }
     */
    public static final AddressLayout Node_GetName$layout() {
        return Node_GetName$LAYOUT;
    }

    private static final long Node_GetName$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)
     * }
     */
    public static final long Node_GetName$offset() {
        return Node_GetName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)
     * }
     */
    public static MemorySegment Node_GetName(MemorySegment struct) {
        return struct.get(Node_GetName$LAYOUT, Node_GetName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)
     * }
     */
    public static void Node_GetName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetName$LAYOUT, Node_GetName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)
     * }
     */
    public final static class Node_GetOperatorType {

        private Node_GetOperatorType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetOperatorType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetOperatorType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetOperatorType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetOperatorType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)
     * }
     */
    public static final AddressLayout Node_GetOperatorType$layout() {
        return Node_GetOperatorType$LAYOUT;
    }

    private static final long Node_GetOperatorType$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetOperatorType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)
     * }
     */
    public static final long Node_GetOperatorType$offset() {
        return Node_GetOperatorType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)
     * }
     */
    public static MemorySegment Node_GetOperatorType(MemorySegment struct) {
        return struct.get(Node_GetOperatorType$LAYOUT, Node_GetOperatorType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)
     * }
     */
    public static void Node_GetOperatorType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetOperatorType$LAYOUT, Node_GetOperatorType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)
     * }
     */
    public final static class Node_GetDomain {

        private Node_GetDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)
     * }
     */
    public static final AddressLayout Node_GetDomain$layout() {
        return Node_GetDomain$LAYOUT;
    }

    private static final long Node_GetDomain$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetDomain"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)
     * }
     */
    public static final long Node_GetDomain$offset() {
        return Node_GetDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)
     * }
     */
    public static MemorySegment Node_GetDomain(MemorySegment struct) {
        return struct.get(Node_GetDomain$LAYOUT, Node_GetDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)
     * }
     */
    public static void Node_GetDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetDomain$LAYOUT, Node_GetDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)
     * }
     */
    public final static class Node_GetSinceVersion {

        private Node_GetSinceVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetSinceVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetSinceVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetSinceVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetSinceVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)
     * }
     */
    public static final AddressLayout Node_GetSinceVersion$layout() {
        return Node_GetSinceVersion$LAYOUT;
    }

    private static final long Node_GetSinceVersion$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetSinceVersion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)
     * }
     */
    public static final long Node_GetSinceVersion$offset() {
        return Node_GetSinceVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)
     * }
     */
    public static MemorySegment Node_GetSinceVersion(MemorySegment struct) {
        return struct.get(Node_GetSinceVersion$LAYOUT, Node_GetSinceVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)
     * }
     */
    public static void Node_GetSinceVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetSinceVersion$LAYOUT, Node_GetSinceVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)
     * }
     */
    public final static class Node_GetNumInputs {

        private Node_GetNumInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetNumInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetNumInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetNumInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetNumInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)
     * }
     */
    public static final AddressLayout Node_GetNumInputs$layout() {
        return Node_GetNumInputs$LAYOUT;
    }

    private static final long Node_GetNumInputs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetNumInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)
     * }
     */
    public static final long Node_GetNumInputs$offset() {
        return Node_GetNumInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)
     * }
     */
    public static MemorySegment Node_GetNumInputs(MemorySegment struct) {
        return struct.get(Node_GetNumInputs$LAYOUT, Node_GetNumInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)
     * }
     */
    public static void Node_GetNumInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetNumInputs$LAYOUT, Node_GetNumInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public final static class Node_GetInputs {

        private Node_GetInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout Node_GetInputs$layout() {
        return Node_GetInputs$LAYOUT;
    }

    private static final long Node_GetInputs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static final long Node_GetInputs$offset() {
        return Node_GetInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment Node_GetInputs(MemorySegment struct) {
        return struct.get(Node_GetInputs$LAYOUT, Node_GetInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static void Node_GetInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetInputs$LAYOUT, Node_GetInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)
     * }
     */
    public final static class Node_GetNumOutputs {

        private Node_GetNumOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetNumOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetNumOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetNumOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetNumOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)
     * }
     */
    public static final AddressLayout Node_GetNumOutputs$layout() {
        return Node_GetNumOutputs$LAYOUT;
    }

    private static final long Node_GetNumOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetNumOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)
     * }
     */
    public static final long Node_GetNumOutputs$offset() {
        return Node_GetNumOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)
     * }
     */
    public static MemorySegment Node_GetNumOutputs(MemorySegment struct) {
        return struct.get(Node_GetNumOutputs$LAYOUT, Node_GetNumOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)
     * }
     */
    public static void Node_GetNumOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetNumOutputs$LAYOUT, Node_GetNumOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public final static class Node_GetOutputs {

        private Node_GetOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout Node_GetOutputs$layout() {
        return Node_GetOutputs$LAYOUT;
    }

    private static final long Node_GetOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static final long Node_GetOutputs$offset() {
        return Node_GetOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment Node_GetOutputs(MemorySegment struct) {
        return struct.get(Node_GetOutputs$LAYOUT, Node_GetOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static void Node_GetOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetOutputs$LAYOUT, Node_GetOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)
     * }
     */
    public final static class Node_GetNumImplicitInputs {

        private Node_GetNumImplicitInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetNumImplicitInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetNumImplicitInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetNumImplicitInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetNumImplicitInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)
     * }
     */
    public static final AddressLayout Node_GetNumImplicitInputs$layout() {
        return Node_GetNumImplicitInputs$LAYOUT;
    }

    private static final long Node_GetNumImplicitInputs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetNumImplicitInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)
     * }
     */
    public static final long Node_GetNumImplicitInputs$offset() {
        return Node_GetNumImplicitInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)
     * }
     */
    public static MemorySegment Node_GetNumImplicitInputs(MemorySegment struct) {
        return struct.get(Node_GetNumImplicitInputs$LAYOUT, Node_GetNumImplicitInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)
     * }
     */
    public static void Node_GetNumImplicitInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetNumImplicitInputs$LAYOUT, Node_GetNumImplicitInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public final static class Node_GetImplicitInputs {

        private Node_GetImplicitInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetImplicitInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetImplicitInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetImplicitInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetImplicitInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout Node_GetImplicitInputs$layout() {
        return Node_GetImplicitInputs$LAYOUT;
    }

    private static final long Node_GetImplicitInputs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetImplicitInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static final long Node_GetImplicitInputs$offset() {
        return Node_GetImplicitInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment Node_GetImplicitInputs(MemorySegment struct) {
        return struct.get(Node_GetImplicitInputs$LAYOUT, Node_GetImplicitInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)
     * }
     */
    public static void Node_GetImplicitInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetImplicitInputs$LAYOUT, Node_GetImplicitInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)
     * }
     */
    public final static class Node_GetNumAttributes {

        private Node_GetNumAttributes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetNumAttributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetNumAttributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetNumAttributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetNumAttributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)
     * }
     */
    public static final AddressLayout Node_GetNumAttributes$layout() {
        return Node_GetNumAttributes$LAYOUT;
    }

    private static final long Node_GetNumAttributes$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetNumAttributes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)
     * }
     */
    public static final long Node_GetNumAttributes$offset() {
        return Node_GetNumAttributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)
     * }
     */
    public static MemorySegment Node_GetNumAttributes(MemorySegment struct) {
        return struct.get(Node_GetNumAttributes$LAYOUT, Node_GetNumAttributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)
     * }
     */
    public static void Node_GetNumAttributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetNumAttributes$LAYOUT, Node_GetNumAttributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)
     * }
     */
    public final static class Node_GetAttributes {

        private Node_GetAttributes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetAttributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetAttributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetAttributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetAttributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)
     * }
     */
    public static final AddressLayout Node_GetAttributes$layout() {
        return Node_GetAttributes$LAYOUT;
    }

    private static final long Node_GetAttributes$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetAttributes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)
     * }
     */
    public static final long Node_GetAttributes$offset() {
        return Node_GetAttributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)
     * }
     */
    public static MemorySegment Node_GetAttributes(MemorySegment struct) {
        return struct.get(Node_GetAttributes$LAYOUT, Node_GetAttributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)
     * }
     */
    public static void Node_GetAttributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetAttributes$LAYOUT, Node_GetAttributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)
     * }
     */
    public final static class Node_GetAttributeByName {

        private Node_GetAttributeByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetAttributeByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetAttributeByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetAttributeByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetAttributeByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)
     * }
     */
    public static final AddressLayout Node_GetAttributeByName$layout() {
        return Node_GetAttributeByName$LAYOUT;
    }

    private static final long Node_GetAttributeByName$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetAttributeByName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)
     * }
     */
    public static final long Node_GetAttributeByName$offset() {
        return Node_GetAttributeByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)
     * }
     */
    public static MemorySegment Node_GetAttributeByName(MemorySegment struct) {
        return struct.get(Node_GetAttributeByName$LAYOUT, Node_GetAttributeByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)
     * }
     */
    public static void Node_GetAttributeByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetAttributeByName$LAYOUT, Node_GetAttributeByName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)
     * }
     */
    public final static class OpAttr_GetTensorAttributeAsOrtValue {

        private OpAttr_GetTensorAttributeAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OpAttr_GetTensorAttributeAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(OpAttr_GetTensorAttributeAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout OpAttr_GetTensorAttributeAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("OpAttr_GetTensorAttributeAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)
     * }
     */
    public static final AddressLayout OpAttr_GetTensorAttributeAsOrtValue$layout() {
        return OpAttr_GetTensorAttributeAsOrtValue$LAYOUT;
    }

    private static final long OpAttr_GetTensorAttributeAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("OpAttr_GetTensorAttributeAsOrtValue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)
     * }
     */
    public static final long OpAttr_GetTensorAttributeAsOrtValue$offset() {
        return OpAttr_GetTensorAttributeAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)
     * }
     */
    public static MemorySegment OpAttr_GetTensorAttributeAsOrtValue(MemorySegment struct) {
        return struct.get(OpAttr_GetTensorAttributeAsOrtValue$LAYOUT, OpAttr_GetTensorAttributeAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)
     * }
     */
    public static void OpAttr_GetTensorAttributeAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(OpAttr_GetTensorAttributeAsOrtValue$LAYOUT, OpAttr_GetTensorAttributeAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)
     * }
     */
    public final static class OpAttr_GetType {

        private OpAttr_GetType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OpAttr_GetType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(OpAttr_GetType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout OpAttr_GetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("OpAttr_GetType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)
     * }
     */
    public static final AddressLayout OpAttr_GetType$layout() {
        return OpAttr_GetType$LAYOUT;
    }

    private static final long OpAttr_GetType$OFFSET = $LAYOUT.byteOffset(groupElement("OpAttr_GetType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)
     * }
     */
    public static final long OpAttr_GetType$offset() {
        return OpAttr_GetType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)
     * }
     */
    public static MemorySegment OpAttr_GetType(MemorySegment struct) {
        return struct.get(OpAttr_GetType$LAYOUT, OpAttr_GetType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)
     * }
     */
    public static void OpAttr_GetType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(OpAttr_GetType$LAYOUT, OpAttr_GetType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)
     * }
     */
    public final static class OpAttr_GetName {

        private OpAttr_GetName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OpAttr_GetName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(OpAttr_GetName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout OpAttr_GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("OpAttr_GetName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)
     * }
     */
    public static final AddressLayout OpAttr_GetName$layout() {
        return OpAttr_GetName$LAYOUT;
    }

    private static final long OpAttr_GetName$OFFSET = $LAYOUT.byteOffset(groupElement("OpAttr_GetName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)
     * }
     */
    public static final long OpAttr_GetName$offset() {
        return OpAttr_GetName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)
     * }
     */
    public static MemorySegment OpAttr_GetName(MemorySegment struct) {
        return struct.get(OpAttr_GetName$LAYOUT, OpAttr_GetName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)
     * }
     */
    public static void OpAttr_GetName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(OpAttr_GetName$LAYOUT, OpAttr_GetName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)
     * }
     */
    public final static class Node_GetNumSubgraphs {

        private Node_GetNumSubgraphs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetNumSubgraphs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetNumSubgraphs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetNumSubgraphs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetNumSubgraphs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)
     * }
     */
    public static final AddressLayout Node_GetNumSubgraphs$layout() {
        return Node_GetNumSubgraphs$LAYOUT;
    }

    private static final long Node_GetNumSubgraphs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetNumSubgraphs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)
     * }
     */
    public static final long Node_GetNumSubgraphs$offset() {
        return Node_GetNumSubgraphs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)
     * }
     */
    public static MemorySegment Node_GetNumSubgraphs(MemorySegment struct) {
        return struct.get(Node_GetNumSubgraphs$LAYOUT, Node_GetNumSubgraphs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)
     * }
     */
    public static void Node_GetNumSubgraphs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetNumSubgraphs$LAYOUT, Node_GetNumSubgraphs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)
     * }
     */
    public final static class Node_GetSubgraphs {

        private Node_GetSubgraphs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetSubgraphs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetSubgraphs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetSubgraphs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetSubgraphs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)
     * }
     */
    public static final AddressLayout Node_GetSubgraphs$layout() {
        return Node_GetSubgraphs$LAYOUT;
    }

    private static final long Node_GetSubgraphs$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetSubgraphs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)
     * }
     */
    public static final long Node_GetSubgraphs$offset() {
        return Node_GetSubgraphs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)
     * }
     */
    public static MemorySegment Node_GetSubgraphs(MemorySegment struct) {
        return struct.get(Node_GetSubgraphs$LAYOUT, Node_GetSubgraphs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)
     * }
     */
    public static void Node_GetSubgraphs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetSubgraphs$LAYOUT, Node_GetSubgraphs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)
     * }
     */
    public final static class Node_GetGraph {

        private Node_GetGraph() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetGraph.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetGraph.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetGraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)
     * }
     */
    public static final AddressLayout Node_GetGraph$layout() {
        return Node_GetGraph$LAYOUT;
    }

    private static final long Node_GetGraph$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetGraph"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)
     * }
     */
    public static final long Node_GetGraph$offset() {
        return Node_GetGraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)
     * }
     */
    public static MemorySegment Node_GetGraph(MemorySegment struct) {
        return struct.get(Node_GetGraph$LAYOUT, Node_GetGraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)
     * }
     */
    public static void Node_GetGraph(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetGraph$LAYOUT, Node_GetGraph$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)
     * }
     */
    public final static class Node_GetEpName {

        private Node_GetEpName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Node_GetEpName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Node_GetEpName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Node_GetEpName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Node_GetEpName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)
     * }
     */
    public static final AddressLayout Node_GetEpName$layout() {
        return Node_GetEpName$LAYOUT;
    }

    private static final long Node_GetEpName$OFFSET = $LAYOUT.byteOffset(groupElement("Node_GetEpName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)
     * }
     */
    public static final long Node_GetEpName$offset() {
        return Node_GetEpName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)
     * }
     */
    public static MemorySegment Node_GetEpName(MemorySegment struct) {
        return struct.get(Node_GetEpName$LAYOUT, Node_GetEpName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)
     * }
     */
    public static void Node_GetEpName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Node_GetEpName$LAYOUT, Node_GetEpName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)
     * }
     */
    public final static class ReleaseExternalInitializerInfo {

        private ReleaseExternalInitializerInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseExternalInitializerInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseExternalInitializerInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseExternalInitializerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseExternalInitializerInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)
     * }
     */
    public static final AddressLayout ReleaseExternalInitializerInfo$layout() {
        return ReleaseExternalInitializerInfo$LAYOUT;
    }

    private static final long ReleaseExternalInitializerInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseExternalInitializerInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)
     * }
     */
    public static final long ReleaseExternalInitializerInfo$offset() {
        return ReleaseExternalInitializerInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)
     * }
     */
    public static MemorySegment ReleaseExternalInitializerInfo(MemorySegment struct) {
        return struct.get(ReleaseExternalInitializerInfo$LAYOUT, ReleaseExternalInitializerInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)
     * }
     */
    public static void ReleaseExternalInitializerInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseExternalInitializerInfo$LAYOUT, ReleaseExternalInitializerInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)
     * }
     */
    public final static class ExternalInitializerInfo_GetFilePath {

        private ExternalInitializerInfo_GetFilePath() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ExternalInitializerInfo_GetFilePath.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExternalInitializerInfo_GetFilePath.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExternalInitializerInfo_GetFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExternalInitializerInfo_GetFilePath"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)
     * }
     */
    public static final AddressLayout ExternalInitializerInfo_GetFilePath$layout() {
        return ExternalInitializerInfo_GetFilePath$LAYOUT;
    }

    private static final long ExternalInitializerInfo_GetFilePath$OFFSET = $LAYOUT.byteOffset(groupElement("ExternalInitializerInfo_GetFilePath"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)
     * }
     */
    public static final long ExternalInitializerInfo_GetFilePath$offset() {
        return ExternalInitializerInfo_GetFilePath$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)
     * }
     */
    public static MemorySegment ExternalInitializerInfo_GetFilePath(MemorySegment struct) {
        return struct.get(ExternalInitializerInfo_GetFilePath$LAYOUT, ExternalInitializerInfo_GetFilePath$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)
     * }
     */
    public static void ExternalInitializerInfo_GetFilePath(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExternalInitializerInfo_GetFilePath$LAYOUT, ExternalInitializerInfo_GetFilePath$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)
     * }
     */
    public final static class ExternalInitializerInfo_GetFileOffset {

        private ExternalInitializerInfo_GetFileOffset() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ExternalInitializerInfo_GetFileOffset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExternalInitializerInfo_GetFileOffset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExternalInitializerInfo_GetFileOffset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExternalInitializerInfo_GetFileOffset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)
     * }
     */
    public static final AddressLayout ExternalInitializerInfo_GetFileOffset$layout() {
        return ExternalInitializerInfo_GetFileOffset$LAYOUT;
    }

    private static final long ExternalInitializerInfo_GetFileOffset$OFFSET = $LAYOUT.byteOffset(groupElement("ExternalInitializerInfo_GetFileOffset"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)
     * }
     */
    public static final long ExternalInitializerInfo_GetFileOffset$offset() {
        return ExternalInitializerInfo_GetFileOffset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)
     * }
     */
    public static MemorySegment ExternalInitializerInfo_GetFileOffset(MemorySegment struct) {
        return struct.get(ExternalInitializerInfo_GetFileOffset$LAYOUT, ExternalInitializerInfo_GetFileOffset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)
     * }
     */
    public static void ExternalInitializerInfo_GetFileOffset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExternalInitializerInfo_GetFileOffset$LAYOUT, ExternalInitializerInfo_GetFileOffset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)
     * }
     */
    public final static class ExternalInitializerInfo_GetByteSize {

        private ExternalInitializerInfo_GetByteSize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ExternalInitializerInfo_GetByteSize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExternalInitializerInfo_GetByteSize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExternalInitializerInfo_GetByteSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExternalInitializerInfo_GetByteSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)
     * }
     */
    public static final AddressLayout ExternalInitializerInfo_GetByteSize$layout() {
        return ExternalInitializerInfo_GetByteSize$LAYOUT;
    }

    private static final long ExternalInitializerInfo_GetByteSize$OFFSET = $LAYOUT.byteOffset(groupElement("ExternalInitializerInfo_GetByteSize"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)
     * }
     */
    public static final long ExternalInitializerInfo_GetByteSize$offset() {
        return ExternalInitializerInfo_GetByteSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)
     * }
     */
    public static MemorySegment ExternalInitializerInfo_GetByteSize(MemorySegment struct) {
        return struct.get(ExternalInitializerInfo_GetByteSize$LAYOUT, ExternalInitializerInfo_GetByteSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)
     * }
     */
    public static void ExternalInitializerInfo_GetByteSize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExternalInitializerInfo_GetByteSize$LAYOUT, ExternalInitializerInfo_GetByteSize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)
     * }
     */
    public final static class GetRunConfigEntry {

        private GetRunConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetRunConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetRunConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetRunConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)
     * }
     */
    public static final AddressLayout GetRunConfigEntry$layout() {
        return GetRunConfigEntry$LAYOUT;
    }

    private static final long GetRunConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("GetRunConfigEntry"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)
     * }
     */
    public static final long GetRunConfigEntry$offset() {
        return GetRunConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)
     * }
     */
    public static MemorySegment GetRunConfigEntry(MemorySegment struct) {
        return struct.get(GetRunConfigEntry$LAYOUT, GetRunConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)
     * }
     */
    public static void GetRunConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetRunConfigEntry$LAYOUT, GetRunConfigEntry$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public final static class EpDevice_MemoryInfo {

        private EpDevice_MemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_MemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_MemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_MemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_MemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static final AddressLayout EpDevice_MemoryInfo$layout() {
        return EpDevice_MemoryInfo$LAYOUT;
    }

    private static final long EpDevice_MemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_MemoryInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static final long EpDevice_MemoryInfo$offset() {
        return EpDevice_MemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static MemorySegment EpDevice_MemoryInfo(MemorySegment struct) {
        return struct.get(EpDevice_MemoryInfo$LAYOUT, EpDevice_MemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static void EpDevice_MemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_MemoryInfo$LAYOUT, EpDevice_MemoryInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)
     * }
     */
    public final static class CreateSharedAllocator {

        private CreateSharedAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSharedAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSharedAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSharedAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSharedAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)
     * }
     */
    public static final AddressLayout CreateSharedAllocator$layout() {
        return CreateSharedAllocator$LAYOUT;
    }

    private static final long CreateSharedAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSharedAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)
     * }
     */
    public static final long CreateSharedAllocator$offset() {
        return CreateSharedAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)
     * }
     */
    public static MemorySegment CreateSharedAllocator(MemorySegment struct) {
        return struct.get(CreateSharedAllocator$LAYOUT, CreateSharedAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)
     * }
     */
    public static void CreateSharedAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSharedAllocator$LAYOUT, CreateSharedAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public final static class GetSharedAllocator {

        private GetSharedAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSharedAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSharedAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSharedAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSharedAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final AddressLayout GetSharedAllocator$layout() {
        return GetSharedAllocator$LAYOUT;
    }

    private static final long GetSharedAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("GetSharedAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final long GetSharedAllocator$offset() {
        return GetSharedAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment GetSharedAllocator(MemorySegment struct) {
        return struct.get(GetSharedAllocator$LAYOUT, GetSharedAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static void GetSharedAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSharedAllocator$LAYOUT, GetSharedAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public final static class ReleaseSharedAllocator {

        private ReleaseSharedAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseSharedAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSharedAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSharedAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSharedAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static final AddressLayout ReleaseSharedAllocator$layout() {
        return ReleaseSharedAllocator$LAYOUT;
    }

    private static final long ReleaseSharedAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSharedAllocator"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static final long ReleaseSharedAllocator$offset() {
        return ReleaseSharedAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static MemorySegment ReleaseSharedAllocator(MemorySegment struct) {
        return struct.get(ReleaseSharedAllocator$LAYOUT, ReleaseSharedAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)
     * }
     */
    public static void ReleaseSharedAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSharedAllocator$LAYOUT, ReleaseSharedAllocator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)
     * }
     */
    public final static class GetTensorData {

        private GetTensorData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetTensorData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)
     * }
     */
    public static final AddressLayout GetTensorData$layout() {
        return GetTensorData$LAYOUT;
    }

    private static final long GetTensorData$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorData"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)
     * }
     */
    public static final long GetTensorData$offset() {
        return GetTensorData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)
     * }
     */
    public static MemorySegment GetTensorData(MemorySegment struct) {
        return struct.get(GetTensorData$LAYOUT, GetTensorData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)
     * }
     */
    public static void GetTensorData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorData$LAYOUT, GetTensorData$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)
     * }
     */
    public final static class GetSessionOptionsConfigEntries {

        private GetSessionOptionsConfigEntries() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSessionOptionsConfigEntries.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSessionOptionsConfigEntries.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSessionOptionsConfigEntries$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSessionOptionsConfigEntries"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)
     * }
     */
    public static final AddressLayout GetSessionOptionsConfigEntries$layout() {
        return GetSessionOptionsConfigEntries$LAYOUT;
    }

    private static final long GetSessionOptionsConfigEntries$OFFSET = $LAYOUT.byteOffset(groupElement("GetSessionOptionsConfigEntries"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)
     * }
     */
    public static final long GetSessionOptionsConfigEntries$offset() {
        return GetSessionOptionsConfigEntries$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)
     * }
     */
    public static MemorySegment GetSessionOptionsConfigEntries(MemorySegment struct) {
        return struct.get(GetSessionOptionsConfigEntries$LAYOUT, GetSessionOptionsConfigEntries$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)
     * }
     */
    public static void GetSessionOptionsConfigEntries(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSessionOptionsConfigEntries$LAYOUT, GetSessionOptionsConfigEntries$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public final static class SessionGetMemoryInfoForInputs {

        private SessionGetMemoryInfoForInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetMemoryInfoForInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetMemoryInfoForInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetMemoryInfoForInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetMemoryInfoForInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static final AddressLayout SessionGetMemoryInfoForInputs$layout() {
        return SessionGetMemoryInfoForInputs$LAYOUT;
    }

    private static final long SessionGetMemoryInfoForInputs$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetMemoryInfoForInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static final long SessionGetMemoryInfoForInputs$offset() {
        return SessionGetMemoryInfoForInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static MemorySegment SessionGetMemoryInfoForInputs(MemorySegment struct) {
        return struct.get(SessionGetMemoryInfoForInputs$LAYOUT, SessionGetMemoryInfoForInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static void SessionGetMemoryInfoForInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetMemoryInfoForInputs$LAYOUT, SessionGetMemoryInfoForInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public final static class SessionGetMemoryInfoForOutputs {

        private SessionGetMemoryInfoForOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetMemoryInfoForOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetMemoryInfoForOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetMemoryInfoForOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetMemoryInfoForOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static final AddressLayout SessionGetMemoryInfoForOutputs$layout() {
        return SessionGetMemoryInfoForOutputs$LAYOUT;
    }

    private static final long SessionGetMemoryInfoForOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetMemoryInfoForOutputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static final long SessionGetMemoryInfoForOutputs$offset() {
        return SessionGetMemoryInfoForOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static MemorySegment SessionGetMemoryInfoForOutputs(MemorySegment struct) {
        return struct.get(SessionGetMemoryInfoForOutputs$LAYOUT, SessionGetMemoryInfoForOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)
     * }
     */
    public static void SessionGetMemoryInfoForOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetMemoryInfoForOutputs$LAYOUT, SessionGetMemoryInfoForOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)
     * }
     */
    public final static class SessionGetEpDeviceForInputs {

        private SessionGetEpDeviceForInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetEpDeviceForInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetEpDeviceForInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetEpDeviceForInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetEpDeviceForInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)
     * }
     */
    public static final AddressLayout SessionGetEpDeviceForInputs$layout() {
        return SessionGetEpDeviceForInputs$LAYOUT;
    }

    private static final long SessionGetEpDeviceForInputs$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetEpDeviceForInputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)
     * }
     */
    public static final long SessionGetEpDeviceForInputs$offset() {
        return SessionGetEpDeviceForInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)
     * }
     */
    public static MemorySegment SessionGetEpDeviceForInputs(MemorySegment struct) {
        return struct.get(SessionGetEpDeviceForInputs$LAYOUT, SessionGetEpDeviceForInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)
     * }
     */
    public static void SessionGetEpDeviceForInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetEpDeviceForInputs$LAYOUT, SessionGetEpDeviceForInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)
     * }
     */
    public final static class CreateSyncStreamForEpDevice {

        private CreateSyncStreamForEpDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSyncStreamForEpDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSyncStreamForEpDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSyncStreamForEpDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSyncStreamForEpDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)
     * }
     */
    public static final AddressLayout CreateSyncStreamForEpDevice$layout() {
        return CreateSyncStreamForEpDevice$LAYOUT;
    }

    private static final long CreateSyncStreamForEpDevice$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSyncStreamForEpDevice"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)
     * }
     */
    public static final long CreateSyncStreamForEpDevice$offset() {
        return CreateSyncStreamForEpDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)
     * }
     */
    public static MemorySegment CreateSyncStreamForEpDevice(MemorySegment struct) {
        return struct.get(CreateSyncStreamForEpDevice$LAYOUT, CreateSyncStreamForEpDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)
     * }
     */
    public static void CreateSyncStreamForEpDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSyncStreamForEpDevice$LAYOUT, CreateSyncStreamForEpDevice$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*SyncStream_GetHandle)(OrtSyncStream *)
     * }
     */
    public final static class SyncStream_GetHandle {

        private SyncStream_GetHandle() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SyncStream_GetHandle.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SyncStream_GetHandle.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SyncStream_GetHandle$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SyncStream_GetHandle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*SyncStream_GetHandle)(OrtSyncStream *)
     * }
     */
    public static final AddressLayout SyncStream_GetHandle$layout() {
        return SyncStream_GetHandle$LAYOUT;
    }

    private static final long SyncStream_GetHandle$OFFSET = $LAYOUT.byteOffset(groupElement("SyncStream_GetHandle"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*SyncStream_GetHandle)(OrtSyncStream *)
     * }
     */
    public static final long SyncStream_GetHandle$offset() {
        return SyncStream_GetHandle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*SyncStream_GetHandle)(OrtSyncStream *)
     * }
     */
    public static MemorySegment SyncStream_GetHandle(MemorySegment struct) {
        return struct.get(SyncStream_GetHandle$LAYOUT, SyncStream_GetHandle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*SyncStream_GetHandle)(OrtSyncStream *)
     * }
     */
    public static void SyncStream_GetHandle(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SyncStream_GetHandle$LAYOUT, SyncStream_GetHandle$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSyncStream)(OrtSyncStream *)
     * }
     */
    public final static class ReleaseSyncStream {

        private ReleaseSyncStream() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseSyncStream.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSyncStream.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSyncStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSyncStream"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSyncStream)(OrtSyncStream *)
     * }
     */
    public static final AddressLayout ReleaseSyncStream$layout() {
        return ReleaseSyncStream$LAYOUT;
    }

    private static final long ReleaseSyncStream$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSyncStream"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSyncStream)(OrtSyncStream *)
     * }
     */
    public static final long ReleaseSyncStream$offset() {
        return ReleaseSyncStream$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSyncStream)(OrtSyncStream *)
     * }
     */
    public static MemorySegment ReleaseSyncStream(MemorySegment struct) {
        return struct.get(ReleaseSyncStream$LAYOUT, ReleaseSyncStream$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSyncStream)(OrtSyncStream *)
     * }
     */
    public static void ReleaseSyncStream(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSyncStream$LAYOUT, ReleaseSyncStream$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)
     * }
     */
    public final static class CopyTensors {

        private CopyTensors() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CopyTensors.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CopyTensors.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CopyTensors$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CopyTensors"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)
     * }
     */
    public static final AddressLayout CopyTensors$layout() {
        return CopyTensors$LAYOUT;
    }

    private static final long CopyTensors$OFFSET = $LAYOUT.byteOffset(groupElement("CopyTensors"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)
     * }
     */
    public static final long CopyTensors$offset() {
        return CopyTensors$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)
     * }
     */
    public static MemorySegment CopyTensors(MemorySegment struct) {
        return struct.get(CopyTensors$LAYOUT, CopyTensors$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)
     * }
     */
    public static void CopyTensors(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CopyTensors$LAYOUT, CopyTensors$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)
     * }
     */
    public final static class Graph_GetModelMetadata {

        private Graph_GetModelMetadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Graph_GetModelMetadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Graph_GetModelMetadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Graph_GetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Graph_GetModelMetadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)
     * }
     */
    public static final AddressLayout Graph_GetModelMetadata$layout() {
        return Graph_GetModelMetadata$LAYOUT;
    }

    private static final long Graph_GetModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement("Graph_GetModelMetadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)
     * }
     */
    public static final long Graph_GetModelMetadata$offset() {
        return Graph_GetModelMetadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)
     * }
     */
    public static MemorySegment Graph_GetModelMetadata(MemorySegment struct) {
        return struct.get(Graph_GetModelMetadata$LAYOUT, Graph_GetModelMetadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)
     * }
     */
    public static void Graph_GetModelMetadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Graph_GetModelMetadata$LAYOUT, Graph_GetModelMetadata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)
     * }
     */
    public final static class GetModelCompatibilityForEpDevices {

        private GetModelCompatibilityForEpDevices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetModelCompatibilityForEpDevices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetModelCompatibilityForEpDevices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetModelCompatibilityForEpDevices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetModelCompatibilityForEpDevices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)
     * }
     */
    public static final AddressLayout GetModelCompatibilityForEpDevices$layout() {
        return GetModelCompatibilityForEpDevices$LAYOUT;
    }

    private static final long GetModelCompatibilityForEpDevices$OFFSET = $LAYOUT.byteOffset(groupElement("GetModelCompatibilityForEpDevices"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)
     * }
     */
    public static final long GetModelCompatibilityForEpDevices$offset() {
        return GetModelCompatibilityForEpDevices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)
     * }
     */
    public static MemorySegment GetModelCompatibilityForEpDevices(MemorySegment struct) {
        return struct.get(GetModelCompatibilityForEpDevices$LAYOUT, GetModelCompatibilityForEpDevices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)
     * }
     */
    public static void GetModelCompatibilityForEpDevices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetModelCompatibilityForEpDevices$LAYOUT, GetModelCompatibilityForEpDevices$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)
     * }
     */
    public final static class CreateExternalInitializerInfo {

        private CreateExternalInitializerInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateExternalInitializerInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateExternalInitializerInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateExternalInitializerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateExternalInitializerInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)
     * }
     */
    public static final AddressLayout CreateExternalInitializerInfo$layout() {
        return CreateExternalInitializerInfo$LAYOUT;
    }

    private static final long CreateExternalInitializerInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateExternalInitializerInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)
     * }
     */
    public static final long CreateExternalInitializerInfo$offset() {
        return CreateExternalInitializerInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)
     * }
     */
    public static MemorySegment CreateExternalInitializerInfo(MemorySegment struct) {
        return struct.get(CreateExternalInitializerInfo$LAYOUT, CreateExternalInitializerInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)
     * }
     */
    public static void CreateExternalInitializerInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateExternalInitializerInfo$LAYOUT, CreateExternalInitializerInfo$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

