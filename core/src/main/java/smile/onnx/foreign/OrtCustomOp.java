// Generated by jextract

package smile.onnx.foreign;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct OrtCustomOp {
 *     uint32_t version;
 *     void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *);
 *     const char *(*GetName)(const struct OrtCustomOp *);
 *     const char *(*GetExecutionProviderType)(const struct OrtCustomOp *);
 *     ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t);
 *     size_t (*GetInputTypeCount)(const struct OrtCustomOp *);
 *     ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t);
 *     size_t (*GetOutputTypeCount)(const struct OrtCustomOp *);
 *     void (*KernelCompute)(void *, OrtKernelContext *);
 *     void (*KernelDestroy)(void *);
 *     OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t);
 *     OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t);
 *     OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t);
 *     int (*GetVariadicInputMinArity)(const struct OrtCustomOp *);
 *     int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *);
 *     int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *);
 *     int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *);
 *     OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **);
 *     OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *);
 *     OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *);
 *     int (*GetStartVersion)(const struct OrtCustomOp *);
 *     int (*GetEndVersion)(const struct OrtCustomOp *);
 *     size_t (*GetMayInplace)(int **, int **);
 *     void (*ReleaseMayInplace)(int *, int *);
 *     size_t (*GetAliasMap)(int **, int **);
 *     void (*ReleaseAliasMap)(int *, int *);
 * }
 * }
 */
public class OrtCustomOp {

    OrtCustomOp() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        onnxruntime_c_api_h.C_INT.withName("version"),
        MemoryLayout.paddingLayout(4),
        onnxruntime_c_api_h.C_POINTER.withName("CreateKernel"),
        onnxruntime_c_api_h.C_POINTER.withName("GetName"),
        onnxruntime_c_api_h.C_POINTER.withName("GetExecutionProviderType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetInputType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetInputTypeCount"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOutputType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOutputTypeCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelCompute"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelDestroy"),
        onnxruntime_c_api_h.C_POINTER.withName("GetInputCharacteristic"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOutputCharacteristic"),
        onnxruntime_c_api_h.C_POINTER.withName("GetInputMemoryType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetVariadicInputMinArity"),
        onnxruntime_c_api_h.C_POINTER.withName("GetVariadicInputHomogeneity"),
        onnxruntime_c_api_h.C_POINTER.withName("GetVariadicOutputMinArity"),
        onnxruntime_c_api_h.C_POINTER.withName("GetVariadicOutputHomogeneity"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateKernelV2"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelComputeV2"),
        onnxruntime_c_api_h.C_POINTER.withName("InferOutputShapeFn"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStartVersion"),
        onnxruntime_c_api_h.C_POINTER.withName("GetEndVersion"),
        onnxruntime_c_api_h.C_POINTER.withName("GetMayInplace"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseMayInplace"),
        onnxruntime_c_api_h.C_POINTER.withName("GetAliasMap"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseAliasMap")
    ).withName("OrtCustomOp");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t version
     * }
     */
    public static final OfInt version$layout() {
        return version$LAYOUT;
    }

    private static final long version$OFFSET = $LAYOUT.byteOffset(groupElement("version"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t version
     * }
     */
    public static final long version$offset() {
        return version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t version
     * }
     */
    public static int version(MemorySegment struct) {
        return struct.get(version$LAYOUT, version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue) {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)
     * }
     */
    public final static class CreateKernel {

        private CreateKernel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateKernel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateKernel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateKernel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateKernel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)
     * }
     */
    public static final AddressLayout CreateKernel$layout() {
        return CreateKernel$LAYOUT;
    }

    private static final long CreateKernel$OFFSET = $LAYOUT.byteOffset(groupElement("CreateKernel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)
     * }
     */
    public static final long CreateKernel$offset() {
        return CreateKernel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)
     * }
     */
    public static MemorySegment CreateKernel(MemorySegment struct) {
        return struct.get(CreateKernel$LAYOUT, CreateKernel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)
     * }
     */
    public static void CreateKernel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateKernel$LAYOUT, CreateKernel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetName)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetName {

        private GetName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetName)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetName$layout() {
        return GetName$LAYOUT;
    }

    private static final long GetName$OFFSET = $LAYOUT.byteOffset(groupElement("GetName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetName)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetName$offset() {
        return GetName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetName)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetName(MemorySegment struct) {
        return struct.get(GetName$LAYOUT, GetName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetName)(const struct OrtCustomOp *)
     * }
     */
    public static void GetName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetName$LAYOUT, GetName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetExecutionProviderType {

        private GetExecutionProviderType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetExecutionProviderType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetExecutionProviderType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetExecutionProviderType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetExecutionProviderType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetExecutionProviderType$layout() {
        return GetExecutionProviderType$LAYOUT;
    }

    private static final long GetExecutionProviderType$OFFSET = $LAYOUT.byteOffset(groupElement("GetExecutionProviderType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetExecutionProviderType$offset() {
        return GetExecutionProviderType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetExecutionProviderType(MemorySegment struct) {
        return struct.get(GetExecutionProviderType$LAYOUT, GetExecutionProviderType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)
     * }
     */
    public static void GetExecutionProviderType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetExecutionProviderType$LAYOUT, GetExecutionProviderType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public final static class GetInputType {

        private GetInputType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetInputType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetInputType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetInputType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final AddressLayout GetInputType$layout() {
        return GetInputType$LAYOUT;
    }

    private static final long GetInputType$OFFSET = $LAYOUT.byteOffset(groupElement("GetInputType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final long GetInputType$offset() {
        return GetInputType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static MemorySegment GetInputType(MemorySegment struct) {
        return struct.get(GetInputType$LAYOUT, GetInputType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static void GetInputType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetInputType$LAYOUT, GetInputType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetInputTypeCount {

        private GetInputTypeCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputTypeCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetInputTypeCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetInputTypeCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetInputTypeCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetInputTypeCount$layout() {
        return GetInputTypeCount$LAYOUT;
    }

    private static final long GetInputTypeCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetInputTypeCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetInputTypeCount$offset() {
        return GetInputTypeCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetInputTypeCount(MemorySegment struct) {
        return struct.get(GetInputTypeCount$LAYOUT, GetInputTypeCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static void GetInputTypeCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetInputTypeCount$LAYOUT, GetInputTypeCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public final static class GetOutputType {

        private GetOutputType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOutputType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOutputType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOutputType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOutputType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final AddressLayout GetOutputType$layout() {
        return GetOutputType$LAYOUT;
    }

    private static final long GetOutputType$OFFSET = $LAYOUT.byteOffset(groupElement("GetOutputType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final long GetOutputType$offset() {
        return GetOutputType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static MemorySegment GetOutputType(MemorySegment struct) {
        return struct.get(GetOutputType$LAYOUT, GetOutputType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static void GetOutputType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOutputType$LAYOUT, GetOutputType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetOutputTypeCount {

        private GetOutputTypeCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOutputTypeCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOutputTypeCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOutputTypeCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOutputTypeCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetOutputTypeCount$layout() {
        return GetOutputTypeCount$LAYOUT;
    }

    private static final long GetOutputTypeCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetOutputTypeCount"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetOutputTypeCount$offset() {
        return GetOutputTypeCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetOutputTypeCount(MemorySegment struct) {
        return struct.get(GetOutputTypeCount$LAYOUT, GetOutputTypeCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)
     * }
     */
    public static void GetOutputTypeCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOutputTypeCount$LAYOUT, GetOutputTypeCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*KernelCompute)(void *, OrtKernelContext *)
     * }
     */
    public final static class KernelCompute {

        private KernelCompute() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelCompute.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelCompute.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelCompute"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*KernelCompute)(void *, OrtKernelContext *)
     * }
     */
    public static final AddressLayout KernelCompute$layout() {
        return KernelCompute$LAYOUT;
    }

    private static final long KernelCompute$OFFSET = $LAYOUT.byteOffset(groupElement("KernelCompute"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*KernelCompute)(void *, OrtKernelContext *)
     * }
     */
    public static final long KernelCompute$offset() {
        return KernelCompute$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*KernelCompute)(void *, OrtKernelContext *)
     * }
     */
    public static MemorySegment KernelCompute(MemorySegment struct) {
        return struct.get(KernelCompute$LAYOUT, KernelCompute$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*KernelCompute)(void *, OrtKernelContext *)
     * }
     */
    public static void KernelCompute(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelCompute$LAYOUT, KernelCompute$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*KernelDestroy)(void *)
     * }
     */
    public final static class KernelDestroy {

        private KernelDestroy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelDestroy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelDestroy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelDestroy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelDestroy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*KernelDestroy)(void *)
     * }
     */
    public static final AddressLayout KernelDestroy$layout() {
        return KernelDestroy$LAYOUT;
    }

    private static final long KernelDestroy$OFFSET = $LAYOUT.byteOffset(groupElement("KernelDestroy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*KernelDestroy)(void *)
     * }
     */
    public static final long KernelDestroy$offset() {
        return KernelDestroy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*KernelDestroy)(void *)
     * }
     */
    public static MemorySegment KernelDestroy(MemorySegment struct) {
        return struct.get(KernelDestroy$LAYOUT, KernelDestroy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*KernelDestroy)(void *)
     * }
     */
    public static void KernelDestroy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelDestroy$LAYOUT, KernelDestroy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public final static class GetInputCharacteristic {

        private GetInputCharacteristic() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputCharacteristic.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetInputCharacteristic.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetInputCharacteristic$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetInputCharacteristic"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final AddressLayout GetInputCharacteristic$layout() {
        return GetInputCharacteristic$LAYOUT;
    }

    private static final long GetInputCharacteristic$OFFSET = $LAYOUT.byteOffset(groupElement("GetInputCharacteristic"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final long GetInputCharacteristic$offset() {
        return GetInputCharacteristic$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static MemorySegment GetInputCharacteristic(MemorySegment struct) {
        return struct.get(GetInputCharacteristic$LAYOUT, GetInputCharacteristic$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static void GetInputCharacteristic(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetInputCharacteristic$LAYOUT, GetInputCharacteristic$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public final static class GetOutputCharacteristic {

        private GetOutputCharacteristic() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOutputCharacteristic.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOutputCharacteristic.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOutputCharacteristic$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOutputCharacteristic"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final AddressLayout GetOutputCharacteristic$layout() {
        return GetOutputCharacteristic$LAYOUT;
    }

    private static final long GetOutputCharacteristic$OFFSET = $LAYOUT.byteOffset(groupElement("GetOutputCharacteristic"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final long GetOutputCharacteristic$offset() {
        return GetOutputCharacteristic$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static MemorySegment GetOutputCharacteristic(MemorySegment struct) {
        return struct.get(GetOutputCharacteristic$LAYOUT, GetOutputCharacteristic$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static void GetOutputCharacteristic(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOutputCharacteristic$LAYOUT, GetOutputCharacteristic$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public final static class GetInputMemoryType {

        private GetInputMemoryType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputMemoryType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetInputMemoryType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetInputMemoryType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetInputMemoryType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final AddressLayout GetInputMemoryType$layout() {
        return GetInputMemoryType$LAYOUT;
    }

    private static final long GetInputMemoryType$OFFSET = $LAYOUT.byteOffset(groupElement("GetInputMemoryType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static final long GetInputMemoryType$offset() {
        return GetInputMemoryType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static MemorySegment GetInputMemoryType(MemorySegment struct) {
        return struct.get(GetInputMemoryType$LAYOUT, GetInputMemoryType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)
     * }
     */
    public static void GetInputMemoryType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetInputMemoryType$LAYOUT, GetInputMemoryType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetVariadicInputMinArity {

        private GetVariadicInputMinArity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicInputMinArity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVariadicInputMinArity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVariadicInputMinArity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVariadicInputMinArity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetVariadicInputMinArity$layout() {
        return GetVariadicInputMinArity$LAYOUT;
    }

    private static final long GetVariadicInputMinArity$OFFSET = $LAYOUT.byteOffset(groupElement("GetVariadicInputMinArity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetVariadicInputMinArity$offset() {
        return GetVariadicInputMinArity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetVariadicInputMinArity(MemorySegment struct) {
        return struct.get(GetVariadicInputMinArity$LAYOUT, GetVariadicInputMinArity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static void GetVariadicInputMinArity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVariadicInputMinArity$LAYOUT, GetVariadicInputMinArity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetVariadicInputHomogeneity {

        private GetVariadicInputHomogeneity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicInputHomogeneity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVariadicInputHomogeneity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVariadicInputHomogeneity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVariadicInputHomogeneity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetVariadicInputHomogeneity$layout() {
        return GetVariadicInputHomogeneity$LAYOUT;
    }

    private static final long GetVariadicInputHomogeneity$OFFSET = $LAYOUT.byteOffset(groupElement("GetVariadicInputHomogeneity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetVariadicInputHomogeneity$offset() {
        return GetVariadicInputHomogeneity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetVariadicInputHomogeneity(MemorySegment struct) {
        return struct.get(GetVariadicInputHomogeneity$LAYOUT, GetVariadicInputHomogeneity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static void GetVariadicInputHomogeneity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVariadicInputHomogeneity$LAYOUT, GetVariadicInputHomogeneity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetVariadicOutputMinArity {

        private GetVariadicOutputMinArity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicOutputMinArity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVariadicOutputMinArity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVariadicOutputMinArity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVariadicOutputMinArity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetVariadicOutputMinArity$layout() {
        return GetVariadicOutputMinArity$LAYOUT;
    }

    private static final long GetVariadicOutputMinArity$OFFSET = $LAYOUT.byteOffset(groupElement("GetVariadicOutputMinArity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetVariadicOutputMinArity$offset() {
        return GetVariadicOutputMinArity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetVariadicOutputMinArity(MemorySegment struct) {
        return struct.get(GetVariadicOutputMinArity$LAYOUT, GetVariadicOutputMinArity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)
     * }
     */
    public static void GetVariadicOutputMinArity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVariadicOutputMinArity$LAYOUT, GetVariadicOutputMinArity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetVariadicOutputHomogeneity {

        private GetVariadicOutputHomogeneity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicOutputHomogeneity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVariadicOutputHomogeneity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVariadicOutputHomogeneity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVariadicOutputHomogeneity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetVariadicOutputHomogeneity$layout() {
        return GetVariadicOutputHomogeneity$LAYOUT;
    }

    private static final long GetVariadicOutputHomogeneity$OFFSET = $LAYOUT.byteOffset(groupElement("GetVariadicOutputHomogeneity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetVariadicOutputHomogeneity$offset() {
        return GetVariadicOutputHomogeneity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetVariadicOutputHomogeneity(MemorySegment struct) {
        return struct.get(GetVariadicOutputHomogeneity$LAYOUT, GetVariadicOutputHomogeneity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)
     * }
     */
    public static void GetVariadicOutputHomogeneity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVariadicOutputHomogeneity$LAYOUT, GetVariadicOutputHomogeneity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)
     * }
     */
    public final static class CreateKernelV2 {

        private CreateKernelV2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateKernelV2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateKernelV2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateKernelV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateKernelV2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)
     * }
     */
    public static final AddressLayout CreateKernelV2$layout() {
        return CreateKernelV2$LAYOUT;
    }

    private static final long CreateKernelV2$OFFSET = $LAYOUT.byteOffset(groupElement("CreateKernelV2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)
     * }
     */
    public static final long CreateKernelV2$offset() {
        return CreateKernelV2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)
     * }
     */
    public static MemorySegment CreateKernelV2(MemorySegment struct) {
        return struct.get(CreateKernelV2$LAYOUT, CreateKernelV2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)
     * }
     */
    public static void CreateKernelV2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateKernelV2$LAYOUT, CreateKernelV2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)
     * }
     */
    public final static class KernelComputeV2 {

        private KernelComputeV2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelComputeV2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelComputeV2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelComputeV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelComputeV2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)
     * }
     */
    public static final AddressLayout KernelComputeV2$layout() {
        return KernelComputeV2$LAYOUT;
    }

    private static final long KernelComputeV2$OFFSET = $LAYOUT.byteOffset(groupElement("KernelComputeV2"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)
     * }
     */
    public static final long KernelComputeV2$offset() {
        return KernelComputeV2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)
     * }
     */
    public static MemorySegment KernelComputeV2(MemorySegment struct) {
        return struct.get(KernelComputeV2$LAYOUT, KernelComputeV2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)
     * }
     */
    public static void KernelComputeV2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelComputeV2$LAYOUT, KernelComputeV2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)
     * }
     */
    public final static class InferOutputShapeFn {

        private InferOutputShapeFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(InferOutputShapeFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(InferOutputShapeFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout InferOutputShapeFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("InferOutputShapeFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)
     * }
     */
    public static final AddressLayout InferOutputShapeFn$layout() {
        return InferOutputShapeFn$LAYOUT;
    }

    private static final long InferOutputShapeFn$OFFSET = $LAYOUT.byteOffset(groupElement("InferOutputShapeFn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)
     * }
     */
    public static final long InferOutputShapeFn$offset() {
        return InferOutputShapeFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)
     * }
     */
    public static MemorySegment InferOutputShapeFn(MemorySegment struct) {
        return struct.get(InferOutputShapeFn$LAYOUT, InferOutputShapeFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)
     * }
     */
    public static void InferOutputShapeFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(InferOutputShapeFn$LAYOUT, InferOutputShapeFn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*GetStartVersion)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetStartVersion {

        private GetStartVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStartVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStartVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStartVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStartVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*GetStartVersion)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetStartVersion$layout() {
        return GetStartVersion$LAYOUT;
    }

    private static final long GetStartVersion$OFFSET = $LAYOUT.byteOffset(groupElement("GetStartVersion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*GetStartVersion)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetStartVersion$offset() {
        return GetStartVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*GetStartVersion)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetStartVersion(MemorySegment struct) {
        return struct.get(GetStartVersion$LAYOUT, GetStartVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*GetStartVersion)(const struct OrtCustomOp *)
     * }
     */
    public static void GetStartVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStartVersion$LAYOUT, GetStartVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*GetEndVersion)(const struct OrtCustomOp *)
     * }
     */
    public final static class GetEndVersion {

        private GetEndVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetEndVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetEndVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetEndVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetEndVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*GetEndVersion)(const struct OrtCustomOp *)
     * }
     */
    public static final AddressLayout GetEndVersion$layout() {
        return GetEndVersion$LAYOUT;
    }

    private static final long GetEndVersion$OFFSET = $LAYOUT.byteOffset(groupElement("GetEndVersion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*GetEndVersion)(const struct OrtCustomOp *)
     * }
     */
    public static final long GetEndVersion$offset() {
        return GetEndVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*GetEndVersion)(const struct OrtCustomOp *)
     * }
     */
    public static MemorySegment GetEndVersion(MemorySegment struct) {
        return struct.get(GetEndVersion$LAYOUT, GetEndVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*GetEndVersion)(const struct OrtCustomOp *)
     * }
     */
    public static void GetEndVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetEndVersion$LAYOUT, GetEndVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * size_t (*GetMayInplace)(int **, int **)
     * }
     */
    public final static class GetMayInplace {

        private GetMayInplace() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetMayInplace.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMayInplace.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMayInplace$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMayInplace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t (*GetMayInplace)(int **, int **)
     * }
     */
    public static final AddressLayout GetMayInplace$layout() {
        return GetMayInplace$LAYOUT;
    }

    private static final long GetMayInplace$OFFSET = $LAYOUT.byteOffset(groupElement("GetMayInplace"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t (*GetMayInplace)(int **, int **)
     * }
     */
    public static final long GetMayInplace$offset() {
        return GetMayInplace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t (*GetMayInplace)(int **, int **)
     * }
     */
    public static MemorySegment GetMayInplace(MemorySegment struct) {
        return struct.get(GetMayInplace$LAYOUT, GetMayInplace$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t (*GetMayInplace)(int **, int **)
     * }
     */
    public static void GetMayInplace(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMayInplace$LAYOUT, GetMayInplace$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMayInplace)(int *, int *)
     * }
     */
    public final static class ReleaseMayInplace {

        private ReleaseMayInplace() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseMayInplace.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseMayInplace.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseMayInplace$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseMayInplace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseMayInplace)(int *, int *)
     * }
     */
    public static final AddressLayout ReleaseMayInplace$layout() {
        return ReleaseMayInplace$LAYOUT;
    }

    private static final long ReleaseMayInplace$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseMayInplace"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseMayInplace)(int *, int *)
     * }
     */
    public static final long ReleaseMayInplace$offset() {
        return ReleaseMayInplace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMayInplace)(int *, int *)
     * }
     */
    public static MemorySegment ReleaseMayInplace(MemorySegment struct) {
        return struct.get(ReleaseMayInplace$LAYOUT, ReleaseMayInplace$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseMayInplace)(int *, int *)
     * }
     */
    public static void ReleaseMayInplace(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseMayInplace$LAYOUT, ReleaseMayInplace$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * size_t (*GetAliasMap)(int **, int **)
     * }
     */
    public final static class GetAliasMap {

        private GetAliasMap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetAliasMap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAliasMap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAliasMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAliasMap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t (*GetAliasMap)(int **, int **)
     * }
     */
    public static final AddressLayout GetAliasMap$layout() {
        return GetAliasMap$LAYOUT;
    }

    private static final long GetAliasMap$OFFSET = $LAYOUT.byteOffset(groupElement("GetAliasMap"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t (*GetAliasMap)(int **, int **)
     * }
     */
    public static final long GetAliasMap$offset() {
        return GetAliasMap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t (*GetAliasMap)(int **, int **)
     * }
     */
    public static MemorySegment GetAliasMap(MemorySegment struct) {
        return struct.get(GetAliasMap$LAYOUT, GetAliasMap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t (*GetAliasMap)(int **, int **)
     * }
     */
    public static void GetAliasMap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAliasMap$LAYOUT, GetAliasMap$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseAliasMap)(int *, int *)
     * }
     */
    public final static class ReleaseAliasMap {

        private ReleaseAliasMap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseAliasMap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseAliasMap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseAliasMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseAliasMap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseAliasMap)(int *, int *)
     * }
     */
    public static final AddressLayout ReleaseAliasMap$layout() {
        return ReleaseAliasMap$LAYOUT;
    }

    private static final long ReleaseAliasMap$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseAliasMap"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseAliasMap)(int *, int *)
     * }
     */
    public static final long ReleaseAliasMap$offset() {
        return ReleaseAliasMap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseAliasMap)(int *, int *)
     * }
     */
    public static MemorySegment ReleaseAliasMap(MemorySegment struct) {
        return struct.get(ReleaseAliasMap$LAYOUT, ReleaseAliasMap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseAliasMap)(int *, int *)
     * }
     */
    public static void ReleaseAliasMap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseAliasMap$LAYOUT, ReleaseAliasMap$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

