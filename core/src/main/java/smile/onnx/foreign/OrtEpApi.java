// Generated by jextract

package smile.onnx.foreign;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct OrtEpApi {
 *     OrtStatusPtr (*CreateEpDevice)(OrtEpFactory *, const OrtHardwareDevice *, const OrtKeyValuePairs *, const OrtKeyValuePairs *, OrtEpDevice **);
 *     void (*ReleaseEpDevice)(OrtEpDevice *);
 *     OrtStatusPtr (*EpGraphSupportInfo_AddNodesToFuse)(OrtEpGraphSupportInfo *, const OrtNode *const *, size_t, const OrtNodeFusionOptions *);
 *     OrtStatusPtr (*EpGraphSupportInfo_AddSingleNode)(OrtEpGraphSupportInfo *, const OrtNode *);
 *     const char *(*NodeComputeContext_NodeName)(const OrtNodeComputeContext *);
 *     OrtStatusPtr (*EpDevice_AddAllocatorInfo)(OrtEpDevice *, const OrtMemoryInfo *);
 *     const OrtMemoryDevice *(*MemoryInfo_GetMemoryDevice)(const OrtMemoryInfo *);
 *     const OrtMemoryDevice *(*Value_GetMemoryDevice)(const OrtValue *);
 *     bool (*MemoryDevice_AreEqual)(const OrtMemoryDevice *, const OrtMemoryDevice *);
 *     OrtMemoryInfoDeviceType (*MemoryDevice_GetDeviceType)(const OrtMemoryDevice *);
 *     OrtDeviceMemoryType (*MemoryDevice_GetMemoryType)(const OrtMemoryDevice *);
 *     uint32_t (*MemoryDevice_GetVendorId)(const OrtMemoryDevice *);
 *     uint32_t (*MemoryDevice_GetDeviceId)(const OrtMemoryDevice *);
 *     const OrtSyncStreamImpl *(*SyncStream_GetImpl)(const OrtSyncStream *);
 *     uint64_t (*SyncStream_GetSyncId)(const OrtSyncStream *);
 *     uint64_t (*GetSyncIdForLastWaitOnSyncStream)(const OrtSyncStream *, const OrtSyncStream *);
 * }
 * }
 */
public class OrtEpApi {

    OrtEpApi() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        onnxruntime_c_api_h.C_POINTER.withName("CreateEpDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseEpDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("EpGraphSupportInfo_AddNodesToFuse"),
        onnxruntime_c_api_h.C_POINTER.withName("EpGraphSupportInfo_AddSingleNode"),
        onnxruntime_c_api_h.C_POINTER.withName("NodeComputeContext_NodeName"),
        onnxruntime_c_api_h.C_POINTER.withName("EpDevice_AddAllocatorInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfo_GetMemoryDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("Value_GetMemoryDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryDevice_AreEqual"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryDevice_GetDeviceType"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryDevice_GetMemoryType"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryDevice_GetVendorId"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryDevice_GetDeviceId"),
        onnxruntime_c_api_h.C_POINTER.withName("SyncStream_GetImpl"),
        onnxruntime_c_api_h.C_POINTER.withName("SyncStream_GetSyncId"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSyncIdForLastWaitOnSyncStream")
    ).withName("OrtEpApi");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEpDevice)(OrtEpFactory *, const OrtHardwareDevice *, const OrtKeyValuePairs *, const OrtKeyValuePairs *, OrtEpDevice **)
     * }
     */
    public final static class CreateEpDevice {

        private CreateEpDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateEpDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEpDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEpDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEpDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEpDevice)(OrtEpFactory *, const OrtHardwareDevice *, const OrtKeyValuePairs *, const OrtKeyValuePairs *, OrtEpDevice **)
     * }
     */
    public static final AddressLayout CreateEpDevice$layout() {
        return CreateEpDevice$LAYOUT;
    }

    private static final long CreateEpDevice$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEpDevice"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEpDevice)(OrtEpFactory *, const OrtHardwareDevice *, const OrtKeyValuePairs *, const OrtKeyValuePairs *, OrtEpDevice **)
     * }
     */
    public static final long CreateEpDevice$offset() {
        return CreateEpDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEpDevice)(OrtEpFactory *, const OrtHardwareDevice *, const OrtKeyValuePairs *, const OrtKeyValuePairs *, OrtEpDevice **)
     * }
     */
    public static MemorySegment CreateEpDevice(MemorySegment struct) {
        return struct.get(CreateEpDevice$LAYOUT, CreateEpDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEpDevice)(OrtEpFactory *, const OrtHardwareDevice *, const OrtKeyValuePairs *, const OrtKeyValuePairs *, OrtEpDevice **)
     * }
     */
    public static void CreateEpDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEpDevice$LAYOUT, CreateEpDevice$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseEpDevice)(OrtEpDevice *)
     * }
     */
    public final static class ReleaseEpDevice {

        private ReleaseEpDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseEpDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseEpDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseEpDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseEpDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseEpDevice)(OrtEpDevice *)
     * }
     */
    public static final AddressLayout ReleaseEpDevice$layout() {
        return ReleaseEpDevice$LAYOUT;
    }

    private static final long ReleaseEpDevice$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseEpDevice"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseEpDevice)(OrtEpDevice *)
     * }
     */
    public static final long ReleaseEpDevice$offset() {
        return ReleaseEpDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseEpDevice)(OrtEpDevice *)
     * }
     */
    public static MemorySegment ReleaseEpDevice(MemorySegment struct) {
        return struct.get(ReleaseEpDevice$LAYOUT, ReleaseEpDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseEpDevice)(OrtEpDevice *)
     * }
     */
    public static void ReleaseEpDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseEpDevice$LAYOUT, ReleaseEpDevice$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddNodesToFuse)(OrtEpGraphSupportInfo *, const OrtNode *const *, size_t, const OrtNodeFusionOptions *)
     * }
     */
    public final static class EpGraphSupportInfo_AddNodesToFuse {

        private EpGraphSupportInfo_AddNodesToFuse() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpGraphSupportInfo_AddNodesToFuse.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpGraphSupportInfo_AddNodesToFuse.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpGraphSupportInfo_AddNodesToFuse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpGraphSupportInfo_AddNodesToFuse"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddNodesToFuse)(OrtEpGraphSupportInfo *, const OrtNode *const *, size_t, const OrtNodeFusionOptions *)
     * }
     */
    public static final AddressLayout EpGraphSupportInfo_AddNodesToFuse$layout() {
        return EpGraphSupportInfo_AddNodesToFuse$LAYOUT;
    }

    private static final long EpGraphSupportInfo_AddNodesToFuse$OFFSET = $LAYOUT.byteOffset(groupElement("EpGraphSupportInfo_AddNodesToFuse"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddNodesToFuse)(OrtEpGraphSupportInfo *, const OrtNode *const *, size_t, const OrtNodeFusionOptions *)
     * }
     */
    public static final long EpGraphSupportInfo_AddNodesToFuse$offset() {
        return EpGraphSupportInfo_AddNodesToFuse$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddNodesToFuse)(OrtEpGraphSupportInfo *, const OrtNode *const *, size_t, const OrtNodeFusionOptions *)
     * }
     */
    public static MemorySegment EpGraphSupportInfo_AddNodesToFuse(MemorySegment struct) {
        return struct.get(EpGraphSupportInfo_AddNodesToFuse$LAYOUT, EpGraphSupportInfo_AddNodesToFuse$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddNodesToFuse)(OrtEpGraphSupportInfo *, const OrtNode *const *, size_t, const OrtNodeFusionOptions *)
     * }
     */
    public static void EpGraphSupportInfo_AddNodesToFuse(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpGraphSupportInfo_AddNodesToFuse$LAYOUT, EpGraphSupportInfo_AddNodesToFuse$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddSingleNode)(OrtEpGraphSupportInfo *, const OrtNode *)
     * }
     */
    public final static class EpGraphSupportInfo_AddSingleNode {

        private EpGraphSupportInfo_AddSingleNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpGraphSupportInfo_AddSingleNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpGraphSupportInfo_AddSingleNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpGraphSupportInfo_AddSingleNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpGraphSupportInfo_AddSingleNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddSingleNode)(OrtEpGraphSupportInfo *, const OrtNode *)
     * }
     */
    public static final AddressLayout EpGraphSupportInfo_AddSingleNode$layout() {
        return EpGraphSupportInfo_AddSingleNode$LAYOUT;
    }

    private static final long EpGraphSupportInfo_AddSingleNode$OFFSET = $LAYOUT.byteOffset(groupElement("EpGraphSupportInfo_AddSingleNode"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddSingleNode)(OrtEpGraphSupportInfo *, const OrtNode *)
     * }
     */
    public static final long EpGraphSupportInfo_AddSingleNode$offset() {
        return EpGraphSupportInfo_AddSingleNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddSingleNode)(OrtEpGraphSupportInfo *, const OrtNode *)
     * }
     */
    public static MemorySegment EpGraphSupportInfo_AddSingleNode(MemorySegment struct) {
        return struct.get(EpGraphSupportInfo_AddSingleNode$LAYOUT, EpGraphSupportInfo_AddSingleNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpGraphSupportInfo_AddSingleNode)(OrtEpGraphSupportInfo *, const OrtNode *)
     * }
     */
    public static void EpGraphSupportInfo_AddSingleNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpGraphSupportInfo_AddSingleNode$LAYOUT, EpGraphSupportInfo_AddSingleNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*NodeComputeContext_NodeName)(const OrtNodeComputeContext *)
     * }
     */
    public final static class NodeComputeContext_NodeName {

        private NodeComputeContext_NodeName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(NodeComputeContext_NodeName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NodeComputeContext_NodeName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NodeComputeContext_NodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NodeComputeContext_NodeName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*NodeComputeContext_NodeName)(const OrtNodeComputeContext *)
     * }
     */
    public static final AddressLayout NodeComputeContext_NodeName$layout() {
        return NodeComputeContext_NodeName$LAYOUT;
    }

    private static final long NodeComputeContext_NodeName$OFFSET = $LAYOUT.byteOffset(groupElement("NodeComputeContext_NodeName"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*NodeComputeContext_NodeName)(const OrtNodeComputeContext *)
     * }
     */
    public static final long NodeComputeContext_NodeName$offset() {
        return NodeComputeContext_NodeName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*NodeComputeContext_NodeName)(const OrtNodeComputeContext *)
     * }
     */
    public static MemorySegment NodeComputeContext_NodeName(MemorySegment struct) {
        return struct.get(NodeComputeContext_NodeName$LAYOUT, NodeComputeContext_NodeName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*NodeComputeContext_NodeName)(const OrtNodeComputeContext *)
     * }
     */
    public static void NodeComputeContext_NodeName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NodeComputeContext_NodeName$LAYOUT, NodeComputeContext_NodeName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EpDevice_AddAllocatorInfo)(OrtEpDevice *, const OrtMemoryInfo *)
     * }
     */
    public final static class EpDevice_AddAllocatorInfo {

        private EpDevice_AddAllocatorInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpDevice_AddAllocatorInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EpDevice_AddAllocatorInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EpDevice_AddAllocatorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EpDevice_AddAllocatorInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpDevice_AddAllocatorInfo)(OrtEpDevice *, const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout EpDevice_AddAllocatorInfo$layout() {
        return EpDevice_AddAllocatorInfo$LAYOUT;
    }

    private static final long EpDevice_AddAllocatorInfo$OFFSET = $LAYOUT.byteOffset(groupElement("EpDevice_AddAllocatorInfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpDevice_AddAllocatorInfo)(OrtEpDevice *, const OrtMemoryInfo *)
     * }
     */
    public static final long EpDevice_AddAllocatorInfo$offset() {
        return EpDevice_AddAllocatorInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpDevice_AddAllocatorInfo)(OrtEpDevice *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment EpDevice_AddAllocatorInfo(MemorySegment struct) {
        return struct.get(EpDevice_AddAllocatorInfo$LAYOUT, EpDevice_AddAllocatorInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EpDevice_AddAllocatorInfo)(OrtEpDevice *, const OrtMemoryInfo *)
     * }
     */
    public static void EpDevice_AddAllocatorInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EpDevice_AddAllocatorInfo$LAYOUT, EpDevice_AddAllocatorInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*MemoryInfo_GetMemoryDevice)(const OrtMemoryInfo *)
     * }
     */
    public final static class MemoryInfo_GetMemoryDevice {

        private MemoryInfo_GetMemoryDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryInfo_GetMemoryDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfo_GetMemoryDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfo_GetMemoryDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfo_GetMemoryDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*MemoryInfo_GetMemoryDevice)(const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout MemoryInfo_GetMemoryDevice$layout() {
        return MemoryInfo_GetMemoryDevice$LAYOUT;
    }

    private static final long MemoryInfo_GetMemoryDevice$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfo_GetMemoryDevice"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*MemoryInfo_GetMemoryDevice)(const OrtMemoryInfo *)
     * }
     */
    public static final long MemoryInfo_GetMemoryDevice$offset() {
        return MemoryInfo_GetMemoryDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*MemoryInfo_GetMemoryDevice)(const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment MemoryInfo_GetMemoryDevice(MemorySegment struct) {
        return struct.get(MemoryInfo_GetMemoryDevice$LAYOUT, MemoryInfo_GetMemoryDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*MemoryInfo_GetMemoryDevice)(const OrtMemoryInfo *)
     * }
     */
    public static void MemoryInfo_GetMemoryDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfo_GetMemoryDevice$LAYOUT, MemoryInfo_GetMemoryDevice$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*Value_GetMemoryDevice)(const OrtValue *)
     * }
     */
    public final static class Value_GetMemoryDevice {

        private Value_GetMemoryDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Value_GetMemoryDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Value_GetMemoryDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Value_GetMemoryDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Value_GetMemoryDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*Value_GetMemoryDevice)(const OrtValue *)
     * }
     */
    public static final AddressLayout Value_GetMemoryDevice$layout() {
        return Value_GetMemoryDevice$LAYOUT;
    }

    private static final long Value_GetMemoryDevice$OFFSET = $LAYOUT.byteOffset(groupElement("Value_GetMemoryDevice"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*Value_GetMemoryDevice)(const OrtValue *)
     * }
     */
    public static final long Value_GetMemoryDevice$offset() {
        return Value_GetMemoryDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*Value_GetMemoryDevice)(const OrtValue *)
     * }
     */
    public static MemorySegment Value_GetMemoryDevice(MemorySegment struct) {
        return struct.get(Value_GetMemoryDevice$LAYOUT, Value_GetMemoryDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtMemoryDevice *(*Value_GetMemoryDevice)(const OrtValue *)
     * }
     */
    public static void Value_GetMemoryDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Value_GetMemoryDevice$LAYOUT, Value_GetMemoryDevice$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * bool (*MemoryDevice_AreEqual)(const OrtMemoryDevice *, const OrtMemoryDevice *)
     * }
     */
    public final static class MemoryDevice_AreEqual {

        private MemoryDevice_AreEqual() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            boolean apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_BOOL,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryDevice_AreEqual.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryDevice_AreEqual.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static boolean invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryDevice_AreEqual$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryDevice_AreEqual"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool (*MemoryDevice_AreEqual)(const OrtMemoryDevice *, const OrtMemoryDevice *)
     * }
     */
    public static final AddressLayout MemoryDevice_AreEqual$layout() {
        return MemoryDevice_AreEqual$LAYOUT;
    }

    private static final long MemoryDevice_AreEqual$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryDevice_AreEqual"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool (*MemoryDevice_AreEqual)(const OrtMemoryDevice *, const OrtMemoryDevice *)
     * }
     */
    public static final long MemoryDevice_AreEqual$offset() {
        return MemoryDevice_AreEqual$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool (*MemoryDevice_AreEqual)(const OrtMemoryDevice *, const OrtMemoryDevice *)
     * }
     */
    public static MemorySegment MemoryDevice_AreEqual(MemorySegment struct) {
        return struct.get(MemoryDevice_AreEqual$LAYOUT, MemoryDevice_AreEqual$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool (*MemoryDevice_AreEqual)(const OrtMemoryDevice *, const OrtMemoryDevice *)
     * }
     */
    public static void MemoryDevice_AreEqual(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryDevice_AreEqual$LAYOUT, MemoryDevice_AreEqual$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtMemoryInfoDeviceType (*MemoryDevice_GetDeviceType)(const OrtMemoryDevice *)
     * }
     */
    public final static class MemoryDevice_GetDeviceType {

        private MemoryDevice_GetDeviceType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryDevice_GetDeviceType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryDevice_GetDeviceType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryDevice_GetDeviceType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryDevice_GetDeviceType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtMemoryInfoDeviceType (*MemoryDevice_GetDeviceType)(const OrtMemoryDevice *)
     * }
     */
    public static final AddressLayout MemoryDevice_GetDeviceType$layout() {
        return MemoryDevice_GetDeviceType$LAYOUT;
    }

    private static final long MemoryDevice_GetDeviceType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryDevice_GetDeviceType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtMemoryInfoDeviceType (*MemoryDevice_GetDeviceType)(const OrtMemoryDevice *)
     * }
     */
    public static final long MemoryDevice_GetDeviceType$offset() {
        return MemoryDevice_GetDeviceType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtMemoryInfoDeviceType (*MemoryDevice_GetDeviceType)(const OrtMemoryDevice *)
     * }
     */
    public static MemorySegment MemoryDevice_GetDeviceType(MemorySegment struct) {
        return struct.get(MemoryDevice_GetDeviceType$LAYOUT, MemoryDevice_GetDeviceType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtMemoryInfoDeviceType (*MemoryDevice_GetDeviceType)(const OrtMemoryDevice *)
     * }
     */
    public static void MemoryDevice_GetDeviceType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryDevice_GetDeviceType$LAYOUT, MemoryDevice_GetDeviceType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryDevice_GetMemoryType)(const OrtMemoryDevice *)
     * }
     */
    public final static class MemoryDevice_GetMemoryType {

        private MemoryDevice_GetMemoryType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryDevice_GetMemoryType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryDevice_GetMemoryType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryDevice_GetMemoryType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryDevice_GetMemoryType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryDevice_GetMemoryType)(const OrtMemoryDevice *)
     * }
     */
    public static final AddressLayout MemoryDevice_GetMemoryType$layout() {
        return MemoryDevice_GetMemoryType$LAYOUT;
    }

    private static final long MemoryDevice_GetMemoryType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryDevice_GetMemoryType"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryDevice_GetMemoryType)(const OrtMemoryDevice *)
     * }
     */
    public static final long MemoryDevice_GetMemoryType$offset() {
        return MemoryDevice_GetMemoryType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryDevice_GetMemoryType)(const OrtMemoryDevice *)
     * }
     */
    public static MemorySegment MemoryDevice_GetMemoryType(MemorySegment struct) {
        return struct.get(MemoryDevice_GetMemoryType$LAYOUT, MemoryDevice_GetMemoryType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtDeviceMemoryType (*MemoryDevice_GetMemoryType)(const OrtMemoryDevice *)
     * }
     */
    public static void MemoryDevice_GetMemoryType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryDevice_GetMemoryType$LAYOUT, MemoryDevice_GetMemoryType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetVendorId)(const OrtMemoryDevice *)
     * }
     */
    public final static class MemoryDevice_GetVendorId {

        private MemoryDevice_GetVendorId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryDevice_GetVendorId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryDevice_GetVendorId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryDevice_GetVendorId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryDevice_GetVendorId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetVendorId)(const OrtMemoryDevice *)
     * }
     */
    public static final AddressLayout MemoryDevice_GetVendorId$layout() {
        return MemoryDevice_GetVendorId$LAYOUT;
    }

    private static final long MemoryDevice_GetVendorId$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryDevice_GetVendorId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetVendorId)(const OrtMemoryDevice *)
     * }
     */
    public static final long MemoryDevice_GetVendorId$offset() {
        return MemoryDevice_GetVendorId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetVendorId)(const OrtMemoryDevice *)
     * }
     */
    public static MemorySegment MemoryDevice_GetVendorId(MemorySegment struct) {
        return struct.get(MemoryDevice_GetVendorId$LAYOUT, MemoryDevice_GetVendorId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetVendorId)(const OrtMemoryDevice *)
     * }
     */
    public static void MemoryDevice_GetVendorId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryDevice_GetVendorId$LAYOUT, MemoryDevice_GetVendorId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetDeviceId)(const OrtMemoryDevice *)
     * }
     */
    public final static class MemoryDevice_GetDeviceId {

        private MemoryDevice_GetDeviceId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(MemoryDevice_GetDeviceId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryDevice_GetDeviceId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryDevice_GetDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryDevice_GetDeviceId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetDeviceId)(const OrtMemoryDevice *)
     * }
     */
    public static final AddressLayout MemoryDevice_GetDeviceId$layout() {
        return MemoryDevice_GetDeviceId$LAYOUT;
    }

    private static final long MemoryDevice_GetDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryDevice_GetDeviceId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetDeviceId)(const OrtMemoryDevice *)
     * }
     */
    public static final long MemoryDevice_GetDeviceId$offset() {
        return MemoryDevice_GetDeviceId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetDeviceId)(const OrtMemoryDevice *)
     * }
     */
    public static MemorySegment MemoryDevice_GetDeviceId(MemorySegment struct) {
        return struct.get(MemoryDevice_GetDeviceId$LAYOUT, MemoryDevice_GetDeviceId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*MemoryDevice_GetDeviceId)(const OrtMemoryDevice *)
     * }
     */
    public static void MemoryDevice_GetDeviceId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryDevice_GetDeviceId$LAYOUT, MemoryDevice_GetDeviceId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const OrtSyncStreamImpl *(*SyncStream_GetImpl)(const OrtSyncStream *)
     * }
     */
    public final static class SyncStream_GetImpl {

        private SyncStream_GetImpl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SyncStream_GetImpl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SyncStream_GetImpl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SyncStream_GetImpl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SyncStream_GetImpl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtSyncStreamImpl *(*SyncStream_GetImpl)(const OrtSyncStream *)
     * }
     */
    public static final AddressLayout SyncStream_GetImpl$layout() {
        return SyncStream_GetImpl$LAYOUT;
    }

    private static final long SyncStream_GetImpl$OFFSET = $LAYOUT.byteOffset(groupElement("SyncStream_GetImpl"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtSyncStreamImpl *(*SyncStream_GetImpl)(const OrtSyncStream *)
     * }
     */
    public static final long SyncStream_GetImpl$offset() {
        return SyncStream_GetImpl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtSyncStreamImpl *(*SyncStream_GetImpl)(const OrtSyncStream *)
     * }
     */
    public static MemorySegment SyncStream_GetImpl(MemorySegment struct) {
        return struct.get(SyncStream_GetImpl$LAYOUT, SyncStream_GetImpl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtSyncStreamImpl *(*SyncStream_GetImpl)(const OrtSyncStream *)
     * }
     */
    public static void SyncStream_GetImpl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SyncStream_GetImpl$LAYOUT, SyncStream_GetImpl$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint64_t (*SyncStream_GetSyncId)(const OrtSyncStream *)
     * }
     */
    public final static class SyncStream_GetSyncId {

        private SyncStream_GetSyncId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SyncStream_GetSyncId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SyncStream_GetSyncId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SyncStream_GetSyncId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SyncStream_GetSyncId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t (*SyncStream_GetSyncId)(const OrtSyncStream *)
     * }
     */
    public static final AddressLayout SyncStream_GetSyncId$layout() {
        return SyncStream_GetSyncId$LAYOUT;
    }

    private static final long SyncStream_GetSyncId$OFFSET = $LAYOUT.byteOffset(groupElement("SyncStream_GetSyncId"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t (*SyncStream_GetSyncId)(const OrtSyncStream *)
     * }
     */
    public static final long SyncStream_GetSyncId$offset() {
        return SyncStream_GetSyncId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t (*SyncStream_GetSyncId)(const OrtSyncStream *)
     * }
     */
    public static MemorySegment SyncStream_GetSyncId(MemorySegment struct) {
        return struct.get(SyncStream_GetSyncId$LAYOUT, SyncStream_GetSyncId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t (*SyncStream_GetSyncId)(const OrtSyncStream *)
     * }
     */
    public static void SyncStream_GetSyncId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SyncStream_GetSyncId$LAYOUT, SyncStream_GetSyncId$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint64_t (*GetSyncIdForLastWaitOnSyncStream)(const OrtSyncStream *, const OrtSyncStream *)
     * }
     */
    public final static class GetSyncIdForLastWaitOnSyncStream {

        private GetSyncIdForLastWaitOnSyncStream() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_LONG_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetSyncIdForLastWaitOnSyncStream.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSyncIdForLastWaitOnSyncStream.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSyncIdForLastWaitOnSyncStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSyncIdForLastWaitOnSyncStream"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t (*GetSyncIdForLastWaitOnSyncStream)(const OrtSyncStream *, const OrtSyncStream *)
     * }
     */
    public static final AddressLayout GetSyncIdForLastWaitOnSyncStream$layout() {
        return GetSyncIdForLastWaitOnSyncStream$LAYOUT;
    }

    private static final long GetSyncIdForLastWaitOnSyncStream$OFFSET = $LAYOUT.byteOffset(groupElement("GetSyncIdForLastWaitOnSyncStream"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t (*GetSyncIdForLastWaitOnSyncStream)(const OrtSyncStream *, const OrtSyncStream *)
     * }
     */
    public static final long GetSyncIdForLastWaitOnSyncStream$offset() {
        return GetSyncIdForLastWaitOnSyncStream$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t (*GetSyncIdForLastWaitOnSyncStream)(const OrtSyncStream *, const OrtSyncStream *)
     * }
     */
    public static MemorySegment GetSyncIdForLastWaitOnSyncStream(MemorySegment struct) {
        return struct.get(GetSyncIdForLastWaitOnSyncStream$LAYOUT, GetSyncIdForLastWaitOnSyncStream$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t (*GetSyncIdForLastWaitOnSyncStream)(const OrtSyncStream *, const OrtSyncStream *)
     * }
     */
    public static void GetSyncIdForLastWaitOnSyncStream(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSyncIdForLastWaitOnSyncStream$LAYOUT, GetSyncIdForLastWaitOnSyncStream$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

