<!-- prettify js and CSS -->
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=scala"></script>

<!-- scroll/follow sidebar -->
<script src="js/follow-sidebar.js" type="text/javascript"></script>

<div class="col-md-3 col-md-push-9 hidden-xs hidden-sm">
    <div id="sidebar">
        <div class="sidebar-toc" style="margin-bottom: 20px;">
            <p class="toc-header">Contents</p>
            <div id="toc"></div>
        </div>
        <div id="search">
            <script>
                (function() {
                    var cx = '010264411143030149390:ajvee_ckdzs';
                    var gcse = document.createElement('script');
                    gcse.type = 'text/javascript';
                    gcse.async = true;
                    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//cse.google.com/cse.js?cx=' + cx;
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(gcse, s);
                })();
            </script>
            <gcse:searchbox-only></gcse:searchbox-only>
        </div>
    </div>
</div>

<div class="col-md-9 col-md-pull-3">
    <h1 id="clustering-top" class="title">Clustering</h1>

    <p>Clustering is the assignment of a set of observations
        into subsets (called clusters) so that observations in the same cluster are
        similar in some sense. Clustering is a method of unsupervised learning,
        and a common technique for statistical data analysis used in many fields.</p>

    <p>Hierarchical algorithms find successive clusters using previously
        established clusters. These algorithms usually are either agglomerative
        ("bottom-up") or divisive ("top-down"). Agglomerative algorithms begin
        with each element as a separate cluster and merge them into successively
        larger clusters. Divisive algorithms begin with the whole set and proceed
        to divide it into successively smaller clusters.</p>

    <p>Partitional algorithms typically determine all clusters at once, but can
        also be used as divisive algorithms in the hierarchical clustering.
        Many partitional clustering algorithms require the specification of
        the number of clusters to produce in the input data set, prior to
        execution of the algorithm. Barring knowledge of the proper value
        beforehand, the appropriate value must be determined, a problem on
        its own for which a number of techniques have been developed.</p>

    <p>Density-based clustering algorithms are devised to discover
        arbitrary-shaped clusters. In this approach, a cluster is regarded as
        a region in which the density of data objects exceeds a threshold.</p>

    <p>Subspace clustering methods look for clusters that can only be seen in
        a particular projection (subspace, manifold) of the data. These methods
        thus can ignore irrelevant attributes. The general problem is also known
        as Correlation clustering while the special case of axis-parallel subspaces
        is also known as two-way clustering, co-clustering or biclustering in
        bioinformatics: in these methods not only the objects are clustered but
        also the features of the objects, i.e., if the data is represented in
        a data matrix, the rows and columns are clustered simultaneously. They
        usually do not however work with arbitrary feature combinations as in general
        subspace methods.</p>

    <h2 id="hierarchical">Agglomerative Hierarchical Clustering</h2>

    <p>Agglomerative hierarchical clustering
        seeks to build a hierarchy of clusters in a bottom up approach: each
        observation starts in its own cluster, and pairs of clusters are merged as
        one moves up the hierarchy. The results of hierarchical clustering are
        usually presented in a dendrogram.</p>

    <p>In general, the merges are determined in a greedy manner. In order to decide
        which clusters should be combined, a measure of dissimilarity between sets
        of observations is required. In most methods of hierarchical clustering,
        this is achieved by use of an appropriate metric, and a linkage criteria
        which specifies the dissimilarity of sets as a function of the pairwise
        distances of observations in the sets.</p>

    <p>Hierarchical clustering has the distinct advantage that any valid measure
        of distance can be used. In fact, the observations themselves are not
        required: all that is used is a matrix of distances.</p>

    <pre class="prettyprint lang-scala"><code>
    def hclust(proximity: Array[Array[Double]], linkage: String): HierarchicalClustering
    </code></pre>

    <p>The parameter <code>proximity</code> is the proximity matrix to store
        the distance measure of dissimilarity. To save space, we only need
        the lower half of matrix. The proximity matrix can be calculated by
        the helper function:</p>

    <pre class="prettyprint lang-scala"><code>
    def proximity[T](data: Array[T], dist: Distance[T], half: Boolean = true): Array[Array[Double]]
    </code></pre>

    <p>If the parameter <code>half</code> is true, only the lower half of matrix
        is allocated to save space. In case of Euclidean distance, one may use</p>

    <pre class="prettyprint lang-scala"><code>
    def distance(data: Array[Array[Double]], half: Boolean = true): Array[Array[Double]]
    </code></pre>

    <p>The parameter <code>linkage</code> specifies the agglomeration method to merge clusters.
        This should be one of "single", "complete", "upgma"/"average", "upgmc"/"centroid", "wpgma", "wpgmc"/"median", and "ward".</p>

    <p>The single linkage defines the distance between groups as the distance
        between the closest pair of objects, one from each group.
        A drawback of this method is the so-called chaining phenomenon: clusters
        may be forced together due to single elements being close to each other,
        even though many of the elements in each cluster may be very distant to
        each other.</p>

    <p>Single linkage clustering is essentially the same as Kruskal's algorithm
        for minimum spanning trees. However, in single linkage clustering, the
        order in which clusters are formed is important, while for minimum spanning
        trees what matters is the set of pairs of points that form distances chosen
        by the algorithm.</p>

    <p>The complete linkage is the opposite of single linkage. Distance between
        groups is now defined as the distance between the most distant pair of
        objects, one from each group.</p>

    <p>UPGMA (Unweighted Pair Group Method with Arithmetic mean, also known as average linkage)
        defines the distance between two clusters as the mean distance between all possible
        pairs of nodes in the two clusters.</p>

    <p>In bioinformatics, UPGMA is used for the creation of phenetic trees
        (phenograms). UPGMA assumes a constant rate of evolution (molecular
        clock hypothesis), and is not a well-regarded method for inferring
        relationships unless this assumption has been tested and justified
        for the data set being used.</p>

    <p>UPGMC (Unweighted Pair Group Method using Centroids, also known as centroid linkage)
        defines the distance between two clusters as the Euclidean distance between their
        centroids, as calculated by arithmetic mean. Only valid for Euclidean
        distance based proximity matrix.</p>

    <p>WPGMA (Weighted Pair Group Method with Arithmetic mean) down-weights the
        largest group by giving equal weights to the two branches of the dendrogram
        that are about to fuse.</p>

    <p>Note that the terms weighted and unweighted refer to the final result,
        not the math by which it is achieved. Thus the simple averaging in WPGMA
        produces a weighted result, and the proportional averaging in UPGMA produces
        an unweighted result.</p>

    <p>WPGMC (Weighted Pair Group Method using Centroids, also known as median linkage)
        defines the distance between two clusters as the Euclidean distance between their
        weighted centroids. Only valid for Euclidean distance based proximity matrix.</p>

    <p>Ward's linkage. Ward's linkage follows the analysis of variance approach
        The dissimilarity between two clusters is computed as the
        increase in the "error sum of squares" (ESS) after fusing two clusters
        into a single cluster. Ward's Method seeks to choose the successive
        clustering steps so as to minimize the increase in ESS at each step.
        Note that it is only valid for Euclidean distance based proximity matrix.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/six.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">Mixture of Six Gaussians</div>
    </div>

    <p>To visualize the clustering results, we apply hierarchical clustering
        to 2d data in the following. The data is generated from six Gaussian
        distributions, each 300 samples.</p>

    <pre class="prettyprint lang-scala"><code>
    val x = readTable("data/clustering/gaussian/six.txt").unzip
    val clusters = hclust(pdist(x), "complete")
    dendrogram(clusters)
    </code></pre>

    <p>The clustering results can be visualized by a hendroagram, which
        is a tree diagram to illustrate the arrangement
        of the clusters produced by hierarchical clustering.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/hclust-dendrogram.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">Dendrogram</div>
    </div>

    <p>If a hard partition is need, we can cut a hierarchical clustering tree
        into several groups by specifying the desired number or the cut height.</p>

    <pre class="prettyprint lang-scala"><code>
    val y = clusters.partition(6)
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <p>The partitioning of six clusters is shown as</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/hclust-six.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">Hierarchical Clustering</div>
    </div>

    <h2 id="k-means">K-Means</h2>

    <p>K-Means clustering partitions <code>n</code> observations into <code>k</code> clusters in which
        each observation belongs to the cluster with the nearest mean.
        Although finding an exact solution to the K-Means problem for arbitrary
        input is NP-hard, the standard approach to finding an approximate solution
        (often called Lloyd's algorithm or the K-Means algorithm) is used widely
        and frequently finds reasonable solutions quickly.</p>

    <p>K-Means is a hard clustering method, i.e. each sample is assigned to
        a specific cluster. In contrast, soft clustering, e.g. the
        Expectation-Maximization algorithm for Gaussian mixtures, assign samples
        to different clusters with different probabilities.</p>

    <p>The K-Means algorithm has at least two major theoretic shortcomings:</p>
    <ul>
        <li>First, it has been shown that the worst case running time of the
            algorithm is super-polynomial in the input size.</li>

        <li>Second, the approximation found can be arbitrarily bad with respect
            to the objective function compared to the optimal learn.</li>
    </ul>

    <p>In Smile, we use K-Means++ which addresses the second of these
        obstacles by specifying a procedure to initialize the cluster centers before
        proceeding with the standard K-Means optimization iterations. With the
        K-Means++ initialization, the algorithm is guaranteed to find a solution
        that is O(log k) competitive to the optimal K-Means solution.</p>

    <p>We also use K-D trees to speed up each K-Means step as described in the filter
        algorithm by Kanungo, et al.</p>

    <pre class="prettyprint lang-scala"><code>
    def kmeans(data: Array[Array[Double]], k: Int, maxIter: Int = 100, runs: Int = 1): KMeans
    </code></pre>

    <p>The parameter <code>maxIter</code> specifies the maximum number of iterations.
        If the output of K-Means is used to initialize other algorithms, a small number (says 20)
        is usually sufficient. In practice, we often run the K-Means multiple times
        and choose the best one. To do that, set the parameter <code>runs &gt; 1</code>
        (e.g. 10 ~ 20).</p>

    <pre class="prettyprint lang-scala"><code>
    val clusters = kmeans(x, 6, runs = 20)
    val y = clusters.getClusterLabel
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <p>K-Means works very well on Gaussian mixtures.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/kmeans-six.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">K-Means on Gaussian Mixture</div>
    </div>

    <p>If the clusters are elongated, however, the results may be far from optimal.</p>

    <pre class="prettyprint lang-scala"><code>
    val x = readTable("data/clustering/gaussian/elongate.txt").unzip
    val clusters = kmeans(x, 2, runs = 20)
    val y = clusters.getClusterLabel
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/kmeans-elongate.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">K-Means on 2 Elongate Clusters</div>
    </div>

    <p>In K-Means, the number of clusters <code>K</code> has to be supplied by the user.
        However, the appropriate number of clusters is often unknown in practice.
        Several approaches (e.g. X-Means, G-Means, deterministic annealing, etc.)
        have been proposed to handle this challenge.</p>

    <h2 id="x-means">X-Means</h2>

    <p>X-Means clustering algorithm is an extended K-Means which tries to
        automatically determine the number of clusters based on BIC scores.
        Starting with only one cluster, the X-Means algorithm goes into action
        after each run of K-Means, making local decisions about which subset of the
        current centroids should split themselves in order to better fit the data.
        The splitting decision is done by computing the Bayesian Information
        Criterion (BIC).</p>

    <pre class="prettyprint lang-scala"><code>
    def xmeans(data: Array[Array[Double]], k: Int = 100): XMeans
    </code></pre>

    <p>where the parameter <code>k</code> is the maximum number of clusters</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/xmeans-six.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">X-Means</div>
    </div>

    <h2 id="g-means">G-Means</h2>

    <p>G-Means clustering algorithm is another extended K-Means which tries to
        automatically determine the number of clusters by normality test.
        The G-Means algorithm is based on a statistical test for the hypothesis
        that a subset of data follows a Gaussian distribution. G-Means runs
        K-Means with increasing k in a hierarchical fashion until the test accepts
        the hypothesis that the data assigned to each K-Means center are Gaussian.</p>

    <pre class="prettyprint lang-scala"><code>
    def gmeans(data: Array[Array[Double]], k: Int = 100): XMeans
    </code></pre>

    <p>where the parameter <code>k</code> is the maximum number of clusters</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/gmeans-six.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">G-Means</div>
    </div>

    <p>Neither X-Means nor G-Means works well on the elongate data. Both report only
        one cluster.</p>

    <h2 id="deterministic-annealing">Deterministic Annealing Clustering</h2>

    <p>The observation of annealing processes in physical chemistry motivated
        the use of similar concepts to avoid local minima of the optimization cost.
        Certain chemical systems can be driven to their low-energy states
        by annealing, which is a gradual reduction of temperature,
        spending a long time at the vicinity of the phase transition points.
        In the corresponding probabilistic framework, a Gibbs distribution
        is defined over the set of all possible configurations which assigns
        higher probability to configurations of lower energy. This distribution
        is parameterized by the temperature, and as the temperature is lowered
        it becomes more discriminating (concentrating most of the probability
        in a smaller subset of low-energy configurations). At the limit of
        low temperature it assigns nonzero probability only to global minimum
        configurations.</p>

    <p>A known technique for nonconvex optimization that
        capitalizes on this physical analogy is simulated annealing based on
        the Metropolis algorithm. A sequence of random
        moves is generated and the random decision to accept a move depends
        on the cost of the resulting configuration relative to that of the
        current state. However, one must be very careful with the annealing
        schedule, i.e., the rate at which the temperature is lowered.
        In theory, the global minimum can be achieved if the schedule obeys
        <code>T &prop; 1 / log n</code>, where <code>n</code> is the number
        of the current iteration. Such schedules are not realistic in many applications.
        It was shown that perturbations of infinite variance (e.g., the Cauchy distribution)
        provide better ability to escape from minima and allow, in principle,
        the use of faster schedules.</p>

    <p>Deterministic annealing tries to enjoy the best of both worlds.
        On the one hand it is deterministic, meaning that we do not want
        to be wandering randomly on the energy surface while making
        incremental progress on the average, as is the case for simulated annealing.
        On the other hand, it is still an annealing method and aims at the global
        minimum, instead of getting greedily attracted to a nearby local minimum.
        One can view deterministic annealing as replacing stochastic simulations by the use of expectation.
        An effective energy function, which is parameterized by a (pseudo) temperature,
        is derived through expectation and is deterministically optimized at successively
        reduced temperatures.</p>

    <p>Deterministic annealing clustering is based on principles of information theory
        and probability theory, and it consists of minimizing the clustering cost
        at prescribed levels of randomness.
        The method provides soft clustering solutions at different scales,
        where the scale is directly related to the temperature parameter.
        For each temperature value, the algorithm iterates between the calculation
        of all posteriori probabilities and the update of the centroids vectors,
        until convergence is reached.
        There are "phase transitions" in the design process, where phases
        correspond to the number of effective clusters in the solution,
        which grows via splits as the temperature is lowered.
        The annealing starts with a high temperature.
        Here, all centroids vectors converge to the center of the pattern
        distribution (independent of their initial positions). Below a critical
        temperature the vectors start to split. Further decreasing the temperature
        leads to more splittings until all centroids vectors are separate. The
        annealing can therefore avoid (if it is sufficiently slow) the convergence
        to local minima. If a limitation on the number of clusters is imposed,
        then at zero temperature a hard clustering solution is obtained.</p>

    <pre class="prettyprint lang-scala"><code>
    def dac(data: Array[Array[Double]], k: Int, alpha: Double): DeterministicAnnealing
    </code></pre>

    <p>where <code>k</code> is the maximum number of clusters, and <code>alpha</code>
        is the annealing control parameter in (0, 1). The temperature <code>T</code>
        is decreasing as <code>T<sub>i+1</sub> = alpha * T<sub>i</sub></code>.</p>

    <pre class="prettyprint lang-scala"><code>
    smile> dac(x, 12, 0.9)

    Clusters of 1800 data points:
    0	  297 (16.5%)
    1	  449 (24.9%)
    2	  298 (16.6%)
    3	  152 ( 8.4%)
    4	  293 (16.3%)
    5	  311 (17.3%)
    6	    0 ( 0.0%)
    7	    0 ( 0.0%)
    8	    0 ( 0.0%)
    9	    0 ( 0.0%)
    10	    0 ( 0.0%)
    11	    0 ( 0.0%)
    </code></pre>

    <p>Note that we set <code>k = 12</code> in the example although we know there are 6 clusters.
        It is because we maintain two codevectors/centroids for each cluster for sake of split.
        The algorithm correctly figures out that half of them are ghost clusters without samples.
        In the output summary, the first column is the cluster id, the second column is the size
        of clusters, and the third column is the percentage of samples.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/deterministic-annealing.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">Deterministic Annealing</div>
    </div>

    <p>Although deterministic annealing is physical and mathematical sound, the results may
        not reveal the correct structure of data as shown in the above.</p>

    <h2 id="sib">Sequential Information Bottleneck</h2>

    <p>The Sequential Information Bottleneck (SIB) algorithm clusters co-occurrence
        data such as text documents vs words. SIB is guaranteed to converge to a local
        maximum of the information. Moreover, the time and space complexity are
        significantly improved in contrast to the agglomerative IB algorithm.</p>

    <p>In analogy to K-Means, SIB's update formulas are essentially same as the
        EM algorithm for estimating finite Gaussian mixture model by replacing
        regular Euclidean distance with Kullback-Leibler divergence, which is
        clearly a better dissimilarity measure for co-occurrence data. However,
        the common batch updating rule (assigning all instances to nearest centroids
        and then updating centroids) of K-Means won't work in SIB, which has
        to work in a sequential way (reassigning (if better) each instance then
        immediately update related centroids). It might be because K-L divergence
        is very sensitive and the centroids may be significantly changed in each
        iteration in batch updating rule.</p>

    <p>Note that this implementation has a little difference from the original
        paper, in which a weighted Jensen-Shannon divergence is employed as a
        criterion to assign a randomly-picked sample to a different cluster.
        However, this doesn't work well in some cases as we experienced probably
        because the weighted JS divergence gives too much weight to clusters which
        is much larger than a single sample. In this implementation, we instead
        use the regular/unweighted Jensen-Shannon divergence.</p>

    <pre class="prettyprint lang-scala"><code>
    def sib(data: Array[Array[Double]], k: Int, maxIter: Int = 100, runs: Int = 1): SIB
    def sib(data: SparseDataset, k: Int, maxIter: Int, runs: Int): SIB
    </code></pre>

    <p>The news data in <code>data/libsvm/news20.dat</code> is a very sparse data
        of dimension 62061. The data contains 15935 samples. The below example
        clusters it into 20 clusters.</p>

    <pre class="prettyprint lang-scala"><code>
    val data = readLibsvm("data/libsvm/news20.dat")
    val clusters = sib(train, 20, 100, 8)
    </code></pre>

    <h2 id="clarans">CLARANS</h2>

    <p>The K-Medoids algorithm is an adaptation of the k-means algorithm.
        Rather than calculate the mean of the items in each cluster,
        a representative item, or medoid, is chosen for each cluster
        at each iteration. The K-Medoids algorithm attempts
        to minimize the distance between points labeled to be in a cluster and
        the medoid of that cluster. So a medoid is a most centrally
        located point in the cluster. K-Medoids works with an arbitrary
        matrix of distances between data points instead of L<sub>2</sub>.
        It is also more robust to noise and outliers as compared to K-Means.</p>

    <p>The most common realisation of K-Medoids clustering is the Partitioning
        Around Medoids (PAM) algorithm. PAM uses a greedy search which may not
        find the optimum solution, but it is faster than exhaustive search.</p>

    <p>CLARANS (Clustering Large Applications based upon RANdomized Search) is a more
        efficient medoid-based clustering algorithm. In CLARANS, the process of finding
        <code>k</code> medoids from <code>n</code> objects is viewed abstractly
        as searching through a certain graph. In the graph, a node is represented
        by a set of <code>k</code> objects as selected medoids. Two
        nodes are neighbors if their sets differ by only one object. In each iteration,
        CLARANS considers a set of randomly chosen neighbor nodes as candidate
        of new medoids. We will move to the neighbor node if the neighbor
        is a better choice for medoids. Otherwise, a local optima is discovered. The
        entire process is repeated multiple time to find better.</p>

    <pre class="prettyprint lang-scala"><code>
    def clarans[T](data: Array[T], distance: Distance[T], k: Int, maxNeighbor: Int, numLocal: Int): CLARANS[T]

    // CLARANS with Euclidean distance
    def clarans(data: Array[Array[Double]], k: Int, maxNeighbor: Int, numLocal: Int): CLARANS[Array[Double]]
    </code></pre>

    <p>CLARANS has two parameters: the maximum number of neighbors examined
        (maxNeighbor) and the number of local minima obtained (numLocal). The
        higher the value of maxNeighbor, the closer is CLARANS to PAM, and the
        longer is each search of a local minima. But the quality of such a local
        minima is higher and fewer local minima needs to be obtained.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/clarans.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">CLARANS</div>
    </div>

    <p>The above clustering partition is achieved with <code>maxNeighbor = 10</code>
        and <code>numLocal = 20</code>.</p>

    <h2 id="birch">BIRCH</h2>

    <p>BIRCH (Balanced Iterative Reducing and Clustering using Hierarchies) performs
        hierarchical clustering over particularly large datasets. An advantage of
        BIRCH is its ability to incrementally and dynamically cluster incoming,
        multi-dimensional metric data points in an attempt to produce the high
        quality clustering for a given set of resources (memory and time constraints).</p>

    <p>BIRCH has several advantages. For example, each clustering decision is made
        without scanning all data points and currently existing clusters. It
        exploits the observation that data space is not usually uniformly occupied
        and not every data point is equally important. It makes full use of
        available memory to derive the finest possible sub-clusters while minimizing
        I/O costs. It is also an incremental method that does not require the whole
        data set in advance.</p>

    <pre class="prettyprint lang-scala"><code>
    def birch(data: Array[Array[Double]], k: Int, minPts: Int, branch: Int, radius: Double): BIRCH
    </code></pre>

    <p>This implementation produces a clustering in three steps. First step
        builds a CF (clustering feature) tree by a single scan of database.
        The second step clusters the leaves of CF tree by hierarchical clustering.
        Then the user can use the learned model to cluster input data in the final
        step. In total, we scan the database twice.</p>

    <p>A CF leaf will be treated as outlier if the number of its
        points is less than the parameter <code>minPts</code>.
        The branching factor parameter <code>branch</code> is the
        maximum number of children nodes and the parameter <code>radius</code>
        is the maximum radius of a sub-cluster.</p>

    <pre class="prettyprint lang-scala"><code>
    val clusters = birch(x, 6, 3, 10, 1)
    val y = x.map(clusters.predict(_)).toArray
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <p>Although BIRCH's Scala API provides a batch interface to cluster data,
        the algorithm itself is online (i.e. processing data point one by one).
        The user should use the method <code>predict</code> on the input (or
        new) data to get the cluster labels as shown in the above example.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/birch.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">BIRCH</div>
    </div>

    <p>Note that points in orange are outliers labeled by the algorithm.</p>

    <h2 id="dbscan">DBScan</h2>

    <p> DBScan (Density-Based Spatial Clustering of Applications with Noise)
        finds a number of clusters starting from the estimated density
        distribution of corresponding nodes.</p>

    <pre class="prettyprint lang-scala"><code>
    // DBScan with a customized data structure for neighborhood search
    def dbscan[T](data: Array[T], nns: RNNSearch[T, T], minPts: Int, radius: Double): DBScan[T]

    def dbscan[T](data: Array[T], distance: Metric[T], minPts: Int, radius: Double): DBScan[T]

    // DBScan with Euclidean distance
    def dbscan(data: Array[Array[Double]], minPts: Int, radius: Double): DBScan[Array[Double]]
    </code></pre>

    <p>DBScan requires two parameters: <code>radius</code> (i.e. neighborhood radius) and the
        number of minimum points required to form a cluster (<code>minPts</code>). It starts
        with an arbitrary starting point that has not been visited. This point's
        neighborhood is retrieved, and if it contains sufficient number of points,
        a cluster is started. Otherwise, the point is labeled as noise. Note that
        this point might later be found in a sufficiently sized radius-environment
        of a different point and hence be made part of a cluster.</p>

    <p>If a point is found to be part of a cluster, its neighborhood is also
        part of that cluster. Hence, all points that are found within the
        neighborhood are added, as is their own neighborhood. This process
        continues until the cluster is completely found. Then, a new unvisited point
        is retrieved and processed, leading to the discovery of a further cluster
        of noise.</p>

    <p>DBScan visits each point of the database, possibly multiple times (e.g.,
        as candidates to different clusters). For practical considerations, however,
        the time complexity is mostly governed by the number of nearest neighbor
        queries. DBScan executes exactly one such query for each point, and if
        an indexing structure is used that executes such a neighborhood query
        in <code>O(log n)</code>, an overall runtime complexity of <code>O(n log n)</code> is obtained.</p>

    <pre class="prettyprint lang-scala"><code>
    val x = readTable("data/clustering/chameleon/t4.8k.txt").unzip
    val clusters = dbscan(x, 20, 10)
    val y = clusters.getClusterLabel
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <p>The chameleon is a set of complicated spatial data of
        arbitrary cluster shapes. With appropriate parameters, DBScan
        can discover the correct clusters and also identify outliers.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/dbscan.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">DBScan</div>
    </div>

    <p>DBScan has many advantages such as</p>

     <ul>
         <li>DBScan does not need to know the number of clusters in the data
             a priori, as opposed to K-Means.</li>

         <li>DBScan can find arbitrarily shaped clusters. It can even find clusters
             completely surrounded by (but not connected to) a different cluster.
             Due to the <code>MinPts</code> parameter, the so-called single-link effect
             (different clusters being connected by a thin line of points) is reduced.</li>

         <li>DBScan has a notion of noise. Outliers are labeled as <code>Clustering.OUTLIER</code>,
             which is <code>Integer.MAX_VALUE</code>.</li>

         <li>DBScan requires just two parameters and is mostly insensitive to the
             ordering of the points in the database. (Only points sitting on the
             edge of two different clusters might swap cluster membership if the
             ordering of the points is changed, and the cluster assignment is unique
             only up to isomorphism.)</li>
     </ul>

    <p>On the other hand, DBScan has the disadvantages of</p>

    <ul>
        <li>In high dimensional space, the data are sparse everywhere
            because of the curse of dimensionality. Therefore, DBScan doesn't
            work well on high-dimensional data in general.

        <li>DBScan does not respond well to data sets with varying densities.
    </ul>

    <h2 id="denclue">DENCLUE</h2>

    <p>DENCLUE (DENsity CLUstering) employs a cluster model based on
        kernel density estimation. A cluster is defined by a local maximum of the
        estimated density function. Data points going to the same local maximum
        are put into the same cluster.
        DENCLUE works efficiently for high-dimensional data sets and allows arbitrary
        noise levels while still guaranteeing to find the clustering.</p>

    <pre class="prettyprint lang-scala"><code>
    def denclue(data: Array[Array[Double]], sigma: Double, m: Int): DENCLUE
    </code></pre>

    <p>The parameter <code>sigma</code> is the smooth parameter in the Gaussian kernel.
        The user can choose <code>sigma</code> such that number of density attractors
        is constant for a long interval of <code>sigma</code>.
        The parameter <code>m</code> is the number of selected samples used in the iteration.
        This number should be much smaller than the number of data points
        to speed up the algorithm. It should also be large enough to capture
        the sufficient information of underlying distribution.</p>

    <p>Clearly, DENCLUE doesn't work on data with uniform distribution. In high
        dimensional space, the data always look like uniformly distributed because
        of the curse of dimensionality. Therefore, DENCLUDE doesn't work well on
        high-dimensional data in general.</p>

    <pre class="prettyprint lang-scala"><code>
    val clusters = denclue(x, 1.0, 50)
    val y = clusters.getClusterLabel
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <p>DENCLUE doesn't directly label some data as outliers. However, it may report
        very small clusters, which could be regarded as outliers.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/denclue.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">DENCLUE</div>
    </div>

    <h2 id="spectral-clustering">Spectral Clustering</h2>

    <p>Given a set of data points, the similarity matrix may
        be defined as a matrix <code>S</code> where <code>S<sub>ij</sub></code>
        represents a measure of the
        similarity between points. Spectral clustering techniques make use of the
        spectrum of the similarity matrix of the data to perform dimensionality
        reduction for clustering in fewer dimensions. Then the clustering will
        be performed in the dimension-reduce space, in which clusters of non-convex
        shape may become tight. There are some intriguing similarities between
        spectral clustering methods and kernel PCA, which has been empirically
        observed to perform clustering.</p>

    <pre class="prettyprint lang-scala"><code>
    def specc(W: Array[Array[Double]], k: Int): SpectralClustering

    def specc(data: Array[Array[Double]], k: Int, sigma: Double): SpectralClustering

    // Nystrom approximation
    def specc(data: Array[Array[Double]], k: Int, l: Int, sigma: Double): SpectralClustering
    </code></pre>

    <p>where <code>W</code> is the adjacency matrix of graph. The user may also
        provides the raw input <code>data</code> and the smooth/width parameter <code>sigma</code>
        of Gaussian kernel, which is a somewhat sensitive parameter. To search for the best setting,
        one may pick the value that gives the tightest clusters (smallest
        distortion, reported by the method <code>distortion</code>) in feature space.
        Spectral clustering is memory intensive because of the adjacency matrix.
        For large data, one may use Nystrom approximation by selecting some
        random samples. The parameter <code>l</code> specifies the number of
        random samples.</p>

    <pre class="prettyprint lang-scala"><code>
    val x = readTable("data/clustering/nonconvex/sincos.txt").unzip
    val clusters = specc(x, 2, 0.2)
    val y = clusters.getClusterLabel
    plot(x, y, 'o', Palette.COLORS)
    </code></pre>

    <p>For this nonconvex data, spectral clustering works very well with appropriate smooth parameter.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/spectral-clustering.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">Spectral Clustering</div>
    </div>

    <h2 id="mec">Minimum Entropy Clustering</h2>

    <p>In this algorithm, the clustering criterion is based on the conditional entropy
        <code>H(C | x)</code>, where <code>C</code> is the cluster label and
        <code>x</code> is an observation. According to Fano's
        inequality, we can estimate <code>C</code> with a low probability of error only if the
        conditional entropy <code>H(C | x)</code> is small.
        Minimum Entropy Clustering (MEC) also generalizes the criterion
        by replacing Shannon's entropy with Havrda-Charvat's structural
        <code>&alpha;</code>-entropy. Interestingly, the minimum entropy criterion based
        on structural <code>&alpha;</code>-entropy is equal to the probability error of the
        nearest neighbor method when <code>&alpha;</code>= 2. To estimate
        <code>p(C | x)</code>, MEC employs
        Parzen density estimation, a nonparametric approach.</p>

    <p>This method performs
        very well especially when the exact number of clusters is unknown.
        The method can also correctly reveal the structure of data and effectively
        identify outliers simultaneously.</p>

    <pre class="prettyprint lang-scala"><code>
    def mec[T](data: Array[T], distance: Distance[T], k: Int, radius: Double): MEC[T]
    def mec[T](data: Array[T], distance: Metric[T], k: Int, radius: Double): MEC[T]
    def mec[T](data: Array[T], nns: RNNSearch[T, T], k: Int, radius: Double, y: Array[Int]): MEC[T]
    def mec(data: Array[Array[Double]], k: Int, radius: Double): MEC[Array[Double]]
    </code></pre>

    <p>MEC is an iterative algorithm starting with an initial partition given by
        any other clustering methods, e.g. K-Means, CLARNAS, hierarchical clustering,
        etc. Note that a random initialization is NOT appropriate.</p>

    <pre class="prettyprint lang-scala"><code>
    val x = readTable("data/clustering/gaussian/six.txt").unzip
    val clusters = mec(x, 20, 2.0)
    val y = clusters.getClusterLabel
    plot(x, y, '.', Palette.COLORS)
    </code></pre>

    <p>Note that we use <code>k = 20</code> for this data and the algorithm still successfully
        finds the correct structure of data. In practice, we rarely know the right number of
        clusters in advance. With MEC, one may starts with a large <code>k</code> and the algorithm
        often can automatically remove unnecessary clusters and reach a lower entropy state.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/mec.png" class="enlarge" style="width: 480px;" />
        <div class="caption" style="min-width: 480px;">MEC</div>
    </div>

    <div id="btnv">
        <span class="btn-arrow-left">&larr; &nbsp;</span>
        <a class="btn-prev-text" id="missing-value-imputation" href="#" title="Previous Section: Missing Value Imputation"><span>Missing Value Imputation</span></a>
        <a class="btn-next-text" id="vector-quantization" href="#" title="Next Section: Vector Quantization"><span>Vector Quantization</span></a>
        <span class="btn-arrow-right">&nbsp;&rarr;</span>
    </div>
</div>

<script type="text/javascript">
    $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>