<div class="col-md-3 col-md-push-9 hidden-xs hidden-sm">
    <div id="sidebar">
        <div class="sidebar-toc" style="margin-bottom: 20px;">
            <p class="toc-header">Contents</p>
            <div id="toc"></div>
        </div>
        <div id="search">
            <script>
                (function() {
                    var cx = '010264411143030149390:ajvee_ckdzs';
                    var gcse = document.createElement('script');
                    gcse.type = 'text/javascript';
                    gcse.async = true;
                    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//cse.google.com/cse.js?cx=' + cx;
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(gcse, s);
                })();
            </script>
            <gcse:searchbox-only></gcse:searchbox-only>
        </div>
    </div>
</div>

<div class="col-md-9 col-md-pull-3">
    <h1 id="faq-top" class="title">FAQ</h1>

    <h2 class="question" id="link-with-smile">Link with Smile</h2>
    <p class="answer">
        Smile artifacts are hosted in <a href="https://oss.sonatype.org/#nexus-search;quick~smile-core">Sonatype Nexus</a>.
        You can add the following dependency into your pom.xml:</p>

    <pre><code>
    &lt;dependency&gt;
      &lt;groupId&gt;com.github.haifengl&lt;/groupId&gt;
      &lt;artifactId&gt;smile-core&lt;/artifactId&gt;
      &lt;version&gt;1.5.0&lt;/version&gt;
    &lt;/dependency&gt;
    </code></pre>

    <p>If you're using SBT, add the following line into your build file:</p>

    <pre><code>
    libraryDependencies += "com.github.haifengl" % "smile-core" % "1.5.0"
    </code></pre>

    <p>For Scala API,</p>

    <pre><code>
    libraryDependencies += "com.github.haifengl" %% "smile-scala" % "1.5.0"
    </code></pre>

    <p>To enable machine optimised matrix computation, the users should add
        the dependency of smile-netlib:</p>
    <pre><code>
    &lt;dependency&gt;
      &lt;groupId&gt;com.github.haifengl&lt;/groupId&gt;
      &lt;artifactId&gt;smile-netlib&lt;/artifactId&gt;
      &lt;version&gt;1.5.0&lt;/version&gt;
    &lt;/dependency&gt;
    </code></pre>
    <p>and also make their machine-optimised libblas3 (CBLAS) and liblapack3 (Fortran)
        available as shared libraries at runtime. This module employs the highly efficient
        <a href="https://github.com/fommil/netlib-java#netlib-java">netlib-java</a>
        library.</p>

    <h3>OS X</h3>
    <p>Apple OS X requires no further setup as it ships with the veclib framework.</p>

    <h3>Linux</h3>
    <p>Generically-tuned ATLAS and OpenBLAS are available with most distributions
        and must be enabled explicitly using the package-manager. For example,</p>

    <pre><code>
    sudo apt-get install libatlas3-base libopenblas-base
    sudo update-alternatives --config libblas.so
    sudo update-alternatives --config libblas.so.3
    sudo update-alternatives --config liblapack.so
    sudo update-alternatives --config liblapack.so.3
    </code></pre>

    <p>However, these are only generic pre-tuned builds. If you have an Intel MKL licence,
    you could also create symbolic links from libblas.so.3 and liblapack.so.3 to libmkl_rt.so
    or use Debian's alternatives system.</p>

    <h3>Windows</h3>
    <p>The native_system builds expect to find libblas3.dll and liblapack3.dll
        on the %PATH% (or current working directory). Besides vendor-supplied
        implementations, OpenBLAS provide generically tuned binaries, and it
        is possible to build ATLAS.</p>

    <h2 class="question" id="model-serialization">Model serialization</h2>
    <p class="answer">To serialize a model, you may use</p>
    <pre class="prettyprint lang-scala"><code>
    write(model, file)
    </code></pre>
    <p>This method is in the Scala API <code>smile.write</code> object and serialize the model to Java
    serialization format. This is handy if you want to use a model in Spark.</p>

    <p>Alternatively, you can also use</p>
    <pre class="prettyprint lang-scala"><code>
    write.xstream(model, file)
    </code></pre>

    <p>which uses XStream library to serialize the model (actually any objects) to XML file.</p>

    <p>To read the model back, you can use <code>read(file)</code> or <code>read.xstream(file)</code>, correspondingly.</p>

    <h2 class="question" id="data-format">Data Format</h2>
    <p class="answer">
        Most Smile algorithms take simple <code>double[]</code> as input. So you can use your favorite methods
        or library to import the data as long as the samples are in double arrays. Meanwhile, Smile provides
        a couple of parsers for popular data formats, such as Weka's ARFF files, LibSVM's file format,
        delimited text files, and binary sparse data. These classes are in the package <code>smile.data.parser</code>
        and <code>smile.io</code> provides high level operators on top of these parsers. The package
        <code>smile.data.parser.microarray</code> also provides several parsers for microarray gene expression datasets,
        including GCT, PCL, RES, and TXT files.</p>

    <h2 class="question" id="pom">Cannot build Smile with maven</h2>
    <p class="answer">
        We have moved to SBT to build packages. The maven pom.xml files were deprecated and were removed in v1.2.0.
    </p>

    <h2 class="question" id="sbt-pgp">sbt error "not found: value useGpg"</h2>
    <p class="answer">
        Smile uses <a href="http://www.scala-sbt.org/sbt-pgp/">sbt-pgp</a> plugin when
        publishing to maven central repository. Although you will not publish the project,
        you still have to set up sbt-pgp in order to build the packages. Fortunately, it is
        very easy. Simply add the following to your <code>~/.sbt/0.13/plugins/gpg.sbt</code> file:
    </p>

    <pre class="prettyprint lang-scala"><code>
    addSbtPlugin("com.jsuereth" % "sbt-pgp" % "1.0.0")
    </code></pre>

    <h2 class="question" id="headless-plot">Headless Plot</h2>
    <p class="answer">
        In case that your environment does not have a display or you need to generate and save
        a lot of plots without showing them on the screen, you may run Smile in headless model.
    </p>

    <pre class="prettyprint lang-bash"><code>
    bin/smile -Djava.awt.headless=true
    </code></pre>

    <p>The following example shows how to save a plot in the headless mode.</p>

    <pre class="prettyprint lang-scala"><code>
    val toy = read.table("data/classification/toy/toy-train.txt", Some((new NominalAttribute("class"), 0)))
    val (x, y) = toy.unzipInt

    val canvas = ScatterPlot.plot(x, y, '*', Array(Color.RED, Color.BLUE))

    val headless = new Headless(canvas);
    headless.pack();
    headless.setVisible(true);

    canvas.save(new java.io.File("headless.png"))
    </code></pre>

</div>

<script type="text/javascript">
    $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>
